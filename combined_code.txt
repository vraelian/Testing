--- START OF FILE: ./index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="manifest" href="manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Orbital Trading 27.10</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19"></script>
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;700&family=Orbitron:wght@500;700&family=Roboto+Mono:wght@400;700&family=Aldrich&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./css/global.css">
    <link rel="stylesheet" href="./css/navigation.css">
    <link rel="stylesheet" href="./css/modals.css">
    <link rel="stylesheet" href="./css/hud.css">
    <link rel="stylesheet" href="./css/missions.css">
    <link rel="stylesheet" href="./css/tutorial.css">
    <link rel="stylesheet" href="./css/debug.css">
    <link rel="stylesheet" href="./css/screens/market-screen.css">
    <link rel="stylesheet" href="./css/screens/hangar-screen.css">
    <link rel="stylesheet" href="./css/screens/navigation-screen.css">
    <link rel="stylesheet" href="./css/screens/finance-screen.css">
    <link rel="stylesheet" href="./css/screens/intel-screen.css">
    <link rel="stylesheet" href="./css/screens/status-screen.css">
    <link rel="stylesheet" href="./css/screens/services-screen.css">
    <link rel="stylesheet" href="./css/screens/cargo-screen.css">
    <link rel="icon" href="./favicon.svg" type="image/svg+xml">
</head>
<body>

    <div id="splash-screen" class="fixed inset-0 z-50 flex flex-col items-center justify-center p-8 text-center bg-[#0c101d]">
        <div class="max-w-3xl w-full panel-border border border-slate-700 bg-black/30 p-8 md:p-12 rounded-lg btn-pulse">
            <h1 class="text-6xl md:text-7xl font-orbitron font-bold text-cyan-300 mb-2">Orbital Trading</h1>
            <p class="text-xl md:text-2xl text-gray-400 mb-16"><span class="hl">A game of heliocentric adventure & arbitrage</span></p>
          
    
            <div class="flex flex-col items-center gap-4 w-full max-w-sm mx-auto">
                <button id="start-game-btn" class="btn btn-header btn-pulse w-full">Start Game</button>
                <button class="btn btn-header w-full" disabled>Load Game</button>
                <button class="btn btn-header w-full" disabled>Options</button>
            </div>
    
        </div>

        <footer class="absolute bottom-4 text-center text-slate-500 text-sm w-full">
            <p>Version 27.10</p>
            <a href="https://docs.google.com/forms/d/e/1FAIpQLSeVqjUEC6nsZlxTQ9-vzz0_fHO0ng8w0AueZaGzkHPoLJIBDA/viewform?usp=header" target="_blank" class="hover:text-cyan-300 transition-colors"><span class="hl">Submit Playtesting Feedback</span></a>
        </footer>
    </div>
    
    <div id="save-toast" class="hidden fixed top-5 left-1/2 -translate-x-1/2 bg-cyan-500/80 text-white px-6 py-2 rounded-lg shadow-lg transition-all duration-300 pointer-events-none z-50">Checkpoint Saved</div>
    <div id="garnishment-toast" class="hidden fixed top-5 left-1/2 -translate-x-1/2 text-white px-6 py-2 rounded-lg shadow-lg transition-all duration-300 pointer-events-none z-50"></div>
    <div id="hull-warning-toast" class="hidden fixed top-20 left-1/2 -translate-x-1/2 text-white px-6 py-2 rounded-lg shadow-lg transition-all duration-300 pointer-events-none z-50"></div>
    <div id="starport-unlock-tooltip" class="hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-gray-900/90 text-white px-6 py-3 rounded-lg shadow-lg transition-all duration-300 pointer-events-none z-50 border border-yellow-500 text-center">
        Pay off your initial loan to access the Starport!
    </div>

    <main id="game-container" class="game-container hidden">
        <div id="top-bar-container">
            <header id="header-main" class="relative">
                <div id="nav-bar"></div>
                <div id="sub-nav-bar"></div>
            </header>
            <div id="sticky-bar"></div>
        </div>
        
        <div class="main-content-wrapper px-4 md:px-8 pb-4 md:pb-8">
            <div id="main-content">
                <div id="status-screen" class="screen"></div>
                <div id="navigation-screen" class="screen"></div>
                <div id="services-screen" class="screen"></div>
               
                <div id="market-screen" class="screen"></div>
                <div id="cargo-screen" class="screen"></div>
                <div id="hangar-screen" class="screen"></div>

                <div id="missions-screen" class="screen"></div>
                <div id="finance-screen" class="screen"></div>
                <div id="intel-screen" class="screen"></div>
            </div>
        </div>

        <div id="mission-modal" class="modal-backdrop hidden">
            <div class="modal-content sci-fi-frame flex flex-col items-center text-center">
                <div class="modal-header">
                    <div>
                        <h3 id="mission-modal-title" class="text-xl font-orbitron mb-1"></h3>
                        <p id="mission-modal-type" class="mission-type"></p>
                    </div>
                    
                </div>
                <p id="mission-modal-description" class="my-4 text-gray-300"></p>
                <div id="mission-modal-objectives"></div>
                <div id="mission-modal-rewards" class="reward-section mb-4"></div>
                <div id="mission-modal-buttons" class="mt-4"></div>
            </div>
        </div>
    </main>
    <div id="mission-sticky-bar" class="bottom-sticky-bar">
        <div class="sticky-content sci-fi-frame">
            <p id="sticky-objective-text"></p>
            <p id="sticky-objective-progress" class="font-roboto-mono"></p>
        </div>
    </div>

    <div id="travel-animation-modal" class="modal-backdrop hidden">
        <div id="travel-animation-content" class="modal-content">
            <div id="travel-header-panel">
                <h3 id="travel-status-text" class="text-2xl font-orbitron text-cyan-300"></h3>
                <p id="travel-arrival-lore" class="text-base text-gray-300 italic mt-2"></p>
            </div>
            <canvas id="travel-canvas"></canvas>
            <div id="travel-footer-panel">
                <div id="travel-progress-container" class="w-full bg-slate-700 rounded-full h-1.5">
                    <div id="travel-progress-bar" class="bg-cyan-400 h-1.5 rounded-full" style="width: 0%"></div>
                </div>
                <div id="travel-readout-container" class="hidden">
                    <p id="travel-info-text" class="text-base font-roboto-mono"></p>
                    <p id="travel-hull-damage" class="text-sm font-roboto-mono mt-1"></p>
                </div>
                <button id="travel-confirm-button" class="btn px-8 py-2 mt-4">Enter Station</button>
            </div>
        </div>
    </div>

    <dialog id="name-modal" class="modal-backdrop hidden">
        <div class="modal-content">
            <h3 class="text-2xl font-orbitron mb-4 text-cyan-300">What is your name, Spacer?</h3>
            <input type="text" id="player-name-input" maxlength="18" class="w-full p-2 rounded bg-slate-900 border border-slate-600 text-center text-lg mb-4 text-gray-200" placeholder="Enter name...">
            <div id="name-modal-buttons" class="mt-4 flex flex-col sm:flex-row justify-center items-center gap-4"></div>
        </div>
    </dialog>

    <div id="event-modal" class="modal-backdrop hidden">
        <div class="modal-content">
            <h3 id="event-title" class="text-2xl font-orbitron mb-4 text-cyan-300"></h3>
            <p id="event-description" class="mb-6 text-lg"></p>
            <div id="event-button-container" class="mt-6 flex justify-center gap-4"></div>
        </div>
    </div>

    <div id="charter-modal" class="modal-backdrop hidden modal-theme-gold">
        <div class="modal-content">
            <h3 id="charter-title" class="text-2xl font-orbitron mb-4 text-gray-300"></h3>
            <div id="charter-description" class="mb-6 text-lg"></div>
            <div id="charter-button-container" class="mt-6 flex justify-center gap-4"></div>
        </div>
    </div>

    <div id="signature-modal" class="modal-backdrop hidden modal-theme-gold">
        <div class="modal-content">
            <h3 id="signature-title" class="text-2xl font-orbitron mb-4 text-gray-300"></h3>
            <div id="signature-description" class="mb-6 text-lg"></div>
            <input type="text" id="signature-input" maxlength="18" class="w-full p-2 rounded text-center text-lg mb-4 text-gray-200" placeholder="INPUT YOUR NAME...">
            <div id="signature-button-container" class="mt-6 flex justify-center gap-4"></div>
        </div>
    </div>

    <div id="processing-modal" class="modal-backdrop hidden">
        <div class="modal-content modal-theme-admin">
            <h3 id="processing-title" class="text-xl font-orbitron mb-4 text-gray-300"></h3>
            <div class="w-full bg-slate-700 rounded-full h-2.5 my-4">
                <div id="processing-progress-bar" class="bg-white h-2.5 rounded-full" style="width: 0%; transition: width 4s ease-out;"></div>
            </div>
            <p id="processing-status" class="text-lg text-gray-400 font-roboto-mono h-6"></p>
        </div>
    </div>

    <div id="random-event-modal" class="modal-backdrop hidden">
        <div class="modal-content">
            <h3 id="random-event-title" class="text-2xl font-orbitron mb-4 text-yellow-300"></h3>
            <p id="random-event-scenario" class="mb-6 text-lg"></p>
            <div id="random-event-choices-container" class="mt-6 flex flex-col justify-center gap-4"></div>
        </div>
    </div>
    
    <div id="age-event-modal" class="modal-backdrop hidden age-event-modal">
        <div class="modal-content">
            <h3 id="age-event-title" class="text-2xl font-orbitron mb-2"></h3>
            <p id="age-event-description" class="mb-6 text-lg"></p>
            <div id="age-event-button-container" class="mt-6 flex flex-col md:flex-row justify-center gap-4"></div>
        </div>
    </div>

    <div id="tutorial-toast-container" class="hidden fixed z-40 p-4 rounded-lg shadow-2xl transition-all duration-300 pointer-events-auto">
        <button id="tutorial-toast-skip-btn" class="absolute top-1 right-2 text-2xl font-bold opacity-70 hover:opacity-1.01">&times;</button>
        <p id="tutorial-toast-text" class="text-lg pr-6"></p>
        <div class="mt-3 text-right">
            <button id="tutorial-toast-next-btn" class="btn btn-sm">Next &rarr;</button>
        </div>
     </div>
    
    <div id="skip-tutorial-modal" class="modal-backdrop hidden">
         <div class="modal-content">
            <h3 id="skip-tutorial-title" class="text-2xl font-orbitron mb-4">Skip Tutorial?</h3>
            <p id="skip-tutorial-description" class="mb-6 text-lg">Are you sure you want to skip the rest of this tutorial? You can replay it later from the tutorial log.</p>
            <div id="skip-tutorial-button-container" class="mt-6 flex justify-center gap-4">
                 <button id="skip-tutorial-confirm-btn" class="btn bg-red-800/80">Yes, Skip</button>
                 <button id="skip-tutorial-cancel-btn" class="btn">No, Cancel</button>
            </div>
        </div>
    </div>

    <div id="ship-detail-modal" class="modal-backdrop hidden">
        <div id="ship-detail-content" class="modal-content">
            </div>
    </div>

    <div id="launch-modal" class="modal-backdrop hidden">
        <div id="launch-modal-content">
            </div>
    </div>

    <div id="cargo-detail-modal" class="modal-backdrop hidden">
        <div id="cargo-detail-content" class="modal-content">
            </div>
    </div>

    <div id="graph-tooltip"></div>
    <div id="generic-tooltip" class="generic-tooltip"></div>
    
    <div id="tutorial-highlight-overlay" class="hidden"></div>

    <script type="module" src="./js/main.js"></script>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }
    </script>
    <div id="orientation-overlay">Please rotate your device to portrait mode.</div>
</body>
</html>
--- END OF FILE: ./index.html ---

--- START OF FILE: ./css/missions.css ---
/* css/missions.css */
.mission-card {
    padding: 0.5rem 1rem;
    cursor: pointer;
    border-radius: 8px;
}
.mission-card:hover .sci-fi-frame::before, .mission-card:hover .sci-fi-frame::after {
    border-color: rgba(96, 165, 250, 0.7);
}
.mission-type {
    font-family: 'Roboto Mono', monospace;
    font-size: 0.7rem;
    color: #9ca3af;
    letter-spacing: 0.1em;
}
.mission-host {
    font-family: 'Roboto Mono', monospace;
    font-size: 0.7rem;
    color: #d1d5db;
}
.mission-reward {
    font-family: 'Orbitron', sans-serif;
    font-size: 0.9rem;
    color: #facc15;
    text-shadow: 0 0 5px rgba(250, 204, 21, 0.6);
}

/* Host Themes */
.host-guild {
    background: linear-gradient(105deg, rgba(255, 215, 0, 0.35) 0%, rgba(255, 255, 255, 0.15) 100%);
    border-color: #FFD700;
}
#mission-modal .modal-content.host-guild {
    background: linear-gradient(105deg, rgba(255, 215, 0, 0.35) 0%, rgba(255, 255, 255, 0.15) 100%);
    border-color: #FFD700;
}
#mission-modal .modal-content.host-guild #mission-modal-objectives {
    border-width: 2px;
    border-color: #FFD700;
}

.host-syndicate {
    background: linear-gradient(105deg, rgba(168, 85, 247, 0.25) 0%, rgba(179, 71, 71, 0.35) 100%);
    border-color: #a855f7;
}
#mission-modal .modal-content.host-syndicate {
    background: linear-gradient(105deg, rgba(168, 85, 247, 0.25) 0%, rgba(179, 71, 71, 0.35) 100%);
    border-color: #a855f7;
}
#mission-modal .modal-content.host-syndicate #mission-modal-objectives {
    border-width: 2px;
    border-color: #a855f7;
}

.host-unknown {
    background: linear-gradient(105deg, rgba(95, 97, 107, 0.35) 0%, rgba(12, 16, 29, 0.5) 100%);
    border-color: #5f616b;
}
#mission-modal .modal-content.host-unknown {
    background: linear-gradient(105deg, rgba(95, 97, 107, 0.35) 0%, rgba(12, 16, 29, 0.5) 100%);
    border-color: #5f616b;
}
#mission-modal .modal-content.host-unknown #mission-modal-objectives {
    border-width: 2px;
    border-color: #5f616b;
}

.host-crew {
    background: linear-gradient(105deg, rgba(201, 191, 177, 0.35) 0%, rgba(245, 222, 179, 0.25) 100%);
    border-color: #c9bfb1;
}
#mission-modal .modal-content.host-crew {
    background: linear-gradient(105deg, rgba(201, 191, 177, 0.35) 0%, rgba(245, 222, 179, 0.25) 100%);
    border-color: #c9bfb1;
}
#mission-modal .modal-content.host-crew #mission-modal-objectives {
    border-width: 2px;
    border-color: #c9bfb1;
}

.host-tutorial {
    background: linear-gradient(105deg, rgba(6, 78, 59, 0.45) 0%, rgba(90, 166, 109, 0.35) 100%);
    border-color: #5aa66d;
}
#mission-modal .modal-content.host-tutorial {
    background: linear-gradient(105deg, rgba(6, 78, 59, 0.45) 0%, rgba(90, 166, 109, 0.35) 100%);
    border-color: #5aa66d;
}
#mission-modal .modal-content.host-tutorial #mission-modal-objectives {
    border-width: 2px;
    border-color: #5aa66d;
}

.host-station {
    background: linear-gradient(105deg, rgba(143, 154, 204, 0.35) 0%, rgba(30, 64, 175, 0.3) 100%);
    border-color: #8f9acc;
}
#mission-modal .modal-content.host-station {
    background: linear-gradient(105deg, rgba(143, 154, 204, 0.35) 0%, rgba(30, 64, 175, 0.3) 100%);
    border-color: #8f9acc;
}
#mission-modal .modal-content.host-station #mission-modal-objectives {
    border-width: 2px;
    border-color: #8f9acc;
}

/* Mission Status Styles */
.mission-active {
    box-shadow: 0 0 16px rgba(96, 165, 250, 0.7), inset 0 0 12px rgba(96, 165, 250, 0.2);
    border-width: 3px;
    border-color: rgba(96, 165, 250, 0.7);
}
.mission-active .sci-fi-frame::before, .mission-active .sci-fi-frame::after {
    border-color: #93c5fd;
}
.mission-complete {
    opacity: 0.6;
    background: #111827;
}
.mission-complete .sci-fi-frame::before, .mission-complete .sci-fi-frame::after {
    border-color: #34d399;
}

.mission-turn-in {
    overflow: hidden;
    position: relative;
    --glow-color: #fde047;
    animation: glow-border 2s infinite, shimmer-effect 3s linear infinite;
    background-image: linear-gradient(to right, transparent 0%, rgba(253, 224, 71, 0.2) 50%, transparent 100%);
    background-repeat: no-repeat;
    background-size: 400px 100%;
}

.objective-progress-flash {
    animation: flash-green 0.7s ease-in-out;
}

.missions-scroll-panel {
    height: 68vh; /* Specific height for this screen layout */
    touch-action: pan-y;
}
--- END OF FILE: ./css/missions.css ---

--- START OF FILE: ./css/debug.css ---
/* css/debug.css */
#debug-panel {
    position: fixed;
    top: 0;
    right: 0;
    width: 450px;
    height: 100vh;
    background-color: #1f2937;
    padding: 1rem;
    overflow-y: auto;
    color: #e5e7eb;
    z-index: 1000;
    box-shadow: -10px 0 20px rgba(0,0,0,0.5);
    display: none; /* Initially hidden */
}

#debug-panel h2 {
    font-family: 'Orbitron', sans-serif;
    border-bottom: 2px solid #4b5563;
    padding-bottom: 0.5rem;
    margin-top: 0;
}

#debug-panel .control-group {
    margin-bottom: 1.5rem;
}

#debug-panel .control-group summary {
    font-weight: bold;
    cursor: pointer;
    padding: 0.5rem;
    background-color: #374151;
    border-radius: 4px;
    margin-bottom: 0.5rem;
}

#debug-panel .control-row {
    display: grid;
    grid-template-columns: 140px 1fr 60px;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
    font-size: 0.9em;
}

#debug-panel .control-row.single {
    grid-template-columns: 140px 1fr;
}


#debug-panel .control-row label {
    font-weight: 500;
}

#debug-panel .control-row input[type="range"] {
    width: 100%;
}
#debug-panel .control-row input[type="text"], #debug-panel .control-row select {
    background-color: #111827;
    border: 1px solid #4b5563;
    color: #e5e7eb;
    border-radius: 4px;
    padding: 4px 6px;
    width: 100%;
    box-sizing: border-box;
    font-family: 'Roboto Mono', monospace;
}

#debug-panel .control-row .value-display {
    font-family: 'Roboto Mono', monospace;
    text-align: right;
}

#debug-panel .export-import {
    margin-top: 2rem;
    border-top: 2px solid #4b5563;
    padding-top: 1rem;
}

#debug-panel .export-import textarea {
    width: 100%;
    box-sizing: border-box;
    height: 150px;
    background-color: #111827;
    color: #f3f4f6;
    border: 1px solid #4b5563;
    border-radius: 4px;
    margin-top: 0.5rem;
    font-family: 'Roboto Mono', monospace;
}

#debug-panel .export-import button {
    width: 100%;
    padding: 0.5rem;
    background-color: #4f46e5;
    border: none;
    color: white;
    border-radius: 4px;
    cursor: pointer;
    margin-top: 0.5rem;
    font-family: 'Orbitron', sans-serif;
}

#debug-panel .control-subheader {
    font-weight: bold;
    color: #9ca3af;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    text-align: center;
}
#debug-panel p, #debug-panel h2 {
    margin: 0;
    padding: 0;
}
--- END OF FILE: ./css/debug.css ---

--- START OF FILE: ./css/tutorial.css ---
    /* css/tutorial.css */
    @keyframes shimmer {
        0% { background-position: -400px 0; }
        100% { background-position: 400px 0; }
    }
    @keyframes green-pulse {
        0%, 100% { box-shadow: 0 0 12px rgba(16, 185, 129, 0.6); }
        50% { box-shadow: 0 0 24px rgba(52, 211, 153, 0.9); }
        100% { box-shadow: 0 0 12px rgba(16, 185, 129, 0.6); }
    }

    #tutorial-toast-container {
        background-color: rgba(13, 42, 42, 0.95);
        color: #f0fff0;
        border: 2px solid transparent;
        border-image: linear-gradient(to right, #d4af37, #fde047, #d4af37);
        border-image-slice: 1;
        animation: shimmer 4s linear infinite, green-pulse 2.5s infinite ease-in-out;
        background-image: linear-gradient(to right, rgba(255,255,255,0) 0%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0) 100%);
        background-repeat: no-repeat;
        background-size: 200px 100%;
        z-index: 190;
        width: 90%;
        max-width: 385px; /* Reduced width by ~15% from 450px */
        max-height: 225px; /* Reduced height by 10% from 250px */
    }

    /* Apply flexbox layout only when the toast is visible to avoid specificity conflicts */
    #tutorial-toast-container:not(.hidden) {
        display: flex;
        flex-direction: column;
    }

    #tutorial-toast-text {
        text-align: left;
        overflow-y: auto; /* Allow vertical scrolling */
        flex-grow: 1; /* Allow the text container to fill available space */
        padding-right: 1rem; /* Add padding for the scrollbar */
    }

    .tutorial-highlight {
        position: relative;
        z-index: 99;
    }

    .tt-top-center, .tt-top { top: 5%; left: 50%; transform: translateX(-50%); }
    .tt-left { top: 50%; left: 2%; transform: translateY(-50%); }
    .tt-right { top: 50%; right: 2%; transform: translateY(-50%); }
    .tt-bottom-center { bottom: 15%; left: 50%; transform: translateX(-50%); }
    .tt-bottom-right { bottom: 15%; right: 2%; }

    .lore-container {
        cursor: pointer;
        display: inline;
        color: #a3b8ee;
        font-style: italic;
        font-weight: bold;
    }
    .lore-tooltip {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 420px;
        max-width: 90vw;
        max-height: 55vh;
        overflow-y: auto;
        background-color: #1f2937;
        border: 2px solid #ffffff;
        border-radius: 0.75rem;
        padding: 1.5rem;
        font-family: 'Exo 2', sans-serif;
        font-size: 1rem;
        line-height: 1.5;
        color: #d0d8e8;
        z-index: 60;
        text-align: left;
        font-style: normal;
        animation: pulse-white 2.5s infinite;
        scrollbar-width: none;
        -ms-overflow-style: none;
    }
    .tutorial-tooltip {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 420px;
        max-width: 90vw;
        max-height: 55vh;
        overflow-y: auto;
        background-color: #1f2937;
        border: 2px solid #10b981;
        border-radius: 0.75rem;
        padding: 1.5rem;
        font-size: 1rem;
        line-height: 1.5;
        color: #d0d8e8;
        z-index: 60;
        text-align: left;
        font-style: normal;
        animation: pulse-green-border 2.5s infinite;
        scrollbar-width: none;
        -ms-overflow-style: none;
    }
    .lore-tooltip.visible, .tutorial-tooltip.visible {
        display: block;
    }
    .lore-tooltip::-webkit-scrollbar, .tutorial-tooltip::-webkit-scrollbar {
        display: none;
    }

    /* --- [[START]] CUSTOM SCROLLBAR STYLES --- */
    #tutorial-toast-text::-webkit-scrollbar {
    width: 8px;
    }
    #tutorial-toast-text::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 4px;
    }
    #tutorial-toast-text::-webkit-scrollbar-thumb {
    background-color: #d4af37;
    border-radius: 4px;
    border: 2px solid transparent;
    background-clip: content-box;
    }
    #tutorial-toast-text::-webkit-scrollbar-thumb:hover {
    background-color: #fde047;
    }
    /* --- [[END]] CUSTOM SCROLLBAR STYLES --- */

    @media (max-width: 768px) {
        #tutorial-toast-container {
            width: 90%; /* Explicitly set width for mobile */
            max-width: 385px; /* Ensure max-width is consistent */
        }

        /* Override positions for mobile to be more consistent */
        .tt-top-center, .tt-left, .tt-right, .tt-top {
            top: 2% !important;
            left: 5% !important; /* Anchor to the left */
            transform: none !important; /* Remove horizontal centering */
            right: auto !important;
            bottom: auto !important;
        }
        
        .tt-bottom-center, .tt-bottom-right {
            bottom: 15% !important;
            top: auto !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            right: auto !important;
        }
    }
--- END OF FILE: ./css/tutorial.css ---

--- START OF FILE: ./css/hud.css ---
/* css/hud.css */
#top-bar-container {
    position: sticky;
    top: 0;
    z-index: 10;
    width: 100%;
    border-radius: 55px;
    background-color: rgba(12, 16, 29, 0.85);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    box-shadow: 0 4px 30px rgba(0, 0, 0, 0.4);
}

.context-bar {
    padding: 6px 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.9rem;
    font-family: 'Share Tech Mono', monospace;
    border-bottom: 2px solid rgba(0,0,0,0.3);
    text-shadow: 0 2px 4px rgba(0,0,0,0.8); /* Increased shadow for readability */
    transition: background 0.5s ease-out, color 0.5s ease-out;
}

.credit-text {
    color: #29f1ff;
    text-shadow: 0 0 5px #16a8bb, 0 0 10px #28d5d7, 0 2px 4px rgba(0,0,0,0.8); /* Blue glow with dark shadow */
}

.status-pod {
    flex-grow: 1;
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 8px;
}

.status-bar-group {
    position: relative;
    display: flex;
    align-items: center;
    gap: 4px;
    cursor: pointer;
}

.status-bar-label {
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.7rem;
    color: #aaa;
}

.status-bar {
    width: 27px;
    height: 8px;
    background-color: #222;
    border: 1px solid #111;
    overflow: hidden;
}

.status-bar .fill {
    height: 100%;
    transition: width 0.3s ease-in-out;
}

.hull-fill { background-color: #2ecc71; }
.fuel-fill { background-color: #3b82f6; }
.cargo-fill { background-color: #f59e0b; }

.status-tooltip {
    position: absolute;
    top: 100%;
    margin-top: 5px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #111;
    color: #fff;
    padding: 4px 8px;
    border-radius: 3px;
    font-size: 0.75rem;
    white-space: nowrap;
    z-index: 20;
    border: 1px solid #555;
    box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s, border-color 0.5s ease-out;
    visibility: hidden;
}

.fuel-group .status-tooltip {
    transform: translateX(calc(-50% - 44px));
}

.cargo-group .status-tooltip {
    transform: translateX(calc(-50% - 88px));
}


.status-tooltip.visible {
    opacity: 1;
    visibility: visible;
}

/* DEPRECATED STYLES - Kept for non-nav UI elements */
.ship-hud {
    background-color: rgba(10, 20, 40, 0.5);
    border: 2px solid #2a3a5a;
    padding: 0.45rem;
    font-size: 0.8rem;
    border-radius: 10px;
    position: relative;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
}
.ship-hud::before, .ship-hud::after {
    content: '';
    position: absolute; width: 15px; height: 15px;
    border-color: #7a9ac0; border-style: solid;
}
.ship-hud::before { top: -2px; left: -2px; border-width: 2px 0 0 2px;
    border-top-left-radius: 10px; }
.ship-hud::after { bottom: -2px; right: -2px;
    border-width: 0 2px 2px 0; border-bottom-right-radius: 10px; }

.hud-stat-bar { background-color: #1a253c;
    border-radius: 3px; overflow: hidden; height: 6px;
}
.hud-stat-bar > div { transition: width 0.5s ease-out;
    height: 100%; }

.sci-fi-frame {
    position: relative;
    border: 1px solid #2a3a5a;
    box-shadow: inset 0 0 15px rgba(12, 16, 29, 0.5);
}
.sci-fi-frame::before, .sci-fi-frame::after {
    content: '';
    position: absolute;
    width: 15px;
    height: 15px;
    border-color: #7a9ac0; /* Default border color */
    border-style: solid;
    transition: border-color 0.3s; /* Smooth transition for border color */
}
.sci-fi-frame::before {
    top: -1px;
    left: -1px;
    border-width: 2px 0 0 2px;
    border-top-left-radius: 8px; /* Top-left corner */
}
.sci-fi-frame::after {
    bottom: -1px;
    right: -1px;
    border-width: 0 2px 2px 0;
    border-bottom-right-radius: 8px; /* Bottom-right corner */
}

.bottom-sticky-bar {
    display: none;
    position: fixed;
    bottom: 1.5rem;
    left: 50%;
    transform: translateX(-50%);
    width: 100%;
    max-width: 1200px;
    padding: 0 1.5rem;
    cursor: pointer;
    z-index: 50;
}
.sticky-content {
    background-color: rgba(12, 16, 29, 0.8);
    background-image: linear-gradient(rgba(12, 16, 29, 0.2) 1px, transparent 1px), linear-gradient(90deg, rgba(12, 16, 29, 0.2) 1px, transparent 1px);
    background-size: 15px 15px;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 8px;
    padding: 0.5rem 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.9rem;
    transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
}
.bottom-sticky-bar p {
    text-shadow: -0.5px -0.5px 0 #000, 0.5px -0.5px 0 #000, -0.5px 0.5px 0 #000, 0.5px 0.5px 0 #000;
}
.bottom-sticky-bar:hover .sticky-content {
    transform: translateY(-3px);
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
}
--- END OF FILE: ./css/hud.css ---

--- START OF FILE: ./css/global.css ---
/* css/global.css */
:root {
    --module-width: 100px;
    --font-size: 0.6rem;
    --border-radius: 20px;
    --toggle-height: 30px;
    --stepper-height: 30px;
    --button-height: 28px;
    --font-family: 'Orbitron', sans-serif;
    --buy-primary: #196a8f;
    --buy-secondary-bg: #1e2a3e;
    --buy-secondary-border: #3c4e68;
    --buy-text-light: #8ca4b5;
    --buy-text-dark: #ddf3f8;
    --sell-primary: #a73535;
    --sell-secondary-bg: #293342;
    --sell-secondary-border: #63686e;
    --sell-text-light: #ff9999;
    --sell-text-dark: #f7cfcf;
    --max-bg: #303946;
    --max-text: #a5aab1;
}

html,
body {
    height: 100dvh;
    overflow: hidden;
    touch-action: none; /* Prevents panning/zooming on the whole page */
}

body {
    font-family: 'Exo 2', sans-serif;
    background-color: #0c101d;
    color: #d0d8e8;
    -webkit-user-select: none; /* Safari */
    -ms-user-select: none; /* IE 10 and IE 11 */
    user-select: none; /* Standard syntax */
    margin: 0;
}

/* Remove focus outlines from all elements */
*:focus {
    outline: none;
}

.font-orbitron { font-family: 'Orbitron', sans-serif; }
.font-roboto-mono { font-family: 'Roboto Mono', monospace; }

.game-container {
    max-width: 1200px;
    margin: auto;
    border: 2px solid #3a4a6a;
    border-radius: 55px;
    transition: background 0.5s ease-out;
    box-shadow: 0 0 30px rgba(58, 74, 106, 0.4);
    display: flex;
    flex-direction: column;
    height: 100%;
    padding: calc(1rem + env(safe-area-inset-top)) 1rem calc(1rem + env(safe-area-inset-bottom)) 1rem;
    box-sizing: border-box;
    overflow: hidden;
}

.main-content-wrapper {
    flex-grow: 1;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    padding-top: 1.5rem; /* Replaces mt-6 */
    min-height: 0; /* Required for flex children to scroll */
}

/* New shared class for scrollable panels */
.scroll-panel {
    height: 75vh; /* Default height, can be overridden */
    overflow-y: auto;
    scrollbar-width: none; /* For Firefox */
    -ms-overflow-style: none; /* For Internet Explorer 10+ */
    padding: 0.25rem;
    touch-action: pan-y; /* Allow vertical panning/scrolling within this element */
}
.scroll-panel::-webkit-scrollbar {
    display: none; /* For Chrome, Safari, and Opera */
}


.btn {
    transition: all 0.3s ease;
    border: 1px solid #4a6a8a;
    border-radius: 8px;
    background-color: #22304a;
    font-family: 'Orbitron', sans-serif;
    letter-spacing: 1px;
    padding: 0.5rem 0.75rem;
    color: #c0d0f0;
    -webkit-user-select: none;
    -ms-user-select: none;
    user-select: none;
}
.btn-sm {
    padding: 0.25rem 0.5rem;
    font-size: 0.8rem;
}
#restart-game-container .btn {
    padding: 0.3rem 0.6rem;
    font-size: 0.875rem;
}
.btn:hover:not(:disabled) {
    background-color: #32405a;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.4);
    color: #e0f0ff;
}
.btn:disabled, [disabled] {
    opacity: 0.4;
    cursor: not-allowed;
    filter: grayscale(80%);
}
.btn-intro-locked {
    filter: grayscale(1);
    opacity: 0.3;
    pointer-events: none;
}

.screen {
    display: none;
}
.active-screen {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    min-height: 0;
}

@keyframes fadeIn {
    from { opacity: 0; transform: scale(0.95); }
    to { opacity: 1; transform: scale(1); }
}
@keyframes fadeOut {
    from { opacity: 1; transform: scale(1); }
    to { opacity: 0; transform: scale(0.95); }
}
@keyframes pulse-green-border {
    0%, 100% { box-shadow: 0 0 10px #10b981, inset 0 0 10px rgba(16, 185, 129, 0.3);
    border-color: #10b981; }
    50% { box-shadow: 0 0 20px #34d399, inset 0 0 15px rgba(52, 211, 153, 0.5);
    border-color: #34d399; }
}
@keyframes pulse-gold-border {
    0%, 100% { box-shadow: 0 0 10px #D4AF37, inset 0 0 10px rgba(212, 175, 55, 0.3);
    border-color: #D4AF37; }
    50% { box-shadow: 0 0 20px #FFD700, inset 0 0 15px rgba(255, 215, 0, 0.5);
    border-color: #FFD700; }
}
@keyframes credits-pulse-glow {
  0% { text-shadow: 0 0 4px #7dd3fc, 0 0 8px #7dd3fc; }
  50% { text-shadow: 0 0 10px #0ea5e9, 0 0 16px #0ea5e9; }
  100% { text-shadow: 0 0 4px #7dd3fc, 0 0 8px #7dd3fc; }
}
@keyframes pulse-green-glow {
    0%, 100% { text-shadow: 0 0 2px #16a34a, 0 0 4px #16a34a; }
    50% { text-shadow: 0 0 4px #22c55e, 0 0 8px #22c55e; }
}
@keyframes float-up {
    from { transform: translateY(0); opacity: 1; }
    to { transform: translateY(-60px);
    opacity: 0; }
}
@keyframes shimmer {
    0% { background-position: -400px 0; }
    100% { background-position: 400px 0; }
}
@keyframes green-pulse {
    0% { box-shadow: 0 0 12px rgba(16, 185, 129, 0.6); }
    50% { box-shadow: 0 0 24px rgba(52, 211, 153, 0.9); }
    100% { box-shadow: 0 0 12px rgba(16, 185, 129, 0.6); }
}
@keyframes blue-pulse-glow {
    0%, 100% { box-shadow: 0 0 16px rgba(96, 165, 250, 0.7), inset 0 0 12px rgba(96, 165, 250, 0.2); }
    50% { box-shadow: 0 0 16px rgba(96, 165, 250, 0.7), inset 0 0 12px rgba(96, 165, 250, 0.2); }
}
@keyframes flash-green {
    0%, 100% { color: #34d399; }
    50% { color: #f0fdf4; }
}
@keyframes shimmer-effect {
    0% { background-position: -600px 0; }
    100% { background-position: 600px 0; }
}

.highlight-current {
    border-color: #facc15;
}
.btn-pulse-green {
    animation: pulse-green-border 2s infinite;
}
.btn-pulse-gold {
    animation: pulse-gold-border 2s infinite;
}
.btn-pulse {
    animation: pulse-green-border 2.5s infinite;
}
.credits-text-pulsing {
  color: #bae6fd;
  animation: credits-pulse-glow 2.5s infinite ease-in-out;
}
.pulse-green-glow {
    animation: pulse-green-glow 2s infinite;
}
.hl { color: #fde047; font-weight: 700; }
.hl-blue { color: #60a5fa; font-weight: 700; }
.hl-red { color: #f87171; font-weight: 700;
}
.hl-green { color: #16a34a; font-weight: 700; }
.hl-yellow { color: #facc15; font-weight: 700; }
.text-outline { text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
}

#save-toast, #garnishment-toast, #hull-warning-toast, #starport-unlock-tooltip {
    z-index: 101;
}

#garnishment-toast {
     background-color: #991b1b;
     border: 1px solid #f87171;
     box-shadow: 0 0 15px rgba(248, 113, 113, 0.7);
}
#hull-warning-toast {
    background-color: #166534;
    border: 1px solid #34d399;
    box-shadow: 0 0 15px rgba(52, 211, 153, 0.7);
    text-shadow: 0 0 5px rgba(255, 255, 255, 0.7);
}

[data-tooltip] { position: relative; }
.tooltip-container[data-tooltip]:hover::after,
.cargo-item-tooltip[data-tooltip]:hover::after,
.commodity-name-tooltip[data-tooltip]:hover::after,
.hanger-ship-name[data-tooltip]:hover::after,
.tooltip-active::after,
.tooltip-container-below[data-tooltip]:hover::after,
.loan-btn-tooltip[data-tooltip]:hover::after {
    content: attr(data-tooltip);
    position: absolute;
    background-color: #111827;
    color: #fff;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 0.875rem;
    white-space: pre-wrap;
    width: max-content;
    max-width: 220px;
    word-wrap: break-word;
    text-align: center;
    z-index: 100;
    display: block;
    pointer-events: none;
    font-family: 'Exo 2', sans-serif;
    left: 105%;
    top: 50%;
    transform: translateY(-50%);
}
.loan-btn-tooltip[data-tooltip]:hover::after {
    font-family: 'Roboto Mono', monospace;
}
.tooltip-container-below[data-tooltip]:hover::after {
    top: 100%;
    margin-top: 5px;
}

#graph-tooltip {
    position: fixed;
    display: none;
    background-color: #111827;
    border: 1px solid #374151;
    border-radius: 8px;
    padding: 0.75rem;
    z-index: 60;
    pointer-events: none;
    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    white-space: pre-wrap;
    text-align: center;
    font-size: 0.875rem;
}

.generic-tooltip {
    position: fixed;
    display: none;
    background-color: #111827;
    border-radius: 6px;
    padding: 5px 10px;
    z-index: 60;
    pointer-events: none;
    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    white-space: pre-wrap;
    text-align: center;
    font-size: 0.875rem;
    color: #fff;
    font-family: 'Exo 2', sans-serif;
    max-width: 60vw;
}

.panel-border {
    position: relative;
}
.panel-border::before, .panel-border::after {
    content: '';
    position: absolute; width: 15px; height: 15px;
    border-color: var(--theme-border-color, #7a9ac0);
    border-style: solid;
}
.panel-border::before { top: -2px; left: -2px; border-width: 2px 0 0 2px;
    border-top-left-radius: 10px; }
.panel-border::after { bottom: -2px; right: -2px;
    border-width: 0 2px 2px 0; border-bottom-right-radius: 10px; }

.floating-text {
    position: fixed;
    pointer-events: none;
    font-weight: 700;
    font-size: 1.25rem;
    text-shadow: 0 2px 4px rgba(0,0,0,0.7);
    z-index: 100;
    animation: float-up 2.5s forwards ease-out;
}

/* --- [[START]] CARGO ITEM STYLES --- */
.cargo-item-card {
    width: 118px;
    height: 118px;
    border-radius: 8px;
    display: flex;
    position: relative;
    box-shadow: inset 0 0 10px rgba(0,0,0,0.4);
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-sizing: border-box;
}

.base-concept {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    box-sizing: border-box;
    color: #fff;
    padding: 0;
}
.pt-header { 
    display: flex; 
    justify-content: space-between; 
    width: 100%; 
    padding: 4px 6px; 
    background: rgba(0,0,0,0.3);
    align-items: center;
    box-sizing: border-box;
    flex-shrink: 0;
}
.pt-number, .pt-category { 
    font-family: 'Share Tech Mono', monospace; 
    font-size: 0.5rem;
    white-space: nowrap;
}
.pt-symbol-wrapper {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    line-height: 1;
}
.pt-symbol {
    font-family: 'Orbitron', sans-serif;
    font-weight: 900;
    font-size: 1.6rem;
    color: #333;
    -webkit-text-stroke: 1.1px #888;
    text-transform: uppercase;
}
.pt-quantity {
    font-family: 'Roboto Mono', monospace;
    font-size: 0.8rem;
    font-weight: 600;
    margin-top: 4px;
    text-shadow: 0 0 6px rgba(0,0,0,0.7);
}
.pt-name { 
    font-family: 'Share Tech Mono', monospace; 
    font-size: 0.5rem; 
    text-align: center; 
    text-transform: uppercase; 
    letter-spacing: 0.5px;
    padding: 4px 6px;
    flex-shrink: 0;
}
/* --- [[END]] CARGO ITEM STYLES --- */

@media (min-width: 768px) {
    .game-container {
        padding: calc(2rem + env(safe-area-inset-top)) 2rem calc(2rem + env(safe-area-inset-bottom)) 2rem;
    }
}

@media (max-width: 768px) {
    .cargo-item-tooltip[data-tooltip]:hover::after,
    .commodity-name-tooltip[data-tooltip]:hover::after,
    .hanger-ship-name[data-tooltip]:hover::after {
        display: none;
    }

    #header-main {
        flex-wrap: wrap;
        justify-content: center;
    }
}

/* --- [[START]] ORIENTATION LOCK OVERLAY --- */
#orientation-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100dvh; /* Use dynamic viewport height */
    background-color: #0c101d;
    color: #d0d8e8;
    z-index: 9999; /* Ensure it's on top of everything */
    /* Flexbox properties for centering */
    display: flex;
    justify-content: center;
    align-items: center;
    text-align: center;
    font-family: 'Orbitron', sans-serif;
    font-size: 1.2rem;
    padding: 1rem;
    display: none; /* Hidden by default */
}

/* This media query activates the overlay when in landscape */
@media (orientation: landscape) {
    #orientation-overlay {
        display: flex;
    }

    #game-container {
        display: none;
    }
}
/* --- [[END]] ORIENTATION LOCK OVERLAY --- */
--- END OF FILE: ./css/global.css ---

--- START OF FILE: ./css/modals.css ---
/* css/modals.css */
.modal-visible {
    animation: fadeIn 0.5s ease-out forwards;
}
.modal-hiding {
    animation: fadeOut 0.5s ease-in forwards;
}

.modal-backdrop {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(12, 16, 29, 0.95);
    display: flex; align-items: center;
    justify-content: center; z-index: 200;
}
.age-event-modal.modal-backdrop {
    align-items: flex-start;
    padding-top: 15vh;
}
.modal-content {
    background: radial-gradient(circle, #1a2030 0%, #0c101d 100%);
    border: 2px solid #3a4a6a;
    border-radius: 15px; padding: 2rem; max-width: 500px;
    width: 90%; text-align: center;
    box-shadow: 0 0 25px rgba(0,0,0,0.7);
}
.modal-content h3 {
    text-align: center;
}
.modal-content .flex.justify-center {
    justify-content: center;
}
#charter-description > .text-justify {
    text-align: justify;
}

.modal-theme-gold .modal-content {
    border-color: #D4AF37;
    box-shadow: 0 0 25px rgba(212, 175, 55, 0.4);
}

.modal-theme-admin .modal-content, .modal-theme-admin.modal-content {
    background: #0c101d;
    border-color: #4a6a8a;
    font-family: 'Roboto Mono', monospace;
}

#signature-input {
    background-color: rgba(255, 255, 255, 0.05);
    border: 1px solid #a3a3a3;
    font-family: 'Roboto Mono', monospace;
    letter-spacing: 2px;
}

.age-event-modal .modal-content {
    background: rgba(240, 240, 255, 0.1);
    backdrop-filter: blur(15px);
    border: 2px solid #D4AF37;
    box-shadow: 0 0 25px rgba(212, 175, 55, 0.3);
    max-width: 600px;
}
.age-event-modal h3 { color: #FFD700; }
.age-event-modal p { color: #f0f0f0; }

.perk-button {
    background: #C0C0C0;
    color: #111827;
    border: 2px solid transparent;
    border-radius: 10px;
    padding: 1rem;
    text-align: left;
    width: 100%;
    transition: all 0.3s ease;
    cursor: pointer;
}
.perk-button:hover {
    transform: translateY(-3px);
    box-shadow: 0 0 15px #FFD700, 0 0 25px #FFD700;
    border-color: #FFD700;
}
.perk-button h4 {
    font-family: 'Orbitron', sans-serif;
    font-size: 0.875rem;
    color: #0c101d;
    text-align: center;
}
.perk-button p {
    font-family: 'Exo 2', sans-serif;
    font-size: 0.9rem;
    color: #374151;
}

#travel-animation-modal #travel-animation-content {
    width: 90%;
    max-width: 800px;
    padding: 0;
    background: radial-gradient(circle, #1a2030 0%, #0c101d 100%);
    border-color: #4a6a8a;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}
#travel-animation-modal #travel-header-panel, #travel-animation-modal #travel-footer-panel {
    padding: 0.75rem 1.5rem;
    text-align: center;
    flex-shrink: 0;
    background-color: rgba(12, 16, 29, 0.5);
    z-index: 10;
}
#travel-animation-modal #travel-header-panel {
    border-bottom: 1px solid #3a4a6a;
    min-height: 80px;
}
#travel-animation-modal #travel-footer-panel {
    border-top: 1px solid #3a4a6a;
    min-height: 80px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}
#travel-animation-modal #travel-canvas {
    width: 100%;
    height: 150px;
    display: block;
}
#travel-animation-modal #travel-arrival-lore, #travel-animation-modal #travel-readout-container, #travel-animation-modal #travel-confirm-button {
    opacity: 0;
    transition: opacity 0.75s ease-in-out;
}
#travel-animation-modal #travel-status-text {
    transition: all 0.5s ease;
}

#random-event-modal .modal-content .btn {
    text-align: center;
}

#ship-detail-modal {
    align-items: center;
    justify-content: center;
}
#ship-detail-modal .modal-content {
    border-radius: 15px;
    width: 90%;
    max-width: 500px;
    margin: 0;
    padding: 1.5rem;
}

#mission-modal .modal-content {
    transform: scale(0.95);
    transition: transform 0.3s ease;
}
#mission-modal .modal-header {
    display: flex;
    justify-content: center;
    align-items: flex-start;
}
#mission-modal .close-button {
    font-size: 2rem;
    line-height: 1;
    color: #9ca3af;
    cursor: pointer;
    transition: color 0.2s;
}
#mission-modal .close-button:hover {
    color: #fff;
}
#mission-modal .reward-section {
    background-color: rgba(0,0,0,0.3);
    border-left: 3px solid #facc15;
    padding: 0.75rem 1rem;
    border-radius: 4px;
    text-align: center;
    width: 80%;
    margin: 0 auto;
}
#mission-modal-objectives {
    width: 80%;
    margin: 1rem auto;
    padding: 1rem;
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    text-align: left;
}

/* --- [[START]] LAUNCH MODAL STYLES --- */
.launch-modal-wrapper {
    position: relative;
    background: radial-gradient(circle, #1a2030 0%, #0c101d 100%);
    border: 2px solid;
    border-radius: 15px;
    padding: 1rem;
    width: 100%;
    max-width: 350px;
    height: 305px;
    margin: 0 auto;
    text-align: center;
    box-shadow: 0 0 25px rgba(0,0,0,0.7);
    display: flex; /* Keep flex display */
    flex-direction: column; /* Keep flex-direction column */
    justify-content: space-between; /* Change from flex-start to space-between */
    gap: 1rem;
}
.launch-modal-wrapper h3 {
    font-size: 1.625rem; /* 26px */
}
.flavor-text {
    font-size: 0.8125rem; /* 13px, a 1pt reduction */
    opacity: 0.80;
}

@keyframes launch-glow-animation {
    0%, 100% {
        box-shadow: 0 0 8px var(--launch-glow-color), inset 0 0 8px var(--launch-glow-color);
    }
    50% {
        box-shadow: 0 0 16px var(--launch-glow-color), inset 0 0 12px var(--launch-glow-color);
    }
}
.btn-launch-glow {
    animation: launch-glow-animation 2.5s infinite;
    border-color: var(--launch-glow-color);
}
/* --- [[END]] LAUNCH MODAL STYLES --- */
--- END OF FILE: ./css/modals.css ---

--- START OF FILE: ./css/screens/services-screen.css ---
/* css/screens/services-screen.css */
.services-scroll-panel {
    height: 75vh; /* Enforce a fixed height based on the viewport */
    overflow-y: auto;
    scrollbar-width: none; /* For Firefox */
    -ms-overflow-style: none; /* For Internet Explorer 10+ */
    padding: 0.25rem;
    touch-action: pan-y; /* Allow vertical scrolling */
}
.services-scroll-panel::-webkit-scrollbar {
    display: none; /* For Chrome, Safari, and Opera */
}
--- END OF FILE: ./css/screens/services-screen.css ---

--- START OF FILE: ./css/screens/market-screen.css ---
/* css/screens/market-screen.css */
:root {
    /* Card Appearance */
    --market-card-height: 160px;
    --market-card-min-height: 40px;
    --market-card-border-radius: 21px;
    --market-card-gradient-angle: 45deg;
    
    /* Positioning */
    --market-card-info-top: 7px;
    --market-card-info-left: 16px;
    --market-card-module-top: 13px;
    --market-card-module-right: 12px;
    --market-card-pinv-top: 34px;
    --market-card-pinv-left: 74px;
    --market-card-avail-top: 29px;
    --market-card-avail-left: 17px;
    --market-card-price-top: 58px;
    --market-card-price-left: 16px;
    
    /* Spacing */
    --market-card-price-indicator-v-gap: 7px;

    /* Name Text */
    --market-card-name-font-size: 0.95rem;
    --market-card-name-color: #ffffff;
    --market-card-name-text-shadow: 1.00px 0.00px 0 #000000, 0.71px 0.71px 0 #000000, 0.00px 1.00px 0 #000000, -0.71px 0.71px 0 #000000, -1.00px 0.00px 0 #000000, -0.71px -0.71px 0 #000000, 0.00px -1.00px 0 #000000, 0.71px -0.71px 0 #000000, -0.5px 0px 3px #000000;

    /* Player Inventory Text */
    --market-card-pinv-font-size: 0.65rem;
    --market-card-pinv-color: #e8e8e8;
    --market-card-pinv-own-color: #ffea00;
    --market-card-pinv-own-font-size: 0.85rem;
    --market-card-pinv-text-shadow: 0.40px 0.00px 0 #000000, 0.28px 0.28px 0 #000000, 0.00px 0.40px 0 #000000, -0.28px 0.28px 0 #000000, -0.40px 0.00px 0 #000000, -0.28px -0.28px 0 #000000, 0.00px -0.40px 0 #000000, 0.28px -0.28px 0 #000000, 0px 1.5px 2.5px #616b70;
    
    /* Avail Text */
    --market-card-avail-font-size: 0.8rem;
    --market-card-avail-color: #ffffff;
    --market-card-avail-text-shadow: 0.70px 0.00px 0 #292929, 0.49px 0.49px 0 #292929, 0.00px 0.70px 0 #292929, -0.49px 0.49px 0 #292929, -0.70px 0.00px 0 #292929, -0.49px -0.49px 0 #292929, 0.00px -0.70px 0 #292929, 0.49px -0.49px 0 #292929, -0.5px 1.5px 3.5px #554a4a;

    /* Price Text */
    --market-card-price-font-size: 1.85rem;
    --market-card-price-color: #29f1ff;
    --market-card-price-font-family: 'Roboto Mono', monospace;
    --market-card-price-text-shadow: 0 0 20px #16a8bb, 1.10px 0.00px 0 #000000, 0.78px 0.78px 0 #000000, 0.00px 1.10px 0 #000000, -0.78px 0.78px 0 #000000, -1.10px 0.00px 0 #000000, -0.78px -0.78px 0 #000000, 0.00px -1.10px 0 #000000, 0.78px -0.78px 0 #000000, 0px 0px 20px #28d5d7;

    /* Effective Price Text */
    --market-card-effective-price-top: 105px;
    --market-card-effective-price-left: 16px;
    --market-card-effective-price-font-size: 0.75rem;
    --market-card-effective-price-color: #ffffff;
    --market-card-effective-price-text-shadow: 0.70px 0.00px 0 #292929, 0.49px 0.49px 0 #292929, 0.00px 0.70px 0 #292929, -0.49px 0.49px 0 #292929, -0.70px 0.00px 0 #292929, -0.49px -0.49px 0 #292929, 0.00px -0.70px 0 #292929, 0.49px -0.49px 0 #292929, -0.5px 1.5px 3.5px #554a4a;

    /* Module */
    --market-card-module-width: 122px;
    --market-card-module-v-gap: 7.1px;
    --market-card-module-toggle-height: 25px;
    --market-card-module-stepper-height: 50px;
    --market-card-module-button-height: 29px;
    --market-card-module-stepper-arrow-size: 1.4em;
    --font-size: 0.85rem; /* Overriding global for module */
    
    /* Glassy Theme Colors */
    --buy-primary: #146171;
    --sell-primary: #a73535;
    --buy-secondary-bg: linear-gradient(145deg, rgba(20,20,30,0.2), rgba(0,0,0,0.5));
    --buy-secondary-border: 1px solid rgba(255,255,255,0.1);
    --buy-text-light: #c8d8e8;
    --buy-text-dark: #ffffff;
    
    --sell-secondary-bg: linear-gradient(145deg, rgba(30,20,20,0.2), rgba(0,0,0,0.5));
    --sell-secondary-border: 1px solid rgba(255,255,255,0.1);
    --sell-text-light: #e8c8c8;
    --sell-text-dark: #ffffff;

    --max-bg: rgba(48, 57, 70, 0.7);
    --max-text: #a5aab1;


    /* Indicators */
    --market-card-indicator-top: 123px;
    --market-card-indicator-left: 16px;
    --market-card-indicator-h-spacing: 6px;
    --market-card-indicator-v-spacing: 3px;
    --market-card-indicator-font-size: 0.7em;
    --market-card-indicator-padding: 0.1em 0.5em;
    --market-card-indicator-positive-bg: rgb(16, 185, 129);
    --market-card-indicator-negative-bg: rgb(220, 38, 38);
    --market-card-indicator-neutral-bg: rgb(115, 115, 115);
    --market-card-indicator-positive-color: #ffffff;
    --market-card-indicator-negative-color: #fee2e2;
    --market-card-indicator-neutral-color: #e5e5e5;
}

.item-card-container {
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    position: relative;
}

/* This is the main card element */
.item-card-container > div {
    position: relative;
    height: var(--market-card-height);
    border-radius: var(--market-card-border-radius);
    padding: 0;
    transition: height 0.3s ease-in-out;
    overflow: visible; /* Changed from hidden to allow button to sit outside */
}

.item-card-container.minimized > div {
    height: var(--market-card-min-height);
}


.item-card-container.locked > div {
    filter: grayscale(80%) brightness(0.6);
    pointer-events: none; /* Disable pointer events on the card itself */
}

.item-card-container.locked .transaction-controls {
    pointer-events: all; /* Re-enable pointer events for the button container */
}


.commodity-name {
    position: absolute;
    top: var(--market-card-info-top);
    left: var(--market-card-info-left);
    font-family: 'Roboto Mono', monospace;
    font-size: var(--market-card-name-font-size);
    color: var(--market-card-name-color);
    text-shadow: var(--market-card-name-text-shadow);
}

.price-text {
    position: absolute;
    top: var(--market-card-price-top);
    left: var(--market-card-price-left);
    font-size: var(--market-card-price-font-size);
    color: var(--market-card-price-color);
    text-shadow: var(--market-card-price-text-shadow);
    font-family: var(--market-card-price-font-family);
}

.profit-text {
    position: absolute;
    top: var(--market-card-price-top);
    left: var(--market-card-price-left);
    font-size: var(--market-card-price-font-size);
    font-family: var(--market-card-price-font-family);
    color: #4ade80; /* bright green */
    text-shadow: 0 0 20px #16a34a, 0 0 10px #22c55e, 1.10px 0.00px 0 #000000, 0.78px 0.78px 0 #000000, 0.00px 1.10px 0 #000000, -0.78px 0.78px 0 #000000, -1.10px 0.00px 0 #000000, -0.78px -0.78px 0 #000000, 0.00px -1.10px 0 #000000, 0.78px -0.78px 0 #000000;
}

.loss-text {
    position: absolute;
    top: var(--market-card-price-top);
    left: var(--market-card-price-left);
    font-size: var(--market-card-price-font-size);
    font-family: var(--market-card-price-font-family);
    color: #f87171; /* bright red */
    text-shadow: 0 0 20px #b91c1c, 0 0 10px #ef4444, 1.10px 0.00px 0 #000000, 0.78px 0.78px 0 #000000, 0.00px 1.10px 0 #000000, -0.78px 0.78px 0 #000000, -1.10px 0.00px 0 #000000, -0.78px -0.78px 0 #000000, 0.00px -1.10px 0 #000000, 0.78px -0.78px 0 #000000;
}

.effective-price-display {
    position: absolute;
    top: var(--market-card-effective-price-top);
    left: var(--market-card-price-left);
    font-size: var(--market-card-effective-price-font-size);
    color: var(--market-card-effective-price-color);
    font-family: 'Roboto Mono', monospace;
    text-shadow: var(--market-card-effective-price-text-shadow);
}

.avail-text {
    position: absolute;
    top: var(--market-card-avail-top);
    left: var(--market-card-avail-left);
    font-size: var(--market-card-avail-font-size);
    color: var(--market-card-avail-color);
    text-shadow: var(--market-card-avail-text-shadow);
}

.avail-text [id^="p-inv-"] {
    color: var(--market-card-pinv-own-color);
    font-size: var(--market-card-pinv-own-font-size);
}

.avg-cost-display {
    position: absolute;
    bottom: 8px;
    right: 16px; /* Positioned to the bottom right */
    font-size: 0.7rem;
    color: #e8e8e8;
    font-family: 'Roboto Mono', monospace;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    display: none; /* Hidden by default */
    text-align: right;
}

.avg-cost-display.visible {
    display: block; /* Show when in sell mode */
}

/* --- [[START]] INDICATOR STYLES --- */
.indicator-container {
    position: absolute;
    top: var(--market-card-indicator-top);
    left: var(--market-card-indicator-left);
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    gap: var(--market-card-indicator-h-spacing);
    margin-top: var(--market-card-price-indicator-v-gap);
}

.indicator-pill {
    padding: var(--market-card-indicator-padding);
    border-radius: 99px;
    font-size: var(--market-card-indicator-font-size);
    font-weight: 700;
    display: inline-flex;
    align-items: center;
    gap: var(--market-card-indicator-h-spacing);
    text-shadow: none;
}

.indicator-pill.positive {
    background-color: var(--market-card-indicator-positive-bg);
    color: var(--market-card-indicator-positive-color);
}
.indicator-pill.negative {
    background-color: var(--market-card-indicator-negative-bg);
    color: var(--market-card-indicator-negative-color);
}
.indicator-pill.neutral {
    background-color: var(--market-card-indicator-neutral-bg);
    color: var(--market-card-indicator-neutral-color);
}
/* --- [[END]] INDICATOR STYLES --- */


/* --- [[START]] COMMODITY CARD STYLES --- */
.item-style-1 {
    border-color: #60a5fa;
    --market-card-gradient-color1: #93c5fd;
    --market-card-gradient-color2: #2563eb;
    background: linear-gradient(var(--market-card-gradient-angle), var(--market-card-gradient-color1), var(--market-card-gradient-color2));
    color: #eff6ff;
}
.item-style-2 {
    border-color: #a3a3a3;
    --market-card-gradient-color1: #d4d4d4;
    --market-card-gradient-color2: #525252;
    background: linear-gradient(var(--market-card-gradient-angle), var(--market-card-gradient-color1), var(--market-card-gradient-color2));
    color: #fafafa;
}
.item-style-3 {
    border-color: #166534;
    --market-card-gradient-color1: #22c55e;
    --market-card-gradient-color2: #15803d;
    background: linear-gradient(var(--market-card-gradient-angle), var(--market-card-gradient-color1), var(--market-card-gradient-color2));
    color: #dcfce7;
}
.item-style-4 {
    border-color: #e5e5e5;
    --market-card-gradient-color1: #f3f4f6;
    --market-card-gradient-color2: #cccccc;
    background: linear-gradient(var(--market-card-gradient-angle), var(--market-card-gradient-color1), var(--market-card-gradient-color2));
    color: #ffffff;
}
.item-style-5 {
    border-color: #c084fc;
    --market-card-gradient-color1: #e9d5ff;
    --market-card-gradient-color2: #a855f7;
    background: linear-gradient(var(--market-card-gradient-angle), var(--market-card-gradient-color1), var(--market-card-gradient-color2));
    color: #faf5ff;
}
.item-style-6 {
    border-color: #93c5fd;
    --market-card-gradient-color1: #bfdbfe;
    --market-card-gradient-color2: #3b82f6;
    background: linear-gradient(var(--market-card-gradient-angle), var(--market-card-gradient-color1), var(--market-card-gradient-color2));
    color: #eff6ff;
}
.item-style-7 {
    border-color: #84cc16;
    --market-card-gradient-color1: #a7f3d0;
    --market-card-gradient-color2: #4d7c0f;
    background: linear-gradient(var(--market-card-gradient-angle), var(--market-card-gradient-color1), var(--market-card-gradient-color2));
    color: #f0fdf4;
}
.item-style-8 {
    border-color: #a5f3fc;
    --market-card-gradient-color1: #e0f2fe;
    --market-card-gradient-color2: #22d3ee;
    background: linear-gradient(var(--market-card-gradient-angle), var(--market-card-gradient-color1), var(--market-card-gradient-color2));
    color: #f0f9ff;
}
.item-style-9 {
    border-color: #fcd34d;
    --market-card-gradient-color1: #fcd34d;
    --market-card-gradient-color2: #d2b48c;
    background: linear-gradient(var(--market-card-gradient-angle), var(--market-card-gradient-color1), var(--market-card-gradient-color2));
    color: #fffbeb;
}
.item-style-10 {
    border-color: #fda4af;
    --market-card-gradient-color1: #fecaca;
    --market-card-gradient-color2: #b91c1c;
    background: linear-gradient(var(--market-card-gradient-angle), var(--market-card-gradient-color1), var(--market-card-gradient-color2));
    color: #fef2f2;
}
.item-style-11 {
    border-color: #c4b5fd;
    --market-card-gradient-color1: #a78bfa;
    --market-card-gradient-color2: #312e81;
    background: linear-gradient(165deg, var(--market-card-gradient-color1), var(--market-card-gradient-color2), #1e3a8a);
    color: #f5f3ff;
}
.item-style-12 {
    border-color: #fca5a5;
    --market-card-gradient-color1: #1f2937;
    --market-card-gradient-color2: #b91c1c;
    background: linear-gradient(var(--market-card-gradient-angle), var(--market-card-gradient-color1) 40%, #7f1d1d, var(--market-card-gradient-color2));
    color: #fee2e2;
}
.item-style-13 {
    border-color: #a78bfa;
    background-color: #000;
    animation: dark-shift 5s ease infinite;
    color: #fde047;
}
.item-style-14 {
    border-color: #f9a8d4;
    background-color: #fca5a5;
    animation: warm-shift 4s ease infinite;
    color: #fff;
}
/* --- [[END]] COMMODITY CARD STYLES --- */

/* --- [[START]] MIN/MAX VIEW STYLES --- */
.card-toggle-btn {
    position: absolute;
    top: -8px;
    right: -8px;
    width: 24px;
    height: 24px;
    border-radius: 99px;
    background-color: rgba(0, 0, 0, 0.45);
    color: rgba(255, 255, 255, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.2);
    cursor: pointer;
    z-index: 10;
    font-family: 'Roboto Mono', monospace;
    font-size: 1.2rem;
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding-bottom: 2px;
}
.card-toggle-btn:hover {
    background-color: rgba(0, 0, 0, 0.6);
    color: white;
}
.min-view-content {
    display: none;
    align-items: center;
    justify-content: space-between;
    padding: 0 16px;
    height: 100%;
}
.commodity-name-min {
    font-family: 'Roboto Mono', monospace;
    font-size: var(--market-card-name-font-size);
    color: var(--market-card-name-color);
    text-shadow: var(--market-card-name-text-shadow);
}
.tier-text-min {
    font-family: 'Roboto Mono', monospace;
    font-size: 0.7rem;
    color: var(--market-card-name-color);
    text-shadow: var(--market-card-name-text-shadow);
    opacity: 0.8;
}

.item-card-container .max-view-content { display: block; }
.item-card-container .min-view-content { display: none; }
.item-card-container.minimized .max-view-content { display: none; }
.item-card-container.minimized .min-view-content { display: flex; }
/* --- [[END]] MIN/MAX VIEW STYLES --- */

/* --- [[START]] SOLID STATE TRANSACTION BUTTONS --- */
.transaction-controls {
    position: absolute;
    top: var(--market-card-module-top);
    right: var(--market-card-module-right);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--market-card-module-v-gap);
    width: var(--market-card-module-width);
    font-family: var(--font-family);
    font-size: var(--font-size);
}
.toggle-switch {
    width: 100%;
    height: var(--market-card-module-toggle-height);
    border-radius: 99px;
    display: flex;
    align-items: center;
    padding: 3px;
    position: relative;
    cursor: pointer;
    transition: all 0.3s ease-in-out;
}
.toggle-thumb {
    width: 50%;
    height: 100%;
    border-radius: 99px;
    position: absolute;
    left: 3px;
    transition: all 0.3s ease-in-out;
}
.toggle-labels {
    width: 100%;
    display: flex;
    justify-content: space-around;
    position: relative;
    z-index: 1;
    font-weight: bold;
    font-size: 0.8em;
}
.toggle-labels span {
    transition: color 0.3s ease-in-out;
}
.qty-stepper {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    height: var(--market-card-module-stepper-height);
    border-radius: var(--border-radius);
    padding: 0 0.5rem;
    transition: all 0.3s ease-in-out;
}
.qty-stepper input {
    width: 30%;
    background: none;
    border: none;
    text-align: center;
    color: inherit;
    font-size: 1.2em;
    font-family: 'Roboto Mono', monospace;
    -moz-appearance: textfield;
}
.qty-stepper input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}
.qty-stepper button {
    background: none;
    border: none;
    font-size: var(--market-card-module-stepper-arrow-size);
    cursor: pointer;
    transition: color 0.2s;
    line-height: 1;
}
.action-group {
    display: flex;
    width: 100%;
    gap: 0.5rem;
}
.action-group .btn {
    flex: 1;
    height: var(--market-card-module-button-height);
    border: none;
    border-radius: 99px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s ease-out;
    font-size: 0.8em;
    padding: 0 0.5rem;
}
.action-group .confirm-btn {
    flex-grow: 1;
}
.action-group .max-btn {
    flex: 1;
}
.action-group .btn:active {
    transform: scale(0.95);
    filter: brightness(1.2) saturate(1.5);
}

/* Dynamic Theming */
.transaction-controls[data-mode="buy"] {
    --active-primary: var(--buy-primary);
    --active-secondary-bg: var(--buy-secondary-bg);
    --active-secondary-border: var(--buy-secondary-border);
    --active-text-light: var(--buy-text-light);
    --active-text-dark: var(--buy-text-dark);
}
.transaction-controls[data-mode="sell"] {
    --active-primary: var(--sell-primary);
    --active-secondary-bg: var(--sell-secondary-bg);
    --active-secondary-border: var(--sell-secondary-border);
    --active-text-light: var(--sell-text-light);
    --active-text-dark: var(--sell-text-dark);
}
.toggle-switch, .qty-stepper {
    background: var(--active-secondary-bg);
    border: var(--active-secondary-border);
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.4);
}
.toggle-thumb {
    background: var(--active-primary);
}
.toggle-labels span {
    color: var(--active-text-light);
}
.transaction-controls[data-mode="buy"] .label-buy, .transaction-controls[data-mode="sell"] .label-sell {
    color: var(--active-text-dark);
}
.qty-stepper {
    color: var(--active-text-light);
}
.qty-stepper button {
    color: var(--active-text-light);
}
.confirm-btn {
    background: var(--active-primary);
    color: var(--active-text-dark);
}
.max-btn {
    background: var(--max-bg);
    color: var(--max-text);
}
.transaction-controls[data-mode="sell"] .toggle-thumb {
    left: calc(50% - 3px);
}
/* --- [[END]] SOLID STATE TRANSACTION BUTTONS --- */

.market-scroll-panel {
    height: 75vh;
    overflow-y: auto;
    scrollbar-width: none; /* For Firefox */
    -ms-overflow-style: none; /* For Internet Explorer 10+ */
    padding: 0.25rem;
    touch-action: pan-y; /* Allow vertical scrolling */
}

.market-scroll-panel::-webkit-scrollbar {
    display: none; /* For Chrome, Safari, and Opera */
}
--- END OF FILE: ./css/screens/market-screen.css ---

--- START OF FILE: ./css/screens/intel-screen.css ---
/* css/screens/intel-screen.css */
.intel-scroll-panel {
    height: 75vh; /* Enforce a fixed height based on the viewport */
    overflow-y: auto;
    scrollbar-width: none; /* For Firefox */
    -ms-overflow-style: none; /* For Internet Explorer 10+ */
    padding: 0.25rem;
    touch-action: pan-y; /* Allow vertical scrolling */
}
.intel-scroll-panel::-webkit-scrollbar {
    display: none; /* For Chrome, Safari, and Opera */
}
--- END OF FILE: ./css/screens/intel-screen.css ---

--- START OF FILE: ./css/screens/cargo-screen.css ---
/* css/screens/cargo-screen.css */
.cargo-scroll-panel {
    height: 75vh;
    overflow-y: auto;
    scrollbar-width: none; /* For Firefox */
    -ms-overflow-style: none; /* For Internet Explorer 10+ */
    padding: 0.25rem;
    touch-action: pan-y; /* Allow vertical scrolling */
}
.cargo-scroll-panel::-webkit-scrollbar {
    display: none; /* For Chrome, Safari, and Opera */
}

/* Grid container for the min-cargo items */
.cargo-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 1rem;
    padding: 1rem;
}

/* Individual min-cargo item styling */
.min-cargo-item {
    aspect-ratio: 1 / 0.8; /* Ensures the item is shorter */
    border-radius: 12px;
    cursor: pointer;
    transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    position: relative;
}

.min-cargo-item .pt-quantity {
    opacity: 0.85; /* Make the quantity text slightly transparent */
    color: #a0aec0; /* Change the quantity text color to grey */
}

.min-cargo-item:hover {
    transform: scale(1.05);
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
}

/* Styles for the max-cargo modal */
#cargo-detail-modal .modal-content {
    background: transparent;
    border: none;
    box-shadow: none;
    max-width: 350px; /* Or adjust as needed */
}

.max-cargo-card {
    width: 100%;
    border-radius: 15px;
    color: #fff;
    padding: 1.5rem;
    text-align: left;
    border: 2px solid;
}

.max-cargo-card h3, .max-cargo-card p, .max-cargo-card div {
    text-shadow: 1px 1px 3px rgba(0,0,0,0.7); /* Add text outline for clarity */
}

.max-cargo-card .tier-type-line {
    text-shadow: 1px 1px 2px rgba(0,0,0,0.9); /* Darker outline for more contrast */
}

.max-cargo-card .flavor-text {
    font-size: 0.9rem;
    color: #d1d5db;
    margin-top: 1rem;
    margin-bottom: 1rem;
    text-align: justify;
}

.max-cargo-card .avg-cost {
    font-family: 'Roboto Mono', monospace;
    font-size: 1rem;
    text-align: center;
    padding-top: 1rem;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
}


/* Responsive adjustments */
@media (max-width: 768px) {
    .cargo-grid {
        grid-template-columns: repeat(3, 1fr);
    }
}

@media (max-width: 480px) {
    .cargo-grid {
        grid-template-columns: repeat(2, 1fr);
    }
}
--- END OF FILE: ./css/screens/cargo-screen.css ---

--- START OF FILE: ./css/screens/finance-screen.css ---
/* css/screens/finance-screen.css */
.finance-log-panel {
    height: 50vh; /* Enforce a fixed height based on the viewport */
    scrollbar-width: none; /* For Firefox */
    -ms-overflow-style: none; /* For Internet Explorer 10+ */
    touch-action: pan-y; /* Allow vertical scrolling */
}
.finance-log-panel::-webkit-scrollbar {
    display: none; /* For Chrome, Safari, and Opera */
}


@media (max-width: 768px) {
    #finance-screen .grid-cols-4 {
        grid-template-columns: 0.5fr 2fr 1fr;
        font-size: 0.8rem;
    }
    #finance-screen .grid-cols-4 > span:nth-child(2) {
        grid-column: span 1;
    }
}
--- END OF FILE: ./css/screens/finance-screen.css ---

--- START OF FILE: ./css/screens/status-screen.css ---
/* css/screens/status-screen.css */
.status-scroll-panel {
    height: 75vh; /* Enforce a fixed height based on the viewport */
    overflow-y: auto;
    scrollbar-width: none; /* For Firefox */
    -ms-overflow-style: none; /* For Internet Explorer 10+ */
    padding: 0.25rem;
    touch-action: pan-y; /* Allow vertical scrolling */
}
.status-scroll-panel::-webkit-scrollbar {
    display: none; /* For Chrome, Safari, and Opera */
}
--- END OF FILE: ./css/screens/status-screen.css ---

--- START OF FILE: ./css/screens/hangar-screen.css ---
/* css/screens/hangar-screen.css */

/* ================================================================================
CORE THEME & VARIABLE SETUP
- Defines the color palette, fonts, and dynamic variables used throughout the component.
- Theming is driven by CSS variables to allow for easy changes based on game state (e.g., location).
================================================================================
*/
:root {
    /* Base Colors */
    --ot-bg-dark: #0c101d;
    --ot-border-light: #4a6a8a;
    --ot-text-primary: #d0d8e8;
    --ot-text-secondary: #9ca3af;
    --ot-green-accent: #4ade80;
    --ot-red-accent: #f87171;
    --ot-cyan-base: #22d3ee;
    --ot-cyan-glow: #67e8f9;

    /* Toggle & Mode-Specific Colors */
    --ot-hangar-red-base: #ef4444;
    --ot-hangar-red-glow: #f87171;
    --ot-shipyard-blue-base: #60a5fa;
    --ot-shipyard-blue-glow: #93c5fd;

    /* Ship Class Colors */
    --class-s-color: #facc15;
    --class-a-color: #60a5fa;
    --class-b-color: #4ade80;
    --class-c-color: #e5e7eb;
    
    /* Placeholder Theme (Saturn) - In the final game, these will be dynamically set. */
    --theme-color-primary: #fde047;
    --theme-color-glow: #fef08a;
    --theme-bg-gradient: linear-gradient(145deg, rgba(113, 63, 18, 0.5), rgba(49, 46, 129, 0.8));

    /* Dynamic Frame Border Color - Changes based on Hangar/Shipyard mode */
    --frame-border-color: var(--ot-shipyard-blue-base);
}

/* Set Hangar-specific frame color when the .mode-hangar class is active */
#ship-terminal-container.mode-hangar {
    --frame-border-color: var(--ot-hangar-red-base);
}


/* ================================================================================
COMPONENT-SPECIFIC STYLING
================================================================================
*/

#ship-terminal-container {
    margin-top: -0.9625rem;
}

/* Carousel: Main container for ship cards */
.carousel-container { 
    width: 100%;
    position: relative;
    cursor: grab;
    flex-grow: 1; /* Ensure this container fills available vertical space */
    display: flex;
}
.carousel-container:active {
    cursor: grabbing;
}

#hangar-carousel {
    display: flex; /* Lays out the pages side-by-side */
    height: 100%;
    width: 100%;
    /* ALWAYS have the transition property defined in CSS for smooth animations */
    transition: transform 0.4s ease-out;
}
.carousel-page {
    width: 100%;
    flex-shrink: 0; /* Prevents the page from shrinking */
    display: flex; 
    flex-direction: column; 
    user-select: none;
}

/* --- PHASE 2: ANIMATION STYLES (REFINED) --- */
@keyframes glow-and-fade-out {
    0% {
        opacity: 1;
        filter: brightness(1) blur(0);
        transform: scale(1);
    }
    50% {
        opacity: 0.8;
        filter: brightness(2.5) blur(4px);
        transform: scale(1.05);
    }
    100% {
        opacity: 0;
        filter: brightness(1) blur(12px);
        transform: scale(0.9);
    }
}

.ship-page-minimizing {
    animation: glow-and-fade-out 3s ease-in-out forwards;
}
/* --- END PHASE 2 --- */



/* Backgrounds & Theming */
#ship-terminal {
    background-image: var(--theme-bg-gradient); /* Base theme from location */
    display: flex; 
    flex-direction: column; 
    flex-grow: 1; /* Make the card itself grow to fill the page */
    min-height: 545px; /* INCREASED FOR MORE VERTICAL SPACE */
    height: auto; 
}

/* The new intermediate container for constraining height */
#ship-card-main-content {
    flex: 1 1 auto; /* Grow to fill space */
    min-height: 0; /* CRUCIAL for allowing the child to scroll */
    display: flex;
    flex-direction: column;
}

/* The scrollable grid content wrapper */
.ship-card-content-wrapper {
    overflow-y: auto; 
    scrollbar-width: none;
    display: grid; 
    grid-template-columns: repeat(5, minmax(0, 1fr));
    gap: 1rem;
    padding: 1rem;
    flex-grow: 1; /* Make the grid wrapper fill the container */
}
.ship-card-content-wrapper::-webkit-scrollbar {
    display: none; 
}

/* Force grid columns to behave as flex containers to distribute space */
.ship-card-content-wrapper > .col-span-2,
.ship-card-content-wrapper > .col-span-3 {
    display: flex;
    flex-direction: column;
}


#ship-terminal-container.mode-hangar #ship-terminal {
    background-blend-mode: overlay;
    background-color: #1a193d; 
}
#ship-terminal-container.mode-hangar #ship-terminal::after { 
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background-image:
        radial-gradient(circle at 10px 10px, rgba(255,255,255,0.05) 1px, transparent 1px);
    background-size: 20px 20px;
    pointer-events: none;
}


/* Hologram */
.ship-display-area { 
    perspective: 1500px; 
    position: relative; 
    flex-grow: 1; /* Pushes buttons down */
}
.ship-image-placeholder { 
    background: transparent; 
    border: 1px solid var(--ot-border-light); 
    color: var(--theme-color-primary); 
    box-shadow: inset 0 0 15px rgba(0,0,0,0.3);
    aspect-ratio: 1 / 0.72; /* Make it a 1:0.8 rectangle */
}
.status-badge {
    position: absolute;
    bottom: -1px;
    left: 50%;
    transform: translateX(-50%) translateY(50%);
    background-color: #1a2030;
    border: 1px solid;
    padding: 3px 11px;
    border-radius: 99px;
    font-size: 0.77rem;
    font-weight: 700;
}

/* Hangar/Shipyard Toggle Switch */
.toggle-container {
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 8px;
    padding: 3px;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.4);
    transform: scale(0.72); 
    flex-shrink: 0; 
}
.toggle-switch {
    background-color: transparent;
    display: flex;
}
.toggle-label {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    flex-grow: 1;
    transition: all 0.3s ease;
    color: var(--ot-text-secondary);
    clip-path: polygon(0% 0%, 100% 0%, 100% 85%, 85% 100%, 0% 100%);
}
.toggle-label.shipyard {
    clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 15% 100%, 0% 85%);
}

#ship-terminal-container.mode-hangar .toggle-label.hangar,
#ship-terminal-container.mode-shipyard .toggle-label.shipyard {
    color: var(--ot-bg-dark);
    font-weight: 900;
}
#ship-terminal-container.mode-hangar .toggle-label.hangar { 
    background-color: var(--ot-hangar-red-base);
    box-shadow: 0 0 10px var(--ot-hangar-red-glow);
}
#ship-terminal-container.mode-shipyard .toggle-label.shipyard { 
    background-color: var(--ot-shipyard-blue-base);
    box-shadow: 0 0 10px var(--ot-shipyard-blue-glow);
}

/* Main Info Panels & Mode-Specific Spacing */
.info-panel-content { 
    display: none; 
    flex-grow: 1; /* Pushes buttons down */
    flex-direction: column;
}

/* ADDED: Mode-specific rules for spacing above action buttons */
#ship-terminal-container.mode-hangar .ship-display-area,
#ship-terminal-container.mode-shipyard .info-panel-content {
    margin-bottom: 1rem;
}

#ship-terminal-container.mode-hangar .info-panel-hangar, 
#ship-terminal-container.mode-shipyard .info-panel-shipyard { 
    display: flex; 
}

/* NEW: Ship Price Display for Shipyard */
.ship-price-display {
    margin-top: 0.5rem;
    color: var(--ot-cyan-base);
    text-shadow: 0 0 5px var(--ot-cyan-glow), 0 0 10px var(--ot-cyan-glow), 0 2px 4px rgba(0,0,0,0.8);
}


/* Stat Readouts */
.spec-readout { display: grid; align-items: center; margin-bottom: 0.75rem; font-family: 'Roboto Mono', sans-serif;}
.hangar-specs { grid-template-columns: 60px 1fr 60px;}
.hangar-specs .w-4\/5 { width: 80%; } 
.hangar-specs .text-xs { font-size: 0.7rem; } 

.spec-bar { height: 13px; background-color: rgba(0,0,0,0.3); flex-grow: 1; border-radius: 4px; box-shadow: inset 0 1px 3px rgba(0,0,0,0.5);}
.spec-bar-fill { height: 100%; border-radius: 4px; box-shadow: 0 0 8px var(--bar-color); }

/* Action Buttons */
.action-button { 
    transition: transform 0.2s ease; 
    border-radius: 0.5rem; 
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.3rem 0.8rem;
}
.action-button:not(:disabled) {
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
}
.action-button:active:not(:disabled) { transform: scale(0.98); filter: brightness(1.2); }
.action-button:disabled { opacity: 0.4; cursor: not-allowed; filter: grayscale(50%); }

/* NEW: Price text specifically for action buttons (like Sell) */
.action-button-price {
    font-size: 1.1rem;
    color: var(--ot-cyan-base);
    text-shadow: 0 0 5px var(--ot-cyan-glow), 0 0 10px var(--ot-cyan-glow), 0 2px 4px rgba(0,0,0,0.8);
}

/* Flavor Text Styling */
.flavor-text-box {
    padding-left: 0.75rem;
    border-left: 2px solid;
    box-shadow: inset 3px 0 5px -2px rgba(0,0,0,0.5);
}

/* Inset Text Shadow for ship names/roles */
.inset-text-shadow {
    text-shadow: 0 2px 3px rgba(0,0,0,0.6);
}

/* Pagination Dots */
#hangar-pagination {
    flex-shrink: 0; 
    padding-bottom: 8px; 
}
.pagination-dot.active { background-color: var(--theme-color-primary); box-shadow: 0 0 8px var(--theme-color-glow); }

/* Spec Cards (Shipyard) */
.spec-card {
    background: rgba(0,0,0,0.2);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 0.375rem;
    padding: 0.5rem;
    text-align: center;
    box-shadow: inset 0 1px 4px rgba(0,0,0,0.6);
}

/* Responsive adjustments for smaller screens */
@media (max-width: 768px) {
    .ship-card-content-wrapper {
        grid-template-columns: 1fr; /* Stack columns vertically */
    }
    .ship-card-content-wrapper > .col-span-2,
    .ship-card-content-wrapper > .col-span-3 {
        grid-column: span 1 / span 1; /* Make each column take full width */
    }
    .ship-display-area {
        min-height: 180px; /* Ensure hologram area has enough height */
    }
}
--- END OF FILE: ./css/screens/hangar-screen.css ---

--- START OF FILE: ./css/screens/navigation-screen.css ---
/* css/screens/navigation-screen.css */
.navigation-scroll-panel {
    height: 75vh;
    overflow-y: auto;
    scrollbar-width: none; /* For Firefox */
    -ms-overflow-style: none; /* For Internet Explorer 10+ */
    touch-action: pan-y; /* Allow vertical scrolling */
}
.navigation-scroll-panel::-webkit-scrollbar {
    display: none; /* For Chrome, Safari, and Opera */
}

.location-card {
    display: flex;
    flex-direction: column;
    border-width: 2px;
    transition: all 0.3s ease;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.25);
}
.location-card p {
    word-wrap: break-word;
    white-space: normal;
    font-size: 0.875rem;
    line-height: 1.25rem;
}
.location-card:not(.highlight-current):hover { transform: scale(1.05); cursor: pointer; }
.location-card.disabled-current { cursor: pointer; }
.location-card-footer {
    margin-top: auto;
}

@media (max-width: 768px) {
    .travel-info-mobile {
        flex-direction: column;
        align-items: center;
        text-align: center;
    }
}
--- END OF FILE: ./css/screens/navigation-screen.css ---

--- START OF FILE: ./css/navigation.css ---
/* css/navigation.css */

/* --- [[START]] NEW BULKHEAD STYLES (Concept 207+) --- */
.nav-wrapper {
    background-color: #383838;
    background-image: radial-gradient(circle, rgba(255,255,255,.03) 1px, transparent 1px);
    background-size: 10px 10px;
    display: flex;
    align-items: center;
    padding: 0 5px 0 10px;
    border-bottom: 1px solid #111;
}

.nav-main {
    display: flex;
}

.tab {
    padding: 7.5px 15px;
    color: #a0aec0; /* Default text color */
    opacity: 0.7; /* Default opacity */
    cursor: pointer;
    font-family: 'Orbitron', sans-serif;
    font-weight: 700;
    font-size: 0.8rem;
    position: relative;
    background-color: #444;
    border-top: 1px solid #666;
    margin-right: -6px;
    transition: all 0.2s;
    text-decoration: none;
    filter: drop-shadow(0 2px 2px rgba(0,0,0,0.4));
    -webkit-user-select: none;
    -ms-user-select: none;
    user-select: none;
}
.tab.disabled {
    pointer-events: none;
    filter: grayscale(1);
    opacity: 0.3;
}

.ship-tab { clip-path: polygon(0% 0%, 100% 0%, 85% 100%, 15% 100%);
}
.starport-tab, .data-tab { clip-path: polygon(15% 0, 100% 0, 85% 100%, 0% 100%); }

.tab.active {
    opacity: 1;
    z-index: 2;
    transform: scale(1.05);
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.4);
    filter: drop-shadow(0 3px 4px rgba(0,0,0,0.5));
}

#sub-nav-bar {
    border-radius: 0 0 15px 15px; /* Round the bottom corners */
    overflow: hidden;
}

.nav-sub {
    background-color: #222;
    padding: 0;
    display: flex;
    justify-content: center;
    border-top: 1px solid #333;
}

.nav-sub a {
    flex-grow: 1;
    text-align: center;
    opacity: 0.8;
    font-size: 0.7rem;
    text-transform: uppercase;
    padding: 8.75px 0;
    text-decoration: none;
    position: relative;
    transition: all 0.2s;
    background-color: #3a3a3a;
    border-right: 1px solid #1c1c1c;
    border-left: 1px solid #4a4a4a;
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.2);
    draggable: false;
    -webkit-user-select: none;
    -ms-user-select: none;
    user-select: none;
}
.nav-sub a.disabled {
    pointer-events: none;
    filter: grayscale(1);
    opacity: 0.3;
}


.nav-sub a:first-child { border-left: none;
}
.nav-sub a:last-child { border-right: none; }

.nav-sub a:hover:not(.disabled) {
    opacity: 1;
    background-color: #4a4a4a;
}
/* --- [[END]] NEW BULKHEAD STYLES --- */


/* --- [[START]] DEPRECATED STYLES --- */
/* The styles below are no longer used by the navigation system but are kept for other UI elements.
*/
.btn-header {
     padding: 0.2rem 1.5rem;
     font-size: 1.125rem;
     flex: 1;
     background-blend-mode: overlay;
     background-image: linear-gradient(rgba(255,255,255,0.08), rgba(0,0,0,0.1));
}

@media (max-width: 768px) {
    /* .btn-header rules are no longer needed for navigation but might be used elsewhere.
*/
    .btn-header {
        padding: 0.2rem 0.6rem;
        font-size: 0.8rem;
        flex: 1;
        min-width: 0;
        width: auto;
    }
}
/* --- [[END]] DEPRECATED STYLES --- */
--- END OF FILE: ./css/navigation.css ---

--- START OF FILE: ./css/orientation.css ---
/* css/orientation.css */
#orientation-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #0c101d;
    color: #d0d8e8;
    z-index: 2000; 
    justify-content: center;
    align-items: center;
    text-align: center;
    font-family: 'Orbitron', sans-serif;
}

@media (orientation: landscape) {
    #orientation-overlay {
        display: flex;
    }
    /* Optional: Hide the main game container to be safe */
    #game-container {
        display: none;
    }
}
--- END OF FILE: ./css/orientation.css ---

--- START OF FILE: ./js/ui/components/StatusScreen.js ---
// js/ui/components/StatusScreen.js
/**
 * @fileoverview This file contains the rendering logic for the main Status screen.
 * It serves as the primary dashboard for the player, displaying the current date,
 * active ship information, and essential ship status metrics like hull, fuel, and cargo.
 */
import { DB } from '../../data/database.js';
import { formatCredits, calculateInventoryUsed, getDateFromDay } from '../../utils.js';

/**
 * Renders the entire Status screen UI.
 * @param {object} gameState - The current state of the game.
 * @returns {string} The HTML content for the Status screen.
 */
export function renderStatusScreen(gameState) {
    const { player, day, currentLocationId } = gameState;
    const shipStatic = DB.SHIPS[player.activeShipId];
    const shipState = player.shipStates[player.activeShipId];
    const inventory = player.inventories[player.activeShipId];
    const cargoUsed = calculateInventoryUsed(inventory);
    const location = DB.MARKETS.find(l => l.id === currentLocationId);
    const theme = location?.navTheme || { gradient: 'linear-gradient(135deg, #4a5568, #2d3748)', textColor: '#f0f0f0', borderColor: '#7a9ac0' };
    const shipClassLower = shipStatic.class.toLowerCase();

    // Active Ship Bar component logic from Hangar screen
    const hullPercent = Math.floor((shipState.health / shipStatic.maxHealth) * 100);
    const fuelPercent = Math.floor((shipState.fuel / shipStatic.maxFuel) * 100);
    const cargoSegments = Array.from({ length: Math.max(10, Math.min(25, Math.floor(shipStatic.cargoCapacity / 8))) }, (_, i) => {
        const filledSegments = Math.round((cargoUsed / shipStatic.cargoCapacity) * Math.max(10, Math.min(25, Math.floor(shipStatic.cargoCapacity / 8))));
        return `<div class="segment ${i < filledSegments ? 'filled' : ''}"></div>`;
    }).join('');

    const activeShipBarHtml = `
        <div class="ship-bar-wrapper bg-class-${shipClassLower} class-${shipClassLower}" style="cursor: default;">
            <div class="status-sidelabel sidelabel-active">ACTIVE</div>
            <div class="main-content">
                <div class="ship-info-top">
                    <div class="ship-info">
                        <span class="ship-name class-${shipClassLower}">${shipStatic.name}</span>
                        <span class="ship-class">Class ${shipStatic.class}</span>
                    </div>
                    <div class="ship-stats-text">
                        <span class="stat-hull">HULL: <span class="value">${hullPercent}%</span></span>
                        <span class="stat-fuel">FUEL: <span class="value">${fuelPercent}%</span></span>
                    </div>
                </div>
                <div class="bottom-line">
                    <div class="cargo-bar">${cargoSegments}</div>
                    <div class="cargo-text">CARGO: <span class="value">${cargoUsed}/${shipStatic.cargoCapacity}</span></div>
                </div>
            </div>
        </div>
    `;

    return `
        <div class="status-scroll-panel">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 bg-black/30 p-4 rounded-lg mb-6 items-start">
                <div class="md:col-span-2 h-full p-4 rounded-lg flex items-center justify-between transition-all duration-500 panel-border border" style="border-color: ${theme.borderColor}; color: ${theme.textColor}; background: ${theme.gradient};">
                    <div class="text-left pl-4">
                        <span class="block text-lg uppercase tracking-widest" style="color: ${theme.textColor}a0;">Day</span>
                        <span class="text-4xl font-bold font-orbitron">${day}</span>
                    </div>
                    <div class="text-right flex flex-col items-end">
                        <p class="text-xs font-roboto-mono text-right" style="color: ${theme.textColor}cc;">${getDateFromDay(day)}</p>
                        <div class="mt-2 pt-2 border-t" style="border-color: ${theme.textColor}50;">
                            <div class="text-right">
                                <p class="text-sm tracking-wider" style="color: ${theme.textColor}a0;">Vessel</p>
                                <p>${shipStatic.name}</p>
                                <p>Class: ${shipStatic.class}</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="md:col-span-1 flex flex-col gap-4">
                    ${activeShipBarHtml}
                    <div class="text-center text-lg font-orbitron flex items-center justify-center gap-2" style="color: ${theme.textColor};">
                        <span>${player.playerTitle} ${player.name}, ${player.playerAge}</span>
                    </div>
                </div>
            </div>
        </div>`;
}
--- END OF FILE: ./js/ui/components/StatusScreen.js ---

--- START OF FILE: ./js/ui/components/HangarScreen.js ---
// js/ui/components/HangarScreen.js
/**
 * @fileoverview Renders the Hangar screen, now a unified "Ship Terminal" with toggleable
 * Hangar and Shipyard views, a central ship display, and a carousel.
 */
import { DB } from '../../data/database.js';
import { formatCredits, calculateInventoryUsed } from '../../utils.js';
import { ACTION_IDS, SHIP_IDS, GAME_RULES } from '../../data/constants.js';

/**
 * Renders the entire Hangar screen UI.
 * @param {object} gameState - The current state of the game.
 * @param {import('../../services/SimulationService.js').SimulationService} simulationService - The simulation service.
 * @returns {string} The HTML content for the Hangar screen.
 */
export function renderHangarScreen(gameState, simulationService) {
    const { uiState, player, tutorials } = gameState;

    // Determine the current mode (Hangar or Shipyard)
    const isHangarMode = uiState.hangarShipyardToggleState === 'hangar';
    const modeClass = isHangarMode ? 'mode-hangar' : 'mode-shipyard';
    
    const shipList = isHangarMode ? player.ownedShipIds : simulationService._getShipyardInventory().map(([id]) => id);
    
    // Use the active index from the UI state for the carousel
    const activeCarouselIndex = isHangarMode 
        ? (uiState.hangarActiveIndex || 0) 
        : (uiState.shipyardActiveIndex || 0);

    // Ensure index is not out of bounds if ship list changes
    const displayIndex = Math.min(activeCarouselIndex, Math.max(0, shipList.length - 1));

    return `
        <div id="ship-terminal-container" class="flex flex-col h-full ${modeClass}">
            <div class="toggle-container mx-auto my-1">
                <div class="toggle-switch p-1 rounded-md flex w-[180px] h-10">
                    <div class="toggle-label hangar flex-1 text-center py-1 cursor-pointer" data-action="${ACTION_IDS.TOGGLE_HANGAR_MODE}" data-mode="hangar">HANGAR</div>
                    <div class="toggle-label shipyard flex-1 text-center py-1 cursor-pointer" data-action="${ACTION_IDS.TOGGLE_HANGAR_MODE}" data-mode="shipyard">SHIPYARD</div>
                </div>
            </div>

            <div class="carousel-container flex-grow overflow-hidden relative">
                <div id="hangar-carousel" class="flex h-full" style="transform: translateX(-${displayIndex * 100}%)">
                    ${shipList.map(shipId => _renderShipCarouselPage(gameState, shipId, isHangarMode)).join('') || _renderEmptyCarouselPage(isHangarMode)}
                </div>
            </div>

            <div id="hangar-pagination" class="flex justify-center items-center p-2 space-x-2 flex-nowrap overflow-x-auto">
                ${shipList.map((_, index) => `<div class="pagination-dot w-2 h-2 rounded-full bg-gray-600 transition-all duration-300 ${index === displayIndex ? 'active' : ''}" data-action="${ACTION_IDS.SET_HANGAR_PAGE}" data-index="${index}"></div>`).join('')}
            </div>
        </div>
    `;
}

/**
 * Renders a placeholder page for when a carousel is empty.
 * @param {boolean} isHangarMode - True if the hangar is empty, false if the shipyard is empty.
 * @returns {string} HTML for the empty page.
 * @private
 */
function _renderEmptyCarouselPage(isHangarMode) {
    const message = isHangarMode ? "Your hangar is empty." : "No ships available in the shipyard.";
    return `
        <div class="carousel-page p-2 md:p-4 w-full">
             <div id="ship-terminal" class="relative h-full rounded-lg border-2" style="border-color: var(--frame-border-color);">
                <div class="flex flex-col items-center justify-center h-full">
                    <p class="text-gray-400">${message}</p>
                </div>
            </div>
        </div>
    `;
}


/**
 * Renders a single page within the ship carousel.
 * @param {object} gameState The current game state.
 * @param {string} shipId The ID of the ship for this page.
 * @param {boolean} isHangarMode True if the view is for the player's hangar.
 * @returns {string} The HTML for a single carousel page.
 * @private
 */
function _renderShipCarouselPage(gameState, shipId, isHangarMode) {
    const shipStatic = DB.SHIPS[shipId];
    const shipDynamic = isHangarMode ? gameState.player.shipStates[shipId] : null;
    const { player } = gameState;

    // Determine Status Badge
    let statusBadgeHtml = '';
    if (isHangarMode) {
        const isActive = player.activeShipId === shipId;
        statusBadgeHtml = `<div class="status-badge" style="border-color: ${isActive ? 'var(--theme-color-primary)' : 'var(--ot-border-light)'}; color: ${isActive ? 'var(--theme-color-primary)' : 'var(--ot-text-secondary)'};">${isActive ? 'ACTIVE' : 'STORED'}</div>`;
    }

    // Conditional rendering for shipyard layout
    const shipyardLayout = `
        <div class="col-span-3 flex flex-col justify-between">
            <div class="ship-display-area flex-grow flex items-center justify-center relative">
                <div class="ship-image-placeholder w-full rounded-lg flex items-center justify-center">
                    <span class="text-2xl font-orbitron">[ SHIP HOLOGRAM ]</span>
                </div>
                ${statusBadgeHtml}
            </div>
        </div>
        <div class="col-span-2 flex flex-col justify-between">
            ${_renderInfoPanel(gameState, shipId, shipStatic, shipDynamic, player, isHangarMode)}
            <div class="action-buttons-container pt-2">
                ${_renderActionButtons(shipId, shipStatic, player, isHangarMode, gameState.tutorials)}
            </div>
        </div>
    `;

    const hangarLayout = `
        <div class="col-span-2 flex flex-col justify-between">
            ${_renderInfoPanel(gameState, shipId, shipStatic, shipDynamic, player, isHangarMode)}
        </div>

        <div class="col-span-3 flex flex-col justify-between">
            <div class="ship-display-area flex-grow flex items-center justify-center relative">
                <div class="ship-image-placeholder w-full rounded-lg flex items-center justify-center">
                    <span class="text-2xl font-orbitron">[ SHIP HOLOGRAM ]</span>
                </div>
                ${statusBadgeHtml}
            </div>
            <div class="action-buttons-container pt-2">
                ${_renderActionButtons(shipId, shipStatic, player, isHangarMode, gameState.tutorials)}
            </div>
        </div>
    `;

    return `
        <div class="carousel-page p-2 md:p-4 w-full">
            <div id="ship-terminal" class="relative h-full rounded-lg border-2" style="border-color: var(--frame-border-color);">
                <div id="ship-card-main-content" class="h-full">
                    <div class="ship-card-content-wrapper h-full">
                        ${isHangarMode ? hangarLayout : shipyardLayout}
                    </div>
                </div>
            </div>
        </div>
    `;
}


/**
 * Renders the appropriate info panel (Hangar or Shipyard).
 * @param {object} gameState - The current state of the game.
 * @param {string} shipId - The ID of the ship.
 * @param {object} shipStatic - The static data for the ship.
 * @param {object} shipDynamic - The dynamic state for the ship (hangar only).
 * @param {object} player - The player object.
 * @param {boolean} isHangarMode - True if rendering the hangar view.
 * @returns {string} The HTML for the info panel.
 * @private
 */
function _renderInfoPanel(gameState, shipId, shipStatic, shipDynamic, player, isHangarMode) {
    const shipClassLower = shipStatic.class.toLowerCase();

    if (isHangarMode) {
        return `
            <div class="info-panel-content info-panel-hangar flex-col justify-between h-full">
                <div>
                    <h3 class="text-2xl font-orbitron inset-text-shadow" style="color: var(--class-${shipClassLower}-color);">${shipStatic.name}</h3>
                    <p class="text-md text-gray-400 inset-text-shadow">Class ${shipStatic.class} ${shipStatic.role || 'Freighter'}</p>
                </div>
                <div class="hangar-specs my-4">
                    ${_renderSpecBar("Hull", shipDynamic?.health, shipStatic.maxHealth, 'var(--ot-green-accent)')}
                    ${_renderSpecBar("Fuel", shipDynamic?.fuel, shipStatic.maxFuel, 'var(--ot-cyan-base)')}
                    ${_renderSpecBar("Cargo", calculateInventoryUsed(player.inventories[shipId]), shipStatic.cargoCapacity, 'var(--class-s-color)')}
                </div>
                <div class="flavor-text-box mt-auto" style="border-color: var(--frame-border-color);">
                    <p class="text-sm text-gray-300">${shipStatic.lore}</p>
                </div>
            </div>
        `;
    } else {
        return `
             <div class="info-panel-content info-panel-shipyard flex-col justify-between h-full">
                <div>
                    <h3 class="text-2xl font-orbitron inset-text-shadow" style="color: var(--class-${shipClassLower}-color);">${shipStatic.name}</h3>
                    <p class="text-md text-gray-400 inset-text-shadow">Class ${shipStatic.class} ${shipStatic.role || 'Freighter'}</p>
                    <p class="ship-price-display font-roboto-mono text-2xl">${formatCredits(shipStatic.price)}</p>
                </div>
                 <div class="grid grid-cols-3 gap-2 my-4">
                    ${_renderSpecCard("Max Hull", shipStatic.maxHealth)}
                    ${_renderSpecCard("Max Fuel", shipStatic.maxFuel)}
                    ${_renderSpecCard("Cargo Hold", shipStatic.cargoCapacity)}
                </div>
                <div class="flavor-text-box mt-auto" style="border-color: var(--frame-border-color);">
                    <p class="text-sm text-gray-300">${shipStatic.lore}</p>
                </div>
            </div>
        `;
    }
}


/**
 * Renders the appropriate action buttons (Hangar or Shipyard).
 * @param {string} shipId - The ID of the ship.
 * @param {object} shipStatic - The static data for the ship.
 * @param {object} player - The player object.
 * @param {boolean} isHangarMode - True if rendering the hangar view.
 * @param {object} tutorials - The current tutorial state.
 * @returns {string} The HTML for the action buttons.
 * @private
 */
function _renderActionButtons(shipId, shipStatic, player, isHangarMode, tutorials) {
    if (isHangarMode) {
        const isActive = player.activeShipId === shipId;
        const canSell = player.ownedShipIds.length > 1 && !isActive;
        const salePrice = Math.floor(shipStatic.price * GAME_RULES.SHIP_SELL_MODIFIER);
        return `
            <div class="grid grid-cols-2 gap-2">
                <button class="action-button" data-action="${ACTION_IDS.SELECT_SHIP}" data-ship-id="${shipId}" ${isActive ? 'disabled' : ''} style="background-color: ${isActive ? '#374151' : 'var(--ot-cyan-base)'}; color: ${isActive ? 'var(--ot-text-secondary)' : 'var(--ot-bg-dark)'};">
                    <span class="font-bold">${isActive ? 'ACTIVE' : 'BOARD'}</span>
                </button>
                <button class="action-button" data-action="${ACTION_IDS.SELL_SHIP}" data-ship-id="${shipId}" ${!canSell ? 'disabled' : ''} style="background-color: var(--ot-hangar-red-base);">
                    <span class="font-bold">SELL</span>
                    <span class="action-button-price font-roboto-mono">${formatCredits(salePrice, true)}</span>
                </button>
            </div>
        `;
    } else { // Shipyard
        const canAfford = player.credits >= shipStatic.price;
        const activeStep = tutorials.activeBatchId ? DB.TUTORIAL_DATA[tutorials.activeBatchId]?.steps.find(s => s.stepId === tutorials.activeStepId) : null;
        const isPurchaseLocked = tutorials.activeBatchId === 'intro_hangar' && !activeStep?.unlockPurchase;
        const isDisabled = !canAfford || isPurchaseLocked;
        
        return `
            <button class="action-button w-full justify-center" data-action="${ACTION_IDS.BUY_SHIP}" data-ship-id="${shipId}" ${isDisabled ? 'disabled' : ''} style="background-color: var(--ot-green-accent);">
                <span class="font-bold">PURCHASE</span>
            </button>
        `;
    }
}


/**
 * Helper to render a single stat bar for the Hangar view.
 * @private
 */
function _renderSpecBar(label, current, max, color) {
    const percentage = max > 0 ? (current / max) * 100 : 0;
    return `
        <div class="spec-readout hangar-specs">
            <span class="text-xs text-right pr-2 text-gray-400">${label}</span>
            <div class="spec-bar"><div class="spec-bar-fill" style="width: ${percentage}%; background-color: ${color}; --bar-color: ${color};"></div></div>
            <span class="text-xs text-left pl-2">${Math.floor(current ?? 0)}/${max}</span>
        </div>
    `;
}

/**
 * Helper to render a single spec card for the Shipyard view.
 * @private
 */
function _renderSpecCard(label, value) {
    return `
        <div class="spec-card">
            <p class="text-xs text-gray-400">${label}</p>
            <p class="text-lg font-bold font-orbitron">${value}</p>
        </div>
    `;
}
--- END OF FILE: ./js/ui/components/HangarScreen.js ---

--- START OF FILE: ./js/ui/components/IntelScreen.js ---
// js/ui/components/IntelScreen.js
/**
 * @fileoverview This file contains the rendering logic for the Intel screen.
 * It provides the player with access to the tutorial log and the game's lore.
 */

/**
 * Renders the entire Intel screen UI, which includes buttons to view the tutorial log and game lore.
 * @returns {string} The HTML content for the Intel screen.
 */
export function renderIntelScreen() {
    return `
        <div class="intel-scroll-panel">
            <div class="text-center p-8 flex flex-col items-center gap-4">
                 <div id="tutorial-button-container" class="tutorial-container relative">
                    <button class="btn btn-header">Tutorial Log</button>
                    <div id="tutorial-log-modal" class="tutorial-tooltip">
                        <h3 id="tutorial-log-title" class="text-2xl font-orbitron mb-4 text-center">Tutorial Log</h3>
                        <ul id="tutorial-log-list" class="space-y-2"></ul>
                    </div>
                </div>
                <div id="lore-button-container" class="lore-container relative">
                    <button class="btn btn-header">Story So Far...</button>
                    <div class="lore-tooltip">
                        <p>The year 2140 is the result of a single, massive corporate takeover. A century ago, the "Ad Astra Initiative" released advanced technology to all of humanity, a gift from the new Human-AI Alliance on Earth designed to kickstart our expansion into the stars. It was a promise of a new beginning, an open-source key to the solar system, ensuring the survival of all Earth life, both organic and synthetic.</p><br><p>But a gift to everyone is a business opportunity for the few. The hyper-corporations, already positioned in space, immediately patented the most efficient manufacturing processes and proprietary components for this new technology. This maneuver ensured that while anyone could build a Folded-Space Drive, only the corporations could supply the high-performance parts needed to make it truly effective, creating a system-wide technological dependency that persists to this day. This technological monopoly created the "Drive-Divide," the central pillar of the new class system. Nearly all ships run on older, less efficient hardware. Very few ships employ these coveted Folded-Space Drives.</p><br><p>The major hubs beyond Earth are sovereign, corporate-run territories where law is policy and your rights are listed in an employment contract. These scattered colonies are fierce rivals, engaged in constant economic warfare, all propped up by the interstellar supply lines maintained by the Merchant's Guild. For them, you are just another cog in the great machine of commerce.</p><br><p>In a system owned by corporations, possessing your own ship is the only true form of freedom. Every credit earned, every successful trade, is a bet on your own skill and a step toward true sovereignty on the razor's edge of a cargo manifest.</p>
                    </div>
                </div>
            </div>
        </div>`;
}
--- END OF FILE: ./js/ui/components/IntelScreen.js ---

--- START OF FILE: ./js/ui/components/NavigationScreen.js ---
// js/ui/components/NavigationScreen.js
/**
 * @fileoverview This file contains the rendering logic for the Navigation screen.
 * It displays the available travel destinations as interactive cards, showing the
 * fuel and time costs for each potential journey.
 */
import { DB } from '../../data/database.js';
import { ACTION_IDS, SCREEN_IDS } from '../../data/constants.js';

/**
 * Renders the entire Navigation screen UI.
 * @param {object} gameState - The current state of the game.
 * @returns {string} The HTML content for the Navigation screen.
 */
export function renderNavigationScreen(gameState) {
    const { player, currentLocationId, TRAVEL_DATA, tutorials } = gameState;
    const { navLock } = tutorials;

    // Check if a tutorial is active and has locked navigation.
    const isNavLocked = navLock && navLock.screenId === SCREEN_IDS.NAVIGATION;
    const enabledElementQuery = isNavLocked ? navLock.enabledElementQuery : null;
    
    return `
        <div class="scroll-panel p-1">
            <div class="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 gap-6">
            ${DB.MARKETS
                .filter(loc => player.unlockedLocationIds.includes(loc.id))
                .map(location => {
                    const isCurrent = location.id === currentLocationId;
                    const travelInfo = isCurrent ? null : TRAVEL_DATA[currentLocationId][location.id];

                    // Determine if this card should be disabled due to a tutorial lock.
                    let isDisabled = false;
                    if (isNavLocked && enabledElementQuery) {
                        // A workaround to check if this location card matches the tutorial's enabled element query.
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = `<div data-location-id="${location.id}"></div>`;
                        isDisabled = !tempDiv.querySelector(enabledElementQuery);
                    }
                    const disabledClass = isDisabled ? 'disabled-location' : '';

                    return `<div class="location-card p-6 rounded-lg text-center flex flex-col ${isCurrent ? 'highlight-current' : ''} ${location.color} ${location.bg} ${disabledClass}" 
                                 data-action="show-launch-modal" data-location-id="${location.id}" ${isDisabled ? 'disabled' : ''}>
                        <h3 class="text-2xl font-orbitron flex-grow">${location.name}</h3>
                        <div class="location-card-footer mt-auto pt-3 border-t border-cyan-100/10">
                        ${isCurrent 
                            ? '<p class="text-yellow-300 font-bold mt-2">(Currently Docked)</p>' 
                            : `<div class="flex justify-around items-center text-center">
                                   <div class="flex items-center space-x-2">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-13a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V5z" clip-rule="evenodd" /></svg>
                                       <div><span class="font-bold font-roboto-mono text-lg">${travelInfo.time}</span><span class="block text-xs text-gray-400">Days</span></div>
                                   </div>
                                   <div class="flex items-center space-x-2">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-sky-400" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M11.3 1.046A1 1 0 0112 2v5h4a1 1 0 01.82 1.573l-7 10A1 1 0 018 18v-5H4a1 1 0 01-.82-1.573l7-10a1 1 0 011.12-.38z" clip-rule="evenodd" /></svg>
                                       <div><span class="font-bold font-roboto-mono text-lg">${travelInfo.fuelCost}</span><span class="block text-xs text-gray-400">Fuel</span></div>
                                   </div>
                               </div>`
                        }
                      </div>
                      </div>`;
                }).join('')
            }
            </div>
        </div>`;
}
--- END OF FILE: ./js/ui/components/NavigationScreen.js ---

--- START OF FILE: ./js/ui/components/MissionsScreen.js ---
// js/ui/components/MissionsScreen.js
/**
 * @fileoverview This file contains the rendering logic for the Missions screen.
 * It is responsible for displaying the currently active mission and a list of all
 * available missions for the player.
 */
import { DB } from '../../data/database.js';

/**
 * Renders the entire Missions screen UI.
 * @param {object} gameState - The current state of the game.
 * @param {import('../../services/MissionService.js').MissionService} missionService - An instance of the MissionService to fetch available missions.
 * @returns {string} The HTML content for the Missions screen.
 */
export function renderMissionsScreen(gameState, missionService) {
    const { missions, currentLocationId } = gameState;
    const { activeMissionId, activeMissionObjectivesMet } = missions;

    /**
     * Generates the HTML for a single mission card.
     * @param {object} mission - The mission object from the database.
     * @param {string} status - The status of the mission ('active', 'completed', 'available').
     * @returns {string} The HTML for the mission card.
     */
    const getMissionCardHtml = (mission, status) => {
        let statusClass = '';
        if (status === 'active') statusClass = 'mission-active';
        if (status === 'completed') statusClass = 'mission-complete';
        // Special class for an active mission that is ready to be turned in at the current location.
        if (status === 'active' && activeMissionObjectivesMet && mission.completion.locationId === currentLocationId) {
            statusClass += ' mission-turn-in';
        }

        const hostClass = `host-${mission.host.toLowerCase().replace(/[^a-z0-9]/g, '')}`;
        const rewardText = mission.rewards.map(r => {
            if(r.type === 'credits') return `⌬ ${r.amount.toLocaleString()}`;
            return r.type.toUpperCase();
        }).join(', ');

        return `
            <div class="mission-card sci-fi-frame ${hostClass} ${statusClass}" data-action="show-mission-modal" data-mission-id="${mission.id}">
                <div class="flex justify-between items-center w-full text-xs mb-1">
                    <div class="flex items-center gap-2">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01"></path></svg>
                        <span class="mission-type">${mission.type}</span>
                    </div>
                    <span class="mission-host">${mission.host}</span>
                </div>
                <div class="flex justify-between items-end w-full">
                    <p class="font-bold text-base">${mission.name}</p>
                    <span class="mission-reward">${rewardText}</span>
                </div>
            </div>`;
    };

    let missionsHtml = '';
    const activeMission = activeMissionId ? DB.MISSIONS[activeMissionId] : null;
    if (activeMission) {
        missionsHtml += getMissionCardHtml(activeMission, 'active');
    }
    
    if (missionService) {
        const availableMissions = missionService.getAvailableMissions();
        availableMissions.forEach(mission => {
            missionsHtml += getMissionCardHtml(mission, 'available');
        });
    }

    if (missionsHtml === '') {
        missionsHtml = '<p class="text-center text-gray-500 text-lg">No missions available at this terminal.</p>';
    }

    return `
        <div class="flex flex-col h-full">
            <h1 class="text-3xl font-orbitron text-center mb-6 text-cyan-300 flex-shrink-0">Mission Terminal</h1>
            <div class="missions-scroll-panel flex-grow min-h-0">
                <div class="space-y-3 max-w-2xl mx-auto">
                    ${missionsHtml}
                </div>
            </div>
        </div>
    `;
}
--- END OF FILE: ./js/ui/components/MissionsScreen.js ---

--- START OF FILE: ./js/ui/components/FinanceScreen.js ---
// js/ui/components/FinanceScreen.js
/**
 * @fileoverview This file contains the rendering logic for the Finance screen.
 * It displays the player's current debt status or available loan options,
 * as well as a detailed log of all financial transactions.
 */
import { DB } from '../../data/database.js';
import { formatCredits } from '../../utils.js';
import { ACTION_IDS, GAME_RULES } from '../../data/constants.js';

/**
 * Renders the entire Finance screen UI.
 * @param {object} gameState - The current state of the game.
 * @returns {string} The HTML content for the Finance screen.
 */
export function renderFinanceScreen(gameState) {
    const { player, day, currentLocationId } = gameState;
    const location = DB.MARKETS.find(l => l.id === currentLocationId);
    const theme = location?.navTheme || { gradient: 'linear-gradient(135deg, #4a5568, #2d3748)', textColor: '#f0f0f0', borderColor: '#7a9ac0' };
    let loanHtml;

    // Display the current debt panel if the player has debt.
    if (player.debt > 0) {
        let garnishmentTimerHtml = '';
        if (player.loanStartDate) {
            const daysRemaining = GAME_RULES.LOAN_GARNISHMENT_DAYS - (day - player.loanStartDate);
            if (daysRemaining > 0) {
                garnishmentTimerHtml = `<p class="text-xs text-red-400/70 mt-2">Garnishment in ${daysRemaining} days</p>`;
            }
        }
        loanHtml = `
            <div>
                <h3 class="text-2xl font-orbitron text-center mb-4">Debt</h3>
                <div class="p-4 rounded-lg flex flex-col items-center justify-center space-y-2 shadow-lg panel-border border text-center" style="border-color: ${theme.borderColor}; color: ${theme.textColor}; background: ${theme.gradient};">
                    <button data-action="${ACTION_IDS.PAY_DEBT}" class="btn w-full py-2 bg-red-800/80 hover:bg-red-700/80 border-red-500 font-roboto-mono" ${player.credits >= player.debt ? '' : 'disabled'}>
                        Pay Off ${formatCredits(player.debt)}
                    </button>
                    ${garnishmentTimerHtml}
                </div>
            </div>`;
    } else {
        // Otherwise, display available loan options.
        const dynamicLoanAmount = Math.floor(player.credits * 3.5);
        const dynamicLoanFee = Math.floor(dynamicLoanAmount * 0.1);
        const dynamicLoanInterest = Math.floor(dynamicLoanAmount * 0.04);
        const dynamicLoanData = { amount: dynamicLoanAmount, fee: dynamicLoanFee, interest: dynamicLoanInterest };
        const loanButtonsHtml = [
            { key: '10000', amount: 10000, fee: 600, interest: 500 },
            { key: 'dynamic', ...dynamicLoanData }
        ].map((loan) => {
            return `<button class="btn btn-loan w-full p-2 mt-2" data-action="${ACTION_IDS.TAKE_LOAN}" data-loan-details='${JSON.stringify(loan)}' ${player.credits < loan.fee ? 'disabled' : ''}>
                        <span class="font-orbitron text-cyan-300">⌬ ${formatCredits(loan.amount, false)}</span>
                    </button>`;
        }).join('');
        loanHtml = `
            <div>
                <h3 class="text-2xl font-orbitron text-center mb-4">Financing</h3>
                <div class="p-4 rounded-lg flex flex-col items-center justify-center space-y-2 shadow-lg panel-border border text-center" style="border-color: ${theme.borderColor}; color: ${theme.textColor}; background: ${theme.gradient};">
                    <div class="flex justify-center gap-4 w-full">${loanButtonsHtml}</div>
                </div>
            </div>`;
    }

    // Render the transaction log.
    const logEntries = [...player.financeLog].reverse().map(entry => {
        const amountColor = entry.amount > 0 ? 'text-green-400' : 'text-red-400';
        const sign = entry.amount > 0 ? '+' : '';
        return `
            <div class="grid grid-cols-4 gap-2 p-2 border-b border-slate-700 text-sm">
                <span class="text-gray-400">${entry.day}</span>
                <span class="col-span-2">${entry.description}</span>
                <span class="${amountColor} text-right">${sign}${formatCredits(entry.amount, false)}</span>
            </div>
        `;
       }).join('');

    return `
        <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
            <div class="md:col-span-1">
                ${loanHtml}
            </div>
            <div class="md:col-span-2">
                 <h3 class="text-2xl font-orbitron text-center mb-4">Transaction Log</h3>
                 <div class="finance-log-panel p-4 rounded-lg shadow-lg panel-border border" style="border-color: ${theme.borderColor}; color: ${theme.textColor}; background: ${theme.gradient};">
                    <div class="grid grid-cols-4 gap-2 p-2 border-b-2 font-bold" style="border-color: ${theme.borderColor};">
                       <span>Day</span>
                       <span class="col-span-2">Description</span>
                       <span class="text-right">Amount</span>
                    </div>
                    ${logEntries || '<p class="text-center p-4">No transactions recorded.</p>'}
                 </div>
            </div>
        </div>
    `;
}
--- END OF FILE: ./js/ui/components/FinanceScreen.js ---

--- START OF FILE: ./js/ui/components/ServicesScreen.js ---
// js/ui/components/ServicesScreen.js
/**
 * @fileoverview This file contains the rendering logic for the Station Services screen.
 * It displays options for refueling and repairing the player's active ship, calculating
 * costs based on the current location and any active player perks.
 */
import { DB } from '../../data/database.js';
import { formatCredits } from '../../utils.js';
import { GAME_RULES, PERK_IDS, LOCATION_IDS } from '../../data/constants.js';

/**
 * Renders the entire Services screen UI.
 * @param {object} gameState - The current state of the game.
 * @returns {string} The HTML content for the Services screen.
 */
export function renderServicesScreen(gameState) {
    const { player, currentLocationId } = gameState;
    const shipStatic = DB.SHIPS[player.activeShipId];
    const shipState = player.shipStates[player.activeShipId];
    const currentMarket = DB.MARKETS.find(m => m.id === currentLocationId);
    const theme = currentMarket?.navTheme || { gradient: 'linear-gradient(135deg, #4a5568, #2d3748)', textColor: '#f0f0f0', borderColor: '#7a9ac0' };


    // Calculate fuel price, applying perks if applicable.
    let fuelPrice = currentMarket.fuelPrice / 2;
    if (player.activePerks[PERK_IDS.VENETIAN_SYNDICATE] && currentLocationId === LOCATION_IDS.VENUS) {
        fuelPrice *= (1 - DB.PERKS[PERK_IDS.VENETIAN_SYNDICATE].fuelDiscount);
    }
    
    // Calculate repair price per tick, applying perks if applicable.
    let costPerRepairTick = (shipStatic.maxHealth * (GAME_RULES.REPAIR_AMOUNT_PER_TICK / 100)) * GAME_RULES.REPAIR_COST_PER_HP;
    if (player.activePerks[PERK_IDS.VENETIAN_SYNDICATE] && currentLocationId === LOCATION_IDS.VENUS) {
        costPerRepairTick *= (1 - DB.PERKS[PERK_IDS.VENETIAN_SYNDICATE].repairDiscount);
    }

    const fuelPct = (shipState.fuel / shipStatic.maxFuel) * 100;
    const healthPct = (shipState.health / shipStatic.maxHealth) * 100;
    
    return `
        <div class="services-scroll-panel">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 max-w-4xl mx-auto mt-8">
                <div class="p-4 rounded-lg text-center shadow-lg panel-border border" style="border-color: ${theme.borderColor}; color: ${theme.textColor}; background: ${theme.gradient};">
                    <h4 class="font-orbitron text-xl mb-2">Refueling</h4>
                    <p class="mb-3">Price: <span class="font-bold">⌬ ${formatCredits(fuelPrice, false)}</span> / 5 units</p>
                    <button id="refuel-btn" class="btn w-full py-3" ${shipState.fuel >= shipStatic.maxFuel ? 'disabled' : ''}>Hold to Refuel</button>
                    <div class="w-full hud-stat-bar mt-2"><div id="fuel-bar" style="width: ${fuelPct}%" class="bg-sky-400"></div></div>
                </div>
                <div class="p-4 rounded-lg text-center shadow-lg panel-border border" style="border-color: ${theme.borderColor}; color: ${theme.textColor}; background: ${theme.gradient};">
                    <h4 class="font-orbitron text-xl mb-2">Ship Maintenance</h4>
                    <p class="mb-3">Price: <span class="font-bold">⌬ ${formatCredits(costPerRepairTick, false)}</span> / 5% repair</p>
                    <button id="repair-btn" class="btn w-full py-3" ${shipState.health >= shipStatic.maxHealth ? 'disabled' : ''}>Hold to Repair</button>
                    <div class="w-full hud-stat-bar mt-2"><div id="repair-bar" style="width: ${healthPct}%" class="bg-green-400"></div></div>
                </div>
            </div>
        </div>`;
}
--- END OF FILE: ./js/ui/components/ServicesScreen.js ---

--- START OF FILE: ./js/ui/components/CargoScreen.js ---
// js/ui/components/CargoScreen.js
/**
 * @fileoverview This file contains the rendering logic for the Cargo screen.
 * It is responsible for displaying the contents of the player's active ship's cargo hold.
 * The new design features a grid of small cargo items ('min-cargo') that expand into
 * a detailed modal view ('max-cargo').
 */
import { DB } from '../../data/database.js';
import { formatCredits, getCommodityStyle } from '../../utils.js';
import { ACTION_IDS } from '../../data/constants.js';

/**
 * Renders the entire Cargo screen UI, displaying a grid of items.
 * @param {object} gameState - The current state of the game.
 * @returns {string} The HTML content for the Cargo screen.
 */
export function renderCargoScreen(gameState) {
    const inventory = gameState.player.inventories[gameState.player.activeShipId];
    if (!inventory) return '<p class="text-center text-gray-500 text-lg">No active ship.</p>';

    const ownedGoods = Object.entries(inventory).filter(([, item]) => item.quantity > 0);

    if (ownedGoods.length === 0) {
        return '<p class="text-center text-gray-500 text-lg">Your cargo hold is empty.</p>';
    }

    const cargoItemsHtml = ownedGoods.map(([goodId, item]) => {
        const good = DB.COMMODITIES.find(c => c.id === goodId);
        return _renderMinCargoItem(good, item);
    }).join('');

    return `<div class="cargo-scroll-panel"><div class="cargo-grid">${cargoItemsHtml}</div></div>`;
}

/**
 * Renders a single small, clickable cargo item for the grid view.
 * @param {object} good - The static data for the commodity from the database.
 * @param {object} item - The player's inventory data for the item (quantity, avgCost).
 * @returns {string} The HTML for a single min-cargo item.
 * @private
 */
function _renderMinCargoItem(good, item) {
    const styles = getCommodityStyle(good.styleClass);

    return `
        <div class="min-cargo-item" 
             style="background: ${styles.gradient}; border: 2px solid ${styles.hex};"
             data-action="show_cargo_detail" 
             data-good-id="${good.id}">
            
            <div class="pt-symbol" style="font-size: 2rem; color: ${styles.hex}; text-shadow: 0 0 5px rgba(0,0,0,0.7);">${good.symbol.toUpperCase()}</div>
            <div class="pt-quantity text-gray-400" style="text-shadow: 1px 1px 3px #000;">(${item.quantity})</div>
        </div>
    `;
}

/**
 * Renders the detailed modal view for a selected cargo item.
 * @param {object} good - The static data for the commodity.
 * @param {object} item - The player's inventory data for the item.
 * @returns {string} The HTML for the max-cargo modal content.
 */
export function _renderMaxCargoModal(good, item) {
    const styles = getCommodityStyle(good.styleClass);

    const categoryMap = {
        RAW: 'Raw Material',
        IND: 'Industrial Product',
        AGRI: 'Agricultural Good',
        TECH: 'Technology',
        CIV: 'Civilian Commodity',
        BIO: 'Bioware',
        RARE: 'Exotic Material'
    };
    const fullCategory = categoryMap[good.cat] || 'Unknown';

    const galacticAvg = (good.basePriceRange[0] + good.basePriceRange[1]) / 2;
    const avgValue = galacticAvg * item.quantity;

    return `
        <div class="max-cargo-card" style="background: ${styles.gradient}; border-color: ${styles.hex};">
            <h3 class="text-2xl font-orbitron text-center">${good.name}</h3>
            <p class="text-sm text-center tier-type-line mb-4" style="color: ${styles.hex};">Tier ${good.tier} ${fullCategory}</p>
            <p class="flavor-text">${good.lore}</p>
            <div class="avg-cost">
                <div>Avg. Cost: <span class="font-bold credits-text-pulsing">${formatCredits(item.avgCost, true)}</span></div>
                <div>Qty Aboard: <span class="font-bold">${item.quantity}</span></div>
                <div>Avg. Value: <span class="font-bold credits-text-pulsing">${formatCredits(avgValue, true)}</span></div>
            </div>
        </div>
    `;
}
--- END OF FILE: ./js/ui/components/CargoScreen.js ---

--- START OF FILE: ./js/ui/components/MarketScreen.js ---
// js/ui/components/MarketScreen.js
/**
 * @fileoverview
 * This file contains the rendering logic for the Market screen.
 * It is responsible for displaying all available commodities for trade.
 */
import { DB } from '../../data/database.js';
import { formatCredits, renderIndicatorPills } from '../../utils.js';
import { ACTION_IDS, COMMODITY_IDS } from '../../data/constants.js';

/**
 * Renders the entire Market screen, adapting for mobile or desktop layouts.
 * @param {object} gameState - The current state of the game.
 * @param {boolean} isMobile - A flag indicating if the mobile layout should be used.
 * @param {function} getItemPrice - A reference to the UIManager's getItemPrice function.
 * @param {object} marketTransactionState - The saved state of the transaction modules.
 * @returns {string} The HTML content for the Market screen.
 */
export function renderMarketScreen(gameState, isMobile, getItemPrice, marketTransactionState) {
    const availableCommodities = DB.COMMODITIES.filter(c => c.tier <= gameState.player.revealedTier);
    const marketHtml = availableCommodities.map(good => {
        return _getMarketItemHtml(good, gameState, getItemPrice, marketTransactionState);
    }).join('');

    return `<div class="scroll-panel">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">${marketHtml}</div>
            </div>`;
}

/**
 * Generates the HTML for a single commodity card on the market screen.
 * @param {object} good - The commodity data from the database.
 * @param {object} gameState - The current game state.
 * @param {function} getItemPrice - A function to calculate the item's current price.
 * @param {object} marketTransactionState - The saved state of the transaction modules.
 * @returns {string} The HTML string for the commodity card.
 * @private
 */
function _getMarketItemHtml(good, gameState, getItemPrice, marketTransactionState) {
    const { player, market, currentLocationId, tutorials, uiState } = gameState;
    const playerItem = player.inventories[player.activeShipId]?.[good.id];
    const price = getItemPrice(gameState, good.id);
    const sellPrice = getItemPrice(gameState, good.id, true);
    const galacticAvg = market.galacticAverages[good.id];
    const marketStock = market.inventory[currentLocationId]?.[good.id];
    
    const hasLicense = !good.licenseId || player.unlockedLicenseIds.includes(good.licenseId);

    const isPlasteelTutStep = tutorials.activeBatchId === 'intro_missions' && tutorials.activeStepId === 'mission_2_2';
    const isMarketLockedForMission = tutorials.activeBatchId === 'intro_missions' && tutorials.activeStepId === 'mission_2_3';
    const isLockedForTutorial = (isPlasteelTutStep && good.id !== COMMODITY_IDS.PLASTEEL) || isMarketLockedForMission;

    const nameTooltip = `data-tooltip="${good.lore}"`;
    const playerInvDisplay = playerItem && playerItem.quantity > 0 ? playerItem.quantity : '0';
    const isMinimized = uiState.marketCardMinimized[good.id];

    // Use the new centralized utility function to render indicators for the initial view.
    const indicatorHtml = renderIndicatorPills({ price, sellPrice, galacticAvg, playerItem });
    const avgCostHtml = playerItem && playerItem.quantity > 0 ? `<div class="avg-cost-display" id="avg-cost-${good.id}">Avg. Cost: ${formatCredits(playerItem.avgCost, false)}</div>` : '';

    let transactionControlsHtml;
    if (hasLicense) {
        // Correctly set initial mode based on saved state, otherwise default to 'buy'
        const initialMode = marketTransactionState[good.id]?.mode || 'buy';

        transactionControlsHtml = `
             <div class="transaction-controls" data-mode="${initialMode}" data-good-id="${good.id}" ${isLockedForTutorial ? 'disabled' : ''}>
                <div class="toggle-switch" data-action="toggle-trade-mode" data-good-id="${good.id}">
                    <div class="toggle-thumb"></div>
                    <div class="toggle-labels"><span class="label-buy">Buy</span><span class="label-sell">Sell</span></div>
                </div>
                <div class="qty-stepper">
                    <button class="qty-down" data-action="decrement" data-good-id="${good.id}">▼</button>
                    <input type="number" value="0" id="qty-${good.id}" min="0">
                    <button class="qty-up" data-action="increment" data-good-id="${good.id}">▲</button>
                </div>
                <div class="action-group">
                    <button class="btn confirm-btn" data-action="confirm-trade" data-good-id="${good.id}">Confirm</button>
                    <button class="btn max-btn" data-action="set-max-trade" data-good-id="${good.id}">Max</button>
                </div>
            </div>`;
    } else {
        transactionControlsHtml = `
            <div class="transaction-controls absolute inset-0 flex items-center justify-center p-4">
                <button class="btn w-full h-full text-center" data-action="${ACTION_IDS.ACQUIRE_LICENSE}" data-license-id="${good.licenseId}">Acquire License</button>
            </div>`;
    }

    const ownedQtyText = playerItem?.quantity > 0 ? ` (${playerItem.quantity})` : '';

    return `
    <div class="item-card-container ${!hasLicense ? 'locked' : ''} ${isMinimized ? 'minimized' : ''}" id="item-card-container-${good.id}">
        <div class="rounded-lg border ${good.styleClass} transition-colors shadow-md">
            <button class="card-toggle-btn" data-action="${ACTION_IDS.TOGGLE_MARKET_CARD_VIEW}" data-good-id="${good.id}">${isMinimized ? '+' : '−'}</button>
            
            <div class="max-view-content">
                <p class="font-bold commodity-name"><span class="commodity-name-tooltip" ${nameTooltip}>${good.name}</span></p>
                <p class="avail-text">Avail: <span id="m-stock-${good.id}">${marketStock.quantity}</span>, Own: <span id="p-inv-${good.id}">${playerInvDisplay}</span></p>
                <p id="price-display-${good.id}" class="font-roboto-mono font-bold price-text" data-action="${ACTION_IDS.SHOW_PRICE_GRAPH}" data-good-id="${good.id}" data-base-price="${price}">${formatCredits(price)}</p>
                
                <div id="effective-price-display-${good.id}" class="effective-price-display"></div>
                
                <div class="indicator-container" id="indicators-${good.id}">${indicatorHtml}</div>

                ${avgCostHtml}

                ${transactionControlsHtml}
            </div>

            <div class="min-view-content">
                <p class="font-bold commodity-name-min">${good.name}${ownedQtyText}</p>
                <p class="tier-text-min">Tier ${good.tier} | ${good.cat}</p>
            </div>
        </div>
    </div>`;
}
--- END OF FILE: ./js/ui/components/MarketScreen.js ---

--- START OF FILE: ./js/main.js ---
// js/main.js
import { GameState } from './services/GameState.js';
import { SimulationService } from './services/SimulationService.js';
import { UIManager } from './services/UIManager.js';
import { EventManager } from './services/EventManager.js';
import { TutorialService } from './services/TutorialService.js';
import { MissionService } from './services/MissionService.js';
import { DebugService } from './services/DebugService.js';
import { Logger } from './services/LoggingService.js';

// Import the new service shells
import { IntroService } from './services/game/IntroService.js';
import { PlayerActionService } from './services/player/PlayerActionService.js';
import { TimeService } from './services/world/TimeService.js';
import { TravelService } from './services/world/TravelService.js';


document.addEventListener('DOMContentLoaded', () => {
    // --- App Initialization ---
    const splashScreen = document.getElementById('splash-screen');
    const startButton = document.getElementById('start-game-btn');
    const DEV_MODE = true; // Guard for development features.

    // Set up the main start button to initialize and begin the game.
    startButton.addEventListener('click', () => {
        // Fade out the splash screen and then start the game logic.
        splashScreen.classList.add('modal-hiding');
        splashScreen.addEventListener('animationend', () => {
            splashScreen.style.display = 'none';
        }, { once: true });

        startGame();

    }, { once: true });

    /**
     * Instantiates all core game services, establishes their dependencies,
     * loads saved data or starts a new game, and binds all necessary event listeners.
     */
    function startGame() {
        // --- Service Instantiation ---
        const gameState = new GameState();
        const uiManager = new UIManager(Logger);
        const missionService = new MissionService(gameState, uiManager, Logger);
        const simulationService = new SimulationService(gameState, uiManager, Logger);
        const tutorialService = new TutorialService(gameState, uiManager, simulationService, uiManager.navStructure, Logger);
        let debugService = null;

        if (DEV_MODE) {
            debugService = new DebugService(gameState, simulationService, uiManager, Logger);
            debugService.init();
        }
        
        // --- Dependency Injection ---
        // Services are created first, then dependencies are injected to avoid circular reference issues during instantiation.
        uiManager.setMissionService(missionService);
        uiManager.setSimulationService(simulationService); // Inject SimulationService into UIManager
        simulationService.setTutorialService(tutorialService);
        simulationService.setMissionService(missionService);
        missionService.setSimulationService(simulationService);
        const eventManager = new EventManager(gameState, simulationService, uiManager, tutorialService, debugService, Logger);
        
        // --- Link GameState to UIManager for automatic re-rendering ---
        gameState.subscribe(() => uiManager.render(gameState.getState()));

        // --- Game Initialization ---
        const hasSave = gameState.loadGame();
        if (!hasSave) {
            // If no save file is found, begin the new game intro sequence.
            gameState.startNewGame('');
            simulationService.timeService.advanceDays(7); // Seed market with 1 week of price history.
            simulationService.startIntroSequence();
        }

        // --- Bindings ---
        eventManager.bindEvents();
        
        // If a save file was loaded, the intro is skipped, and the game container is shown immediately.
        if (hasSave) {
            document.getElementById('game-container').classList.remove('hidden');
            uiManager.render(gameState.getState());
        }
        
        // Perform an initial check for any tutorials that should trigger on game load.
        tutorialService.checkState({ type: 'SCREEN_LOAD', screenId: gameState.activeScreen });
    }
});
--- END OF FILE: ./js/main.js ---

--- START OF FILE: ./js/utils.js ---
// js/utils.js
/**
 * @fileoverview This file contains globally accessible utility functions for various tasks
 * such as formatting numbers, calculating inventory usage, and handling date conversions.
 * These helpers are used throughout the application to standardize common operations.
 */
import { DATE_CONFIG } from './data/database.js';

/**
 * A centralized map for commodity visual styles.
 * @type {Object.<string, {hex: string, gradient: string}>}
 */
const commodityStyleMap = {
    'item-style-1':  { hex: '#60a5fa', gradient: 'linear-gradient(45deg, #3b82f6, #1e3a8a)' },
    'item-style-2':  { hex: '#a3a3a3', gradient: 'linear-gradient(45deg, #737373, #262626)' },
    'item-style-3':  { hex: '#22c55e', gradient: 'linear-gradient(45deg, #16a34a, #14532d)' },
    'item-style-4':  { hex: '#e5e5e5', gradient: 'linear-gradient(45deg, #d4d4d4, #737373)' },
    'item-style-5':  { hex: '#c084fc', gradient: 'linear-gradient(45deg, #a855f7, #6b21a8)' },
    'item-style-6':  { hex: '#93c5fd', gradient: 'linear-gradient(45deg, #60a5fa, #2563eb)' },
    'item-style-7':  { hex: '#84cc16', gradient: 'linear-gradient(45deg, #a3e635, #4d7c0f)' },
    'item-style-8':  { hex: '#67e8f9', gradient: 'linear-gradient(45deg, #22d3ee, #0891b2)' },
    'item-style-9':  { hex: '#fcd34d', gradient: 'linear-gradient(45deg, #facc15, #b45309)' },
    'item-style-10': { hex: '#fb7185', gradient: 'linear-gradient(45deg, #f43f5e, #9f1239)' },
    'item-style-11': { hex: '#a78bfa', gradient: 'linear-gradient(165deg, #a78bfa, #312e81, #1e3a8a)' },
    'item-style-12': { hex: '#f87171', gradient: 'linear-gradient(45deg, #ef4444, #7f1d1d)' },
    'item-style-13': { hex: '#d8b4fe', gradient: 'linear-gradient(45deg, #a855f7, #3b0764)' },
    'item-style-14': { hex: '#f472b6', gradient: 'linear-gradient(45deg, #ec4899, #831843)' },
};

/**
 * Retrieves the style object for a given commodity style class.
 * @param {string} styleClass - The style class of the commodity.
 * @returns {{hex: string, gradient: string}} The style object.
 */
export function getCommodityStyle(styleClass) {
    return commodityStyleMap[styleClass] || { hex: '#a8a29e', gradient: 'linear-gradient(45deg, #52525b, #18181b)' };
}

/**
 * Formats a number into a compact, human-readable credit string with appropriate suffixes (k, M, B, T).
 * This function now correctly handles negative values.
 * Example: -12345 becomes '⌬ -12.3k'.
 * @param {number} amount The numeric value to format.
 * @param {boolean} [withSymbol=true] - Whether to prepend the '⌬ ' symbol.
 * @returns {string} The formatted credit string.
 */
export function formatCredits(amount, withSymbol = true) {
    const isNegative = amount < 0;
    const num = Math.abs(Math.floor(amount));
    const prefix = withSymbol ? '⌬ ' : '';
    const sign = isNegative ? '-' : '';

    let formattedNumber;
    if (num >= 1e12) {
        formattedNumber = `${(num / 1e12).toFixed(2)}T`;
    } else if (num >= 1e9) {
        formattedNumber = `${(num / 1e9).toFixed(2)}B`;
    } else if (num >= 1e6) {
        formattedNumber = `${(num / 1e6).toFixed(2)}M`;
    } else if (num >= 1e3) {
        formattedNumber = `${(num / 1e3).toFixed(1)}k`;
    } else {
        formattedNumber = num.toLocaleString();
    }

    return `${prefix}${sign}${formattedNumber}`;
}


/**
 * Calculates the total number of cargo units currently used in a given inventory object.
 * @param {object} inventory - The inventory object to calculate, where keys are commodity IDs
 * and values are objects containing a 'quantity' property.
 * @returns {number} The total sum of all item quantities in the inventory.
 */
export function calculateInventoryUsed(inventory) {
     if (!inventory) return 0;
    return Object.values(inventory).reduce((acc, item) => acc + item.quantity, 0);
}

/**
 * Returns the correct ordinal suffix (st, nd, rd, th) for a given day of the month.
 * @param {number} day - The day of the month.
 * @returns {string} The ordinal suffix.
 * @private
 */
function getDaySuffix(day) {
    if (day > 3 && day < 21) return 'th';
    switch (day % 10) {
        case 1: return "st";
        case 2: return "nd";
        case 3: return "rd";
        default: return "th";
    }
}

/**
 * Converts an absolute day number from the start of the game into a formatted date string.
 * Example: 'Monday, January 1st, 2140'.
 * @param {number} dayNumber - The absolute day number of the game.
 * @returns {string} The fully formatted date string.
 */
export function getDateFromDay(dayNumber) {
    const year = DATE_CONFIG.START_YEAR + Math.floor((dayNumber - 1) / 365);
    let dayOfYear = (dayNumber - 1) % 365;
    const dayOfWeek = DATE_CONFIG.DAY_NAMES[(dayNumber - 1 + DATE_CONFIG.START_DAY_OF_WEEK) % 7];
    let monthIndex = 0;
    for (let i = 0; i < DATE_CONFIG.DAYS_IN_MONTH.length; i++) {
        if (dayOfYear < DATE_CONFIG.DAYS_IN_MONTH[i]) {
            monthIndex = i;
            break;
        }
        dayOfYear -= DATE_CONFIG.DAYS_IN_MONTH[i];
    }
    const dayOfMonth = dayOfYear + 1;
    const monthName = DATE_CONFIG.MONTH_NAMES[monthIndex];
    return `${dayOfWeek}, ${monthName} ${dayOfMonth}${getDaySuffix(dayOfMonth)}, ${year}`;
}

/**
 * Generates a random integer between a min and max value, skewed towards the lower end.
 * This is useful for creating distributions where lower values are more common.
 * @param {number} min - The minimum possible value (inclusive).
 * @param {number} max - The maximum possible value (inclusive).
 * @returns {number} The skewed random integer.
 */
export function skewedRandom(min, max) {
    let rand = (Math.random() + Math.random() + Math.random()) / 3; // Average of 3 rolls biases towards the mean (0.5).
    return Math.floor(min + (max - min) * Math.pow(rand, 0.5)); // Squaring the root further biases towards the lower end.
}

/**
 * Generates the HTML for the MKT and P/L indicators on a market card.
 * This centralized function ensures consistent and accurate indicator rendering.
 * @param {object} data - An object containing all necessary data for rendering.
 * @param {number} data.price - The current market buy price.
 * @param {number} data.sellPrice - The effective sell price (after diminishing returns).
 * @param {number} data.galacticAvg - The galactic average price for the commodity.
 * @param {object} data.playerItem - The player's inventory data for this commodity (can be null).
 * @returns {string} The HTML string for the indicator pills.
 */
export function renderIndicatorPills({ price, sellPrice, galacticAvg, playerItem }) {
    // Market vs Galactic Average Indicator (MKT)
    const marketDiff = price - galacticAvg;
    const marketPct = galacticAvg > 0 ? Math.round((marketDiff / galacticAvg) * 100) : 0;
    const marketSign = marketPct >= 0 ? '+' : '';
    let marketClass = 'neutral';
    if (marketPct > 5) marketClass = 'positive';
    if (marketPct < -5) marketClass = 'negative';
    const marketIcon = marketPct > 5 ? '▲' : (marketPct < -5 ? '▼' : '●');
    const marketIndicatorHtml = `<div class="indicator-pill ${marketClass}">${marketIcon} MKT: ${marketSign}${marketPct}%</div>`;

    let plIndicatorHtml = '';
    
    // Profit/Loss Indicator (P/L)
    if (playerItem && playerItem.avgCost > 0) {
        const spreadPerUnit = sellPrice - playerItem.avgCost;
        
        if (Math.abs(spreadPerUnit) > 0.01) {
            const plPct = playerItem.avgCost > 0 ? Math.round((spreadPerUnit / playerItem.avgCost) * 100) : 0;
            const plSign = plPct >= 0 ? '+' : '';
            const plClass = spreadPerUnit >= 0 ? 'positive' : 'negative';
            const plIcon = spreadPerUnit >= 0 ? '▲' : '▼';
            plIndicatorHtml = `<div class="indicator-pill ${plClass}"> P/L: ${plSign}${plPct}%</div>`;
        }
    }

    return `${marketIndicatorHtml}${plIndicatorHtml}`;
}
--- END OF FILE: ./js/utils.js ---

--- START OF FILE: ./js/effects/SystemSurgeEffect.js ---
// js/effects/SystemSurgeEffect.js
import { BaseEffect } from './BaseEffect.js';

/**
 * @fileoverview Defines the SystemSurgeEffect class, a full-screen celebration effect.
 */

export class SystemSurgeEffect extends BaseEffect {

    /**
     * @constructor
     * @param {object} options - Configuration for the effect.
     * @param {string} [options.text='SYSTEM SURGE'] - The text to display, overrides profile default.
     * @param {string} [options.theme='blue'] - The color theme, determines the profile to use.
     */
    constructor(options = {}) {
        super(options);

        const theme = options.theme || 'blue';
        const profile = SystemSurgeEffect.PROFILES[theme] || SystemSurgeEffect.PROFILES.blue;

        // Combine the profile defaults with any specific overrides from the options.
        this.options = {
            ...profile,
            ...options, // Any options passed in will override the profile defaults.
            theme: theme // Ensure the theme is correctly set.
        };

        this.domElements = {};
        this.themes = {
            gold: { color: 'rgba(255, 223, 0, 0.8)', glow: '#ffd700' },
            green: { color: 'rgba(50, 255, 150, 0.8)', glow: '#32ff96' },
            red: { color: 'rgba(255, 50, 50, 0.8)', glow: '#ff3232' },
            blue: { color: 'rgba(50, 150, 255, 0.8)', glow: '#3296ff' },
            orange: { color: 'rgba(255, 165, 0, 0.8)', glow: '#ffa500' },
            purple: { color: 'rgba(220, 50, 255, 0.8)', glow: '#dc32ff' },
            silver: { color: 'rgba(192, 192, 192, 0.9)', glow: '#c0c0c0' },
            tan: { color: 'rgba(210, 180, 140, 0.9)', glow: '#d2b48c' }
        };
    }

    /**
     * @method play
     * @override
     * @description Runs the entire System Surge effect from creation to cleanup.
     * @returns {Promise<void>} A promise that resolves when the effect is finished.
     */
    async play() {
        return new Promise(resolve => {
            this._injectCSS();
            this._createDOM();

            const onsetDuration = this.options.fadeInTime;
            const holdDuration = this.options.lingerTime;
            const fadeDuration = this.options.fadeOutTime;

            setTimeout(() => {
                document.body.classList.add('system-surge-active');
            }, 50);

            setTimeout(() => {
                document.body.classList.remove('system-surge-active');
                document.body.classList.add('system-surge-fading');
            }, onsetDuration + holdDuration);

            setTimeout(() => {
                this._cleanup();
                resolve();
            }, onsetDuration + holdDuration + fadeDuration);
        });
    }

    /**
     * @method _createDOM
     * @protected
     * @override
     * @description Creates the DOM elements for the System Surge effect.
     */
    _createDOM() {
        const themeColors = this.themes[this.options.theme] || this.themes.blue;

        const overlay = document.createElement('div');
        overlay.id = 'celebration-overlay';
        overlay.style.setProperty('--surge-color', themeColors.color);
        overlay.style.setProperty('--surge-glow', themeColors.glow);
        overlay.style.setProperty('--particle-travel-distance', `${this.options.travelDistance}vh`);
        this.domElements.overlay = overlay;

        const surgeLight = document.createElement('div');
        surgeLight.className = 'surge-light';
        this.domElements.surgeLight = surgeLight;

        const surgeText = document.createElement('div');
        surgeText.className = 'surge-text';
        surgeText.textContent = this.options.text;
        surgeText.style.fontSize = this.options.textSize;
        this.domElements.surgeText = surgeText;

        overlay.appendChild(surgeLight);
        overlay.appendChild(surgeText);
        this._createParticles(this.options.particleCount);

        document.body.appendChild(overlay);
    }
    
    /**
     * @method _createParticles
     * @private
     * @description Creates and animates a specified number of particle elements.
     * @param {number} count - The number of particles to create.
     */
    _createParticles(count) {
        for (let i = 0; i < count; i++) {
            const particle = document.createElement('div');
            particle.className = `particle particle-shape-${this.options.particleShape}`;
            
            const size = Math.random() * (this.options.particleSize.max - this.options.particleSize.min) + this.options.particleSize.min;
            const speed = Math.random() * (this.options.particleSpeed.max - this.options.particleSpeed.min) + this.options.particleSpeed.min;
            
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.left = `${Math.random() * 100}%`;
            particle.style.animationDelay = `${Math.random() * 1.5}s`;
            particle.style.animationDuration = `${speed}s`;
            this.domElements.overlay.appendChild(particle);
        }
    }

    /**
     * @method _injectCSS
     * @protected
     * @override
     * @description Injects the CSS required for the System Surge effect into the document head.
     */
    _injectCSS() {
        const style = document.createElement('style');
        style.id = 'system-surge-styles';
        style.textContent = SystemSurgeEffect.css;
        document.head.appendChild(style);
        this.domElements.style = style;
    }

    /**
     * @method _cleanup
     * @protected
     * @override
     * @description Removes all DOM elements, styles, and body classes added by the effect.
     */
    _cleanup() {
        document.body.classList.remove('system-surge-active', 'system-surge-fading');
        Object.values(this.domElements).forEach(element => element && element.remove());
    }

    /**
     * @property {Object} PROFILES
     * @static
     * @description Static property containing the default parameter profiles for each theme.
     */
    static PROFILES = {
        tan: {
            text: 'LICENSE ACQUIRED',
            textSize: '8vw', particleCount: 74, particleShape: 'sliver',
            particleSize: { min: 1, max: 11 }, particleSpeed: { min: 1, max: 7.5 },
            travelDistance: 110, fadeInTime: 1900, lingerTime: 3150, fadeOutTime: 5000
        },
        silver: {
            text: 'SHIP PURCHASED',
            textSize: '8vw', particleCount: 90, particleShape: 'sliver',
            particleSize: { min: 1, max: 3 }, particleSpeed: { min: 1, max: 4 },
            travelDistance: 100, fadeInTime: 500, lingerTime: 3050, fadeOutTime: 3500
        },
        purple: {
            text: 'WEALTH MILESTONE',
            textSize: '8vw', particleCount: 18, particleShape: 'rectangle',
            particleSize: { min: 1, max: 9 }, particleSpeed: { min: 1.5, max: 4 },
            travelDistance: 100, fadeInTime: 500, lingerTime: 3050, fadeOutTime: 3500
        },
        orange: {
            text: 'ORANGE',
            textSize: '8vw', particleCount: 96, particleShape: 'sliver',
            particleSize: { min: 1, max: 6 }, particleSpeed: { min: 2.5, max: 8.5 },
            travelDistance: 120, fadeInTime: 1750, lingerTime: 3750, fadeOutTime: 3500
        },
        blue: {
            text: 'HAPPY BIRTHDAY',
            textSize: '8vw', particleCount: 50, particleShape: 'circle',
            particleSize: { min: 7, max: 20 }, particleSpeed: { min: 5, max: 8.5 },
            travelDistance: 120, fadeInTime: 1750, lingerTime: 3750, fadeOutTime: 3500
        },
        red: {
            text: 'TOP CLASS',
            textSize: '8vw', particleCount: 115, particleShape: 'rectangle',
            particleSize: { min: 5, max: 6 }, particleSpeed: { min: 1, max: 5.5 },
            travelDistance: 120, fadeInTime: 1750, lingerTime: 3000, fadeOutTime: 5000
        },
        green: {
            text: 'WEALTH MILESTONE',
            textSize: '8vw', particleCount: 200, particleShape: 'sliver',
            particleSize: { min: 1, max: 20 }, particleSpeed: { min: 1, max: 4 },
            travelDistance: 50, fadeInTime: 1750, lingerTime: 3000, fadeOutTime: 5000
        },
        gold: {
            text: 'MISSION COMPLETE',
            textSize: '8vw', particleCount: 62, particleShape: 'circle',
            particleSize: { min: 3, max: 18 }, particleSpeed: { min: 2.5, max: 12 },
            travelDistance: 115, fadeInTime: 1750, lingerTime: 1900, fadeOutTime: 5000
        }
    };

    /**
     * @property {string} css
     * @static
     * @description Static property containing all CSS for this effect.
     */
    static css = `
        #celebration-overlay {
            --surge-color: #00ffff;
            --surge-glow: #00ffff;
            --particle-travel-distance: 105vh;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            opacity: 0;
        }

        .system-surge-active #celebration-overlay {
            opacity: 1;
            transition: opacity 0.2s ease-in;
        }
        .system-surge-fading #celebration-overlay {
            opacity: 0;
            transition: opacity 3s ease-out;
        }

        .surge-light {
            position: absolute;
            bottom: -100%;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to top, var(--surge-color), transparent 60%);
            opacity: 0.6;
            transition: all 2.9s ease-out;
        }
        .system-surge-active .surge-light {
            bottom: 0;
            opacity: 0.6;
            transition-delay: 0.2s;
        }

        .surge-text {
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 0 10px #fff, 0 0 25px var(--surge-glow), 0 0 50px var(--surge-glow);
            transform: scale(0.5);
            opacity: 0;
            transition: all 1.15s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }
        .system-surge-active .surge-text {
            transform: scale(1);
            opacity: 1;
            transition-delay: 0.4s;
        }

        .particle {
            position: absolute;
            bottom: -20px;
            background-color: var(--surge-color);
            opacity: 0;
            animation: system-surge-rise 8s ease-in forwards;
            box-shadow: 0 0 8px var(--surge-color);
        }

        .particle-shape-circle {
            border-radius: 50%;
        }
        .particle-shape-star {
            background-color: transparent;
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            border: 1px solid var(--surge-color);
        }
        .particle-shape-sliver {
            width: 2px !important;
            height: 20px !important;
            border-radius: 2px;
        }
        .particle-shape-rectangle {
            height: 12px !important;
            width: 4px !important;
        }

        @keyframes system-surge-rise {
            0% { transform: translateY(0); opacity: 0.9; }
            100% { transform: translateY(calc(-1 * var(--particle-travel-distance))); opacity: 0; }
        }
    `;
}
--- END OF FILE: ./js/effects/SystemSurgeEffect.js ---

--- START OF FILE: ./js/effects/BaseEffect.js ---
/**
 * @fileoverview Defines the BaseEffect class, an abstract blueprint for all visual effects.
 * This class should not be instantiated directly. Instead, specific effect classes
 * should extend it and implement its methods.
 */

export class BaseEffect {
    /**
     * @JSDoc
     * @constructor
     * @param {object} options - Configuration for the effect, passed from the trigger.
     */
    constructor(options) {
        this.options = options;
    }

    /**
     * @JSDoc
     * @method play
     * @description The main entry point for the effect. The EffectsManager calls this method.
     * It is responsible for the entire lifecycle of the effect (setup, animation, cleanup).
     * Subclasses MUST implement this method.
     * @returns {Promise<void>} A promise that resolves when the effect is completely finished.
     */
    async play() {
        throw new Error("Effects must implement the 'play' method.");
    }

    /**
     * @JSDoc
     * @method _createDOM
     * @protected
     * @description Creates the necessary DOM elements for the effect and appends them to the document.
     * Subclasses should implement this to build their specific HTML structure.
     */
    _createDOM() {
        // To be implemented by subclasses
    }

    /**
     * @JSDoc
     * @method _injectCSS
     * @protected
     * @description Injects the effect-specific CSS into the document's head.
     * Subclasses should implement this to provide their styling.
     */
    _injectCSS() {
        // To be implemented by subclasses
    }

    /**
     * @JSDoc
     * @method _cleanup
     * @protected
     * @description Removes all DOM elements and CSS created by the effect.
     * This method is crucial for leaving the DOM in a clean state.
     */
    _cleanup() {
        // To be implemented by subclasses
    }
}
--- END OF FILE: ./js/effects/BaseEffect.js ---

--- START OF FILE: ./js/effects/EffectsManager.js ---
/**
 * @fileoverview Defines the EffectsManager, a controller for queueing and playing visual effects.
 */

export class EffectsManager {
    /**
     * @JSDoc
     * @constructor
     */
    constructor() {
        /** @private @type {Array<object>} */
        this.effectQueue = [];
        /** @private @type {boolean} */
        this.isEffectActive = false;
        /** @private @type {Object<string, typeof BaseEffect>} */
        this.effectsRegistry = {};
    }

    /**
     * @JSDoc
     * @method registerEffect
     * @description Adds an effect class to the registry, making it available to be triggered.
     * @param {string} name - The unique name to identify the effect (e.g., 'systemSurge').
     * @param {typeof BaseEffect} effectClass - The class definition for the effect, which must extend BaseEffect.
     */
    registerEffect(name, effectClass) {
        this.effectsRegistry[name] = effectClass;
    }

    /**
     * @JSDoc
     * @method trigger
     * @description Adds an effect request to the queue and starts processing.
     * @param {string} effectName - The name of the effect to trigger, must match a registered effect.
     * @param {object} options - The configuration object to pass to the effect's constructor.
     */
    trigger(effectName, options) {
        this.effectQueue.push({ effectName, options });
        this._processQueue();
    }

    /**
     * @JSDoc
     * @method _processQueue
     * @private
     * @async
     * @description Processes the effect queue sequentially. It takes the next effect from the queue,
     * plays it, and waits for it to complete before starting the next one.
     */
    async _processQueue() {
        if (this.isEffectActive || this.effectQueue.length === 0) {
            return;
        }

        this.isEffectActive = true;
        const request = this.effectQueue.shift();
        const EffectClass = this.effectsRegistry[request.effectName];

        if (!EffectClass) {
            console.warn(`EffectManager: Attempted to trigger unregistered effect '${request.effectName}'.`);
            this.isEffectActive = false;
            this._processQueue(); // Process next item
            return;
        }

        try {
            const effect = new EffectClass(request.options);
            await effect.play();
        } catch (error) {
            console.error(`Error playing effect '${request.effectName}':`, error);
        } finally {
            this.isEffectActive = false;
            // Check for more effects that may have been added during playback
            this._processQueue();
        }
    }
}
--- END OF FILE: ./js/effects/EffectsManager.js ---

--- START OF FILE: ./js/data/constants.js ---
// js/data/constants.js
/**
 * @fileoverview This file contains centralized constant values and enumerations used throughout the game.
 * Consolidating these values here makes the codebase easier to manage, read, and modify, as it provides
 * a single source of truth for frequently used identifiers and game balance numbers.
 */

/**
 * Unique identifiers for each primary screen in the game's UI.
 * @enum {string}
 */
export const SCREEN_IDS = Object.freeze({
    STATUS: 'status',
    NAVIGATION: 'navigation',
    SERVICES: 'services',
    MARKET: 'market',
    CARGO: 'cargo',
    HANGAR: 'hangar',
    MISSIONS: 'missions',
    FINANCE: 'finance',
    INTEL: 'intel',
});

/**
 * Unique identifiers for the main navigation tabs.
 * @enum {string}
 */
export const NAV_IDS = Object.freeze({
    SHIP: 'ship',
    STARPORT: 'starport',
    DATA: 'data',
});

/**
 * Unique identifiers for each type of ship available in the game.
 * @enum {string}
 */
export const SHIP_IDS = Object.freeze({
    WANDERER: 'starter',
    STALWART: 'hauler_c1',
    MULE: 'hauler_c2',
    PATHFINDER: 'explorer_b1',
    NOMAD: 'explorer_b2',
    VINDICATOR: 'frigate_a1',
    AEGIS: 'frigate_a2',
    ODYSSEY: 'luxury_s1',
    MAJESTIC: 'luxury_s2',
    TITAN_HAULER: 'rare_s1',
    VOID_CHASER: 'rare_s2',
    GUARDIAN: 'rare_s3',
    STARGAZER: 'rare_s4',
    BEHEMOTH: 'rare_o1',
});

/**
 * Unique identifiers for each type of commodity that can be traded.
 * @enum {string}
 */
export const COMMODITY_IDS = Object.freeze({
    WATER_ICE: 'water_ice',
    PLASTEEL: 'plasteel',
    HYDROPONICS: 'hydroponics',
    CYBERNETICS: 'cybernetics',
    PROPELLANT: 'propellant',
    PROCESSORS: 'processors',
    GMO_SEEDS: 'gmo_seeds',
    CRYO_PODS: 'cryo_pods',
    ATMO_PROCESSORS: 'atmos_processors',
    CLONED_ORGANS: 'cloned_organs',
    XENO_GEOLOGICALS: 'xeno_geologicals',
    SENTIENT_AI: 'sentient_ai',
    ANTIMATTER: 'antimatter',
    FOLDED_DRIVES: 'folded_drives',
});

/**
 * Unique identifiers for each travel destination (market location).
 * @enum {string}
 */
export const LOCATION_IDS = Object.freeze({
    EARTH: 'loc_earth',
    LUNA: 'loc_luna',
    MARS: 'loc_mars',
    VENUS: 'loc_venus',
    BELT: 'loc_belt',
    SATURN: 'loc_saturn',
    JUPITER: 'loc_jupiter',
    URANUS: 'loc_uranus',
    NEPTUNE: 'loc_neptune',
    PLUTO: 'loc_pluto',
    EXCHANGE: 'loc_exchange',
    KEPLER: 'loc_kepler',
});

/**
 * Unique identifiers for player perks, which provide passive bonuses.
 * @enum {string}
 */
export const PERK_IDS = Object.freeze({
    TRADEMASTER: 'trademaster',
    NAVIGATOR: 'navigator',
    VENETIAN_SYNDICATE: 'venetian_syndicate',
    MERCHANT_GUILD_SHIP: 'merchant_guild_ship',
});

/**
 * Unique identifiers for actions triggered by user interaction with UI elements.
 * These are typically assigned to `data-action` attributes in the HTML.
 * @enum {string}
 */
export const ACTION_IDS = Object.freeze({
    SET_SCREEN: 'set-screen',
    TRAVEL: 'travel',
    BUY_SHIP: 'buy-ship',
    SELL_SHIP: 'sell-ship',
    SELECT_SHIP: 'select-ship',
    PAY_DEBT: 'pay-debt',
    TAKE_LOAN: 'take-loan',
    PURCHASE_INTEL: 'purchase-intel',
    ACQUIRE_LICENSE: 'acquire-license',
    BUY_ITEM: 'buy-item',
    SELL_ITEM: 'sell-item',
    SET_MAX_BUY: 'set-max-buy',
    SET_MAX_SELL: 'set-max-sell',
    INCREMENT: 'increment',
    DECREMENT: 'decrement',
    SHOW_PRICE_GRAPH: 'show-price-graph',
    SHOW_FINANCE_GRAPH: 'show-finance-graph',
    TOGGLE_MARKET_CARD_VIEW: 'toggle-market-card-view',
    TOGGLE_HANGAR_MODE: 'toggle-hangar-mode',
    SET_HANGAR_PAGE: 'set-hangar-page',
});

/**
 * Defines the types of conditions that can trigger or complete a tutorial step.
 * @enum {string}
 */
export const TUTORIAL_ACTION_TYPES = Object.freeze({
    SCREEN_LOAD: 'SCREEN_LOAD', // Triggered when a specific screen is loaded.
    ACTION: 'ACTION',           // Triggered by a specific user action (e.g., buying a ship).
    INFO: 'INFO',               // A purely informational step, completed by clicking "Next".
});

/**
 * A collection of core game balance numbers and rules.
 * @property {number} STARTING_CREDITS - The amount of credits the player starts with.
 * @property {number} STARTING_DEBT_INTEREST - The initial monthly interest on the starting debt.
 * @property {number} REPAIR_COST_PER_HP - The credit cost to repair one point of hull damage.
 * @property {number} REPAIR_AMOUNT_PER_TICK - The percentage of max hull repaired per service tick.
 * @property {number} FUEL_SCALAR - A base multiplier used in travel fuel cost calculations.
 * @property {number} INTEREST_INTERVAL - The number of days between interest charges on debt.
 * @property {number} PASSIVE_REPAIR_RATE - The percentage of max hull repaired per day on inactive ships.
 * @property {number} HULL_DECAY_PER_TRAVEL_DAY - The amount of flat hull damage taken per day of travel.
 * @property {number} SHIP_SELL_MODIFIER - The percentage of a ship's base price received when sold.
 * @property {number} RARE_SHIP_CHANCE - The probability (0-1) of a rare ship appearing in the shipyard stock.
 * @property {number} PRICE_HISTORY_LENGTH - The maximum number of daily price entries to store for graphs.
 * @property {number} FINANCE_HISTORY_LENGTH - The maximum number of transactions to display in the finance log.
 * @property {number} DAILY_PRICE_VOLATILITY - The maximum percentage a price can fluctuate daily.
 * @property {number} MEAN_REVERSION_STRENGTH - The strength of the tendency for prices to return to their galactic average.
 * @property {number} MARKET_PRESSURE_DECAY - The weekly decay factor for market pressure (e.g., 0.85 means 15% decay).
 * @property {number} LOAN_GARNISHMENT_DAYS - The number of days after taking a loan before wage garnishment can begin.
 * @property {number} LOAN_GARNISHMENT_PERCENT - The percentage of player credits garnished if their loan is delinquent.
 * @property {number} RANDOM_EVENT_CHANCE - The probability (0-1) of a random event occurring during travel.
 */
export const GAME_RULES = Object.freeze({
    STARTING_CREDITS: 5000,
    STARTING_DEBT_INTEREST: 125,
    REPAIR_COST_PER_HP: 75,
    REPAIR_AMOUNT_PER_TICK: 5,
    FUEL_SCALAR: 3,
    INTEREST_INTERVAL: 30,
    PASSIVE_REPAIR_RATE: 0.02,
    HULL_DECAY_PER_TRAVEL_DAY: 1 / 7,
    SHIP_SELL_MODIFIER: 0.75,
    RARE_SHIP_CHANCE: 0.3,
    PRICE_HISTORY_LENGTH: 65,
    FINANCE_HISTORY_LENGTH: 10,
    DAILY_PRICE_VOLATILITY: 0.15,
    MEAN_REVERSION_STRENGTH: 0.07,
    MARKET_PRESSURE_DECAY: 0.70,
    LOAN_GARNISHMENT_DAYS: 1095,
    LOAN_GARNISHMENT_PERCENT: 0.14,
    RANDOM_EVENT_CHANCE: 0.07,
});

/**
 * Defines the wealth milestones that trigger the reveal of new commodity tiers.
 */
export const WEALTH_MILESTONES = [
    { threshold: 50000, revealsTier: 2 },
    { threshold: 450000, revealsTier: 3 },
    { threshold: 4000000, revealsTier: 4 },
    { threshold: 35000000, revealsTier: 5 },
    { threshold: 300000000, revealsTier: 6 },
    { threshold: 2500000000, revealsTier: 7 }
];

/**
 * Defines rules for how player transactions impact local market prices.
 */
export const MARKET_IMPACT_RULES = {
    SENSITIVITY: 0.1, // Base multiplier for how much a transaction affects price
    MAX_IMPACT: 0.25, // Maximum percentage a single transaction can shift the price
    TIER_THRESHOLD: 4 // Only goods of this tier and above cause an impact
};


/**
 * The key used to store and retrieve the game state from the browser's localStorage.
 * @type {string}
 */
export const SAVE_KEY = 'orbitalTraderSave_v2';
--- END OF FILE: ./js/data/constants.js ---

--- START OF FILE: ./js/data/database.js ---
// js/data/database.js
/**
 * @fileoverview
 * This file serves as the central database for all static game data.
 * It consolidates information from previous data, config, and content files
 * into a single, authoritative source. This improves maintainability and clarity
 * by providing a unified structure for all core game content and configuration.
 */
import { LOCATION_IDS, PERK_IDS, SHIP_IDS, COMMODITY_IDS, SCREEN_IDS, TUTORIAL_ACTION_TYPES, ACTION_IDS, NAV_IDS } from './constants.js';

// --- In-Game Date Configuration ---
export const DATE_CONFIG = {
    START_YEAR: 2140,
    START_DAY_OF_WEEK: 1, // 0 = Sunday, 1 = Monday, etc.
    DAYS_IN_MONTH: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    MONTH_NAMES: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    DAY_NAMES: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};

export const SYSTEM_STATES = {
    'NEUTRAL': {
        name: 'Neutral System',
        duration: 28,
        description: "Standard space-faring conditions. Markets are operating under normal parameters.",
        modifiers: {} // No economic deviations
    },
    /* // Example of a disruptive economic state. More can be added here.
    'CORPORATE_WAR': {
        name: 'Corporate War',
        duration: 28,
        description: "Rival corporations have escalated to open conflict, creating high demand for military-grade materials. The Plasteel and Cybernetics markets are in turmoil.",
        modifiers: {
            commodity: {
                'cybernetics': {
                    availability: 0.6,
                    price: 1.4,
                    volatility_mult: 2.5,
                    mean_reversion_mult: 0.3
                },
                'plasteel': {
                    availability: 0.7,
                    price: 1.3,
                    volatility_mult: 2.0,
                    mean_reversion_mult: 0.5
                }
            }
        }
    }
    */
};

export const DB = {
    // --- Core Game Configuration ---
    CONFIG: {
        INTEL_COST_PERCENTAGE: 0.20,
        INTEL_MIN_CREDITS: 5000,
        INTEL_CHANCE: 0.3,
        INTEL_DEMAND_MOD: 1.8,
        INTEL_DEPRESSION_MOD: 0.5,
    },

    SYSTEM_STATES: SYSTEM_STATES,

    DATE_CONFIG: DATE_CONFIG,

    // --- New Game Introduction Sequence ---
    INTRO_SEQUENCE_V1: {
      modals: [
        {
          id: 'lore_1',
          title: 'Year 2140',
          description: "Humanity has expanded throughout the Solar System.<br><br> <span class=\"hl\">Commerce</span> has thrived among the numerous colonies and stations longer than living memory.",
          buttonText: 'Begin',
          contentClass: 'text-center'
        },
        {
          id: 'lore_2',
          title: "The Price of Freedom",
          description: "A dead-end job in the Belt pays the bills, but it does not offer the <b class='hl-green font-bold'>prosperity</b> that you dream of.<br><br>The <span class='hl'>Merchant's Guild</span> will fund your ambition, but their price is steep.<br><br>This is no simple loan; it's a bet on yourself and your future.",
          buttonText: 'Apply for Loan',
          contentClass: 'text-center',
          buttonClass: 'btn-pulse-green'
        },
        {
          id: 'charter',
          title: "<span class=\"hl\">MERCHANT'S GUILD LOAN AGREEMENT</span>",
          description: `
            <div class="font-roboto-mono text-left text-sm space-y-2">
                <p><span class="text-gray-400">CHARTER ID:</span> G7-K491-38B</p>
                <p><span class="text-gray-400">CREDIT AMOUNT:</span> <span class="credits-text-pulsing">⌬ 25,000</span></p>
                <p><span class="text-gray-400">INTEREST RATE:</span> 1.56% (Monthly)</p>
            </div>
            <div class="border-t border-slate-600 my-4"></div>
            <p class="text-sm text-gray-400 text-justify">Herein, the Applicant agrees to the terms of repayment and interest accrual, subject to the Interstellar Commerce Mandates of the Merchant's Guild. This binding digital agreement is logged on the system-wide ledger, whereupon it is considered immutable and enforceable system-wide. The principal of the debt is due in 1095 Terran-standard days, after which failure to remit payment shall authorize the automatic initiation of a garnishment sub-routine against the Applicant's credit.</p>
          `,
          buttonText: 'Accept Terms',
          buttonClass: 'btn-pulse-gold'
        },
        {
          id: 'signature',
          title: 'SIGN YOUR NAME',
          description: `
            <p class="text-sm text-gray-400 text-justify mb-4">I, the undersigned, do hereby accept the aforementioned terms and enter into this agreement with the Merchant's Guild. My signature, digitally rendered, shall serve as my legal mark.</p>
          `,
          buttonText: 'Submit Application'
        },
        {
            id: 'final',
            title: 'Low On Credits!',
            description: "Interest on your debt grows every month. It's time to make some <b class='hl-yellow font-bold'>credits</b>. Let's view the <b>Mission Terminal</b> here on <b>Mars</b>!",
            buttonText: 'View Missions'
        }
      ]
    },

    // --- Visual Representations for Locations ---
    LOCATION_VISUALS: {
        [LOCATION_IDS.EARTH]: '🌍',
        [LOCATION_IDS.LUNA]: '🌕',
        [LOCATION_IDS.MARS]: '🔴',
        [LOCATION_IDS.VENUS]: '🟡',
        [LOCATION_IDS.BELT]: '🪨',
        [LOCATION_IDS.SATURN]: '🪐',
        [LOCATION_IDS.JUPITER]: '🟠',
        [LOCATION_IDS.URANUS]: '🔵',
        [LOCATION_IDS.NEPTUNE]: '🟣',
        [LOCATION_IDS.PLUTO]: '🪩',
        [LOCATION_IDS.EXCHANGE]: '🏴‍☠️',
        [LOCATION_IDS.KEPLER]: '👁️'
    },

    // --- Player Perks and Their Effects ---
    PERKS: {
        [PERK_IDS.TRADEMASTER]: { profitBonus: 0.05 },
        [PERK_IDS.NAVIGATOR]: { fuelMod: 0.9, hullDecayMod: 0.9, travelTimeMod: 0.9 },
        [PERK_IDS.VENETIAN_SYNDICATE]: { fuelDiscount: 0.25, repairDiscount: 0.25 }
    },

    // --- Narrative Events Triggered by Game Progression ---
    AGE_EVENTS: [
        {
            id: 'captain_choice',
            trigger: { day: 366 }, // Triggers after one full year of gameplay.
            title: 'Captain Who?',
            description: "You've successfully navigated many trades and run a tight ship. Your crew depends on you... but what kind of captain will you be?",
            choices: [
                { title: 'Trademaster', description: '5% bonus on all trade profits.', perkId: PERK_IDS.TRADEMASTER, playerTitle: 'Trademaster' },
                { title: 'Navigator', description: '10% reduced fuel usage, hull decay, and travel time.', perkId: PERK_IDS.NAVIGATOR, playerTitle: 'Navigator' }
            ]
        },
        {
            id: 'friends_with_benefits',
            trigger: { credits: 50000 }, // Triggers upon reaching 50,000 credits.
            title: 'Friends with Benefits',
            description: 'An ally in need is an ally indeed.',
            choices: [
                { title: "Join the Merchant's Guild", description: 'Receive a free C-Class freighter.', perkId: PERK_IDS.MERCHANT_GUILD_SHIP },
                { title: 'Join the Venetian Syndicate', description: '75% discount on fuel and repairs at Venus.', perkId: PERK_IDS.VENETIAN_SYNDICATE }
            ]
        }
    ],

    // --- Random Events Encountered During Travel ---
    RANDOM_EVENTS: [
        {
            id: 'distress_call',
            title: 'Distress Call',
            scenario: 'You pick up a distress signal from a small, damaged ship. They are out of fuel and requesting an emergency transfer to restart their reactor.',
            precondition: (gameState, activeShip) => activeShip.fuel >= 20, // Event can only trigger if player has enough fuel to offer.
            choices: [
                {
                    title: 'Offer Aid (20 Fuel)',
                    outcomes: [
                        {
                            chance: 0.75,
                            description: 'The fuel transfer is successful. The grateful captain rewards you with 10,000 credits for your timely assistance.',
                            effects: [ { type: 'fuel', value: -20 }, { type: 'credits', value: 10000 } ]
                        },
                        {
                            chance: 0.25,
                            description: 'As the fuel transfer begins, their reactor overloads! The resulting explosion damages your hull by 15%.',
                            effects: [ { type: 'fuel', value: -20 }, { type: 'hull_damage_percent', value: 15 } ]
                        }
                    ]
                },
                {
                    title: 'Ignore the Call',
                    outcomes: [ { chance: 1.0, description: 'You press on, and the desperate signal fades behind you.', effects: [] } ]
                }
            ]
        },
        {
            id: 'floating_cargo',
            title: 'Floating Cargo Pod',
            scenario: 'Long-range sensors detect an unmarked, sealed cargo pod adrift in the shipping lane. It appears to be intact.',
            precondition: () => true,
            choices: [
                {
                    title: 'Bring it Aboard',
                    outcomes: [
                        {
                            chance: 0.60,
                            description: `The pod contains valuable goods. You gain 25 units of Neural Processors.`,
                            effects: [ { type: 'add_cargo', value: { id: COMMODITY_IDS.PROCESSORS, quantity: 25 } } ]
                        },
                        {
                            chance: 0.40,
                            description: 'It was a trap! The pod is booby-trapped and detonates as your tractor beam locks on, causing 20% hull damage.',
                            effects: [ { type: 'hull_damage_percent', value: 20 } ]
                        }
                    ]
                },
                {
                    title: 'Report it',
                    outcomes: [ { chance: 1.0, description: 'You notify the nearest station of the hazard and receive a small finder\'s fee of 1,000 credits.', effects: [ { type: 'credits', value: 1000 } ] } ]
                }
            ]
        },
        {
            id: 'adrift_passenger',
            title: 'Adrift Passenger',
            scenario: 'You find a spacer in a functioning escape pod. Their beacon is down, and they ask for passage to the nearest civilized port.',
            precondition: (gameState, activeShip) => activeShip.fuel >= 30,
            choices: [
                {
                    title: 'Take Aboard for Payment',
                    outcomes: [ { chance: 1.0, description: 'The passenger is grateful for the rescue and pays you 10,000 credits upon arrival at your destination.', effects: [ { type: 'credits', value: 10000 } ] } ]
                },
                {
                    title: 'Give a Fuel Cell (30 Fuel)',
                    outcomes: [
                        {
                            chance: 1.0,
                            descriptions: {
                                'reward_cybernetics': `In gratitude, the passenger gives you a crate of <span class="hl-green">40 Cybernetics</span>.`,
                                'reward_debt_paid': `Seeing your tight cargo, the passenger pays off 20% of your debt, reducing it by <span class="hl-green">{amount}</span>.`,
                                'reward_credits': `With no room and no debt, the passenger transfers you <span class="hl-green">{amount}</span>.`
                            },
                            effects: [ { type: 'ADRIFT_PASSENGER' } ]
                        }
                    ]
                }
            ]
        },
        {
            id: 'meteoroid_swarm',
            title: 'Micrometeoroid Swarm',
            scenario: 'Alarms blare as you fly into an uncharted micrometeoroid swarm. Your navigation computer suggests two options to minimize damage.',
            precondition: (gameState, activeShip) => activeShip.fuel >= 15,
            choices: [
                {
                    title: 'Evade Aggressively (+15 Fuel)',
                    outcomes: [ { chance: 1.0, description: 'You burn extra fuel to successfully dodge the worst of the swarm, emerging unscathed.', effects: [ { type: 'fuel', value: -15 } ] } ]
                },
                {
                    title: 'Brace for Impact',
                    outcomes: [ { chance: 1.0, description: 'You trust your hull to withstand the impacts, taking a beating but saving fuel.', effects: [ { type: 'hull_damage_percent', value: [10, 25] } ] } ]
                }
            ]
        },
        {
            id: 'engine_malfunction',
            title: 'Engine Malfunction',
            scenario: 'A sickening shudder runs through the ship. A key plasma injector has failed, destabilizing your engine output.',
            precondition: (gameState, activeShip, getActiveInventory) => (getActiveInventory()[COMMODITY_IDS.PLASTEEL]?.quantity || 0) >= 5,
            choices: [
                {
                    title: 'Quick, Risky Fix (5 Plasteel)',
                    outcomes: [
                        {
                            chance: 0.50,
                            description: 'The patch holds! The engine stabilizes and you continue your journey without further incident.',
                            effects: [ { type: 'lose_cargo', value: { id: COMMODITY_IDS.PLASTEEL, quantity: 5 } } ]
                        },
                        {
                            chance: 0.50,
                            description: 'The patch fails catastrophically, causing a small explosion that deals 20% hull damage.',
                            effects: [ { type: 'lose_cargo', value: { id: COMMODITY_IDS.PLASTEEL, quantity: 5 } }, { type: 'hull_damage_percent', value: 20 } ]
                        }
                    ]
                },
                {
                    title: 'Limp to Destination',
                    outcomes: [ { chance: 1.0, description: 'You shut down the faulty injector. The ship is slower, but stable. Your remaining travel time increases by 25%.', effects: [ { type: 'travel_time_add_percent', value: 0.25 } ] } ]
                }
            ]
        },
        {
            id: 'nav_glitch',
            title: 'Navigation Sensor Glitch',
            scenario: 'The nav-console flashes red. Your primary positioning sensors are offline, and you\'re flying blind in the deep dark.',
            precondition: () => true,
            choices: [
                {
                    title: 'Attempt Hard Reboot',
                    outcomes: [
                        {
                            chance: 0.50,
                            description: 'Success! The sensors come back online. In your haste, you find a shortcut, shortening your trip. You will arrive the next day.',
                            effects: [ { type: 'set_travel_time', value: 1 } ]
                        },
                        {
                            chance: 0.50,
                            description: 'The reboot corrupts your course data, sending you on a long, meandering path. This adds 15 days to your journey.',
                            effects: [ { type: 'travel_time_add', value: 15 } ]
                        }
                    ]
                },
                {
                    title: 'Navigate Manually',
                    outcomes: [ { chance: 1.0, description: 'You rely on old-fashioned star charts. It\'s slow but safe, adding 7 days to your trip.', effects: [ { type: 'travel_time_add', value: 7 } ] } ]
                }
            ]
        },
        {
            id: 'life_support_fluctuation',
            title: 'Life Support Fluctuation',
            scenario: 'An alarm indicates unstable oxygen levels. It\'s not critical yet, but the crew is on edge and efficiency is dropping.',
            precondition: (gameState, activeShip) => activeShip.health > (activeShip.maxHealth * 0.25),
            choices: [
                {
                    title: 'Salvage materials from the ship to repair the atmospheric regulators. (This will cost 25% hull damage)',
                    outcomes: [ { chance: 1.0, description: 'You cannibalize some non-essential hull plating to get the regulators working again. The system stabilizes, but the ship\'s integrity is compromised.', effects: [ { type: 'hull_damage_percent', value: 25 } ] } ]
                },
                {
                    title: 'Defer Maintenance Costs',
                    outcomes: [ { chance: 1.0, description: 'You log the issue for later. The cost of repairs and crew hazard pay, 5,000 credits, is added to your debt.', effects: [ { type: 'add_debt', value: 5000 } ] } ]
                }
            ]
        },
        {
            id: 'cargo_rupture',
            title: 'Cargo Hold Rupture',
            scenario: 'A micrometeorite has punched a small hole in the cargo bay. One of your cargo stacks is exposed to hard vacuum.',
            precondition: (gameState, activeShip, getActiveInventory) => {
                const inventory = getActiveInventory();
                if (!inventory) return false;
                return Object.values(inventory).some(item => item.quantity > 0);
            },
            choices: [
                {
                    title: 'Jettison Damaged Cargo',
                    outcomes: [ { chance: 1.0, description: 'You vent the damaged section, losing 10% of a random cargo stack from your hold into the void.', effects: [ { type: 'lose_random_cargo_percent', value: 0.10 } ] } ]
                },
                {
                    title: 'Attempt EVA Repair',
                    outcomes: [
                        {
                            chance: 0.75,
                            description: 'The emergency patch holds! The cargo is safe, but the repair adds 2 days to your trip.',
                            effects: [ { type: 'travel_time_add', value: 2 } ]
                        },
                        {
                            chance: 0.25,
                            description: 'The patch fails to hold. Explosive decompression destroys 50% of the cargo stack, and the repair still adds 2 days to your trip.',
                            effects: [ { type: 'lose_random_cargo_percent', value: 0.50 }, { type: 'travel_time_add', value: 2 } ]
                        }
                    ]
                }
            ]
        },
        {
            id: 'space_race',
            title: 'Space Race Wager',
            scenario: 'A smug-looking luxury ship pulls alongside and its captain, broadcasted on your main screen, challenges you to a "friendly" race to the destination.',
            precondition: (gameState) => gameState.player.credits > 100,
            choices: [
                {
                    title: 'Accept Wager (Bet: 80% of current credits)',
                    outcomes: [
                        {
                            chance: 1.0,
                            description: 'You accept the high-stakes challenge...',
                            effects: [ { type: 'SPACE_RACE', wagerPercentage: 0.80, winChance: { 'S': 0.85, 'A': 0.70, 'B': 0.55, 'C': 0.40, 'O': 0.95 } } ]
                        }
                    ]
                },
                {
                    title: 'Politely Decline',
                    outcomes: [ { chance: 1.0, description: 'You decline the race. The luxury ship performs a flashy maneuver and speeds off, leaving you to travel in peace.', effects: [] } ]
                }
            ]
        },
        {
            id: 'supply_drop',
            title: 'Emergency Supply Drop',
            scenario: 'You intercept a system-wide emergency broadcast. A new outpost is offering a massive premium for an immediate delivery of a specific commodity that you happen to be carrying.',
            precondition: (gameState, activeShip, getActiveInventory) => {
                const inventory = getActiveInventory();
                return inventory && Object.values(inventory).some(item => item.quantity > 0);
            },
            choices: [
                {
                    title: 'Divert Course to Deliver',
                    outcomes: [ { chance: 1.0, description: 'You sell your entire stack of the requested commodity for 3 times its galactic average value. Your course is diverted to a new, random destination, adding 7 days to your trip.', effects: [ { type: 'sell_random_cargo_premium', value: 3 }, { type: 'travel_time_add', value: 7 }, { type: 'set_new_random_destination' } ] } ]
                },
                {
                    title: 'Decline and Continue',
                    outcomes: [ { chance: 1.0, description: 'You stick to your original plan and let someone else handle the emergency supply run.', effects: [] } ]
                }
            ]
        }
    ],

    // --- Ship Data ---
    SHIPS: {
        [SHIP_IDS.WANDERER]: { name: 'Wanderer', class: 'C', price: 25000, maxHealth: 100, cargoCapacity: 20, maxFuel: 100, saleLocationId: null, lore: 'The All-Rounder. A reliable, if unspectacular, light freighter. Its balanced stats make it a good choice for new captains finding their niche.' },
        [SHIP_IDS.STALWART]: { name: 'Stalwart', class: 'C', price: 25000, maxHealth: 150, cargoCapacity: 45, maxFuel: 80, saleLocationId: LOCATION_IDS.MARS, lore: 'The Hauler. A workhorse of the inner worlds. Slow and cumbersome, but boasts an impressive cargo capacity for its price point.' },
        [SHIP_IDS.MULE]: { name: 'Mule', class: 'C', price: 25000, maxHealth: 75, cargoCapacity: 30, maxFuel: 150, saleLocationId: LOCATION_IDS.BELT, lore: 'The Explorer. What it lacks in cargo space, it makes up for with surprising efficiency and robust systems, allowing it to travel further and cheaper than other ships in its class.' },
        [SHIP_IDS.PATHFINDER]: { name: 'Pathfinder', class: 'B', price: 180000, maxHealth: 120, cargoCapacity: 40, maxFuel: 150, saleLocationId: LOCATION_IDS.LUNA, lore: 'Built for the long haul. Its extended fuel tanks and robust sensor suite make it ideal for reaching the outer edges of the system.' },
        [SHIP_IDS.NOMAD]: { name: 'Nomad', class: 'B', price: 280000, maxHealth: 100, cargoCapacity: 35, maxFuel: 140, saleLocationId: LOCATION_IDS.URANUS, lore: 'A vessel designed for self-sufficiency, featuring advanced life support and a small onboard workshop for emergency repairs.' },
        [SHIP_IDS.VINDICATOR]: { name: 'Vindicator', class: 'A', price: 750000, maxHealth: 250, cargoCapacity: 80, maxFuel: 120, saleLocationId: LOCATION_IDS.NEPTUNE, lore: 'A decommissioned military frigate. Fast, tough, and intimidating, with cargo space retrofitted where missile launchers used to be.' },
        [SHIP_IDS.AEGIS]: { name: 'Aegis', class: 'A', price: 1200000, maxHealth: 120, cargoCapacity: 70, maxFuel: 140, saleLocationId: LOCATION_IDS.EARTH, lore: 'Built as a high-threat escort vessel, its hull is exceptionally dense. A flying fortress that can also haul a respectable amount of cargo.' },
        [SHIP_IDS.ODYSSEY]: { name: 'Odyssey', class: 'S', price: 3800000, maxHealth: 100, cargoCapacity: 120, maxFuel: 250, saleLocationId: LOCATION_IDS.SATURN, lore: 'The pinnacle of personal transport. Gleaming chrome, whisper-quiet engines, and a cabin that smells of rich Corinthian leather.' },
        [SHIP_IDS.MAJESTIC]: { name: 'Majestic', class: 'S', price: 7200000, maxHealth: 200, cargoCapacity: 160, maxFuel: 250, saleLocationId: LOCATION_IDS.KEPLER, lore: 'A flying palace favored by corporate magnates. Its speed, range, and capacity make it one of the most versatile ships money can buy.' },
        [SHIP_IDS.TITAN_HAULER]: { name: 'Titan Hauler', class: 'S', price: 1800000, maxHealth: 175, cargoCapacity: 300, maxFuel: 75, saleLocationId: LOCATION_IDS.URANUS, isRare: true, lore: 'A relic of a failed colonization effort, this ship is almost entirely a cargo container with an engine strapped to it.' },
        [SHIP_IDS.VOID_CHASER]: { name: 'Void Chaser', class: 'S', price: 3100000, maxHealth: 50, cargoCapacity: 90, maxFuel: 400, saleLocationId: LOCATION_IDS.BELT, isRare: true, lore: 'A heavily modified smuggling vessel. Its paper-thin hull is a small price to pay for its legendary engine and long-range fuel cells.' },
        [SHIP_IDS.GUARDIAN]: { name: 'Guardian', class: 'S', price: 1500000, maxHealth: 400, cargoCapacity: 75, maxFuel: 150, saleLocationId: LOCATION_IDS.EARTH, isRare: true, lore: 'An experimental military prototype with redundant hull plating, designed to withstand extreme punishment.' },
        [SHIP_IDS.STARGAZER]: { name: 'Stargazer', class: 'S', price: 950000, maxHealth: 100, cargoCapacity: 60, maxFuel: 350, saleLocationId: LOCATION_IDS.JUPITER, isRare: true, lore: 'A deep-space exploration vessel with colossal fuel reserves, intended for journeys far beyond the known systems.' },
        [SHIP_IDS.BEHEMOTH]: { name: 'Behemoth', class: 'O', price: 32000000, maxHealth: 600, cargoCapacity: 500, maxFuel: 600, saleLocationId: LOCATION_IDS.EXCHANGE, isRare: true, lore: 'An orbital-class freighter that dwarfs even the largest stations. It is a legend among traders, rumored to be a mobile black market in its own right.' }
    },

    // --- Tradable Commodities Data ---
    COMMODITIES: [
        { id: COMMODITY_IDS.WATER_ICE, name: 'Water Ice', tier: 1, basePriceRange: [15, 80], volatility: 0.01, canonicalAvailability: [80, 150], styleClass: 'item-style-1', lore: 'Crude, unrefined water ice scraped from asteroids; a universal necessity.', cat: 'RAW', symbol: 'H2O' },
        { id: COMMODITY_IDS.PLASTEEL, name: 'Plasteel', tier: 1, basePriceRange: [100, 280], volatility: 0.015, canonicalAvailability: [80, 150], styleClass: 'item-style-2', lore: 'A basic, versatile polymer for 3D printing and simple manufacturing.', cat: 'IND', symbol: 'PLST' },
        { id: COMMODITY_IDS.HYDROPONICS, name: 'Hydroponics', tier: 2, licenseId: 't2_license', basePriceRange: [850, 2400], volatility: 0.025, canonicalAvailability: [40, 70], styleClass: 'item-style-3', lore: 'Packaged agricultural systems and produce essential for feeding isolated colonies.', cat: 'AGRI', symbol: 'HYD' },
        { id: COMMODITY_IDS.CYBERNETICS, name: 'Cybernetics', tier: 2, licenseId: 't2_license', basePriceRange: [1200, 3800], volatility: 0.03, canonicalAvailability: [40, 70], styleClass: 'item-style-4', lore: 'Mass-produced enhancement limbs and organs for the industrial workforce.', cat: 'TECH', symbol: 'CYB' },
        { id: COMMODITY_IDS.PROPELLANT, name: 'Refined Propellant', tier: 3, licenseId: 't3_license', basePriceRange: [14000, 38000], volatility: 0.035, canonicalAvailability: [25, 50], styleClass: 'item-style-5', lore: 'High-efficiency fuel that powers all modern ship drives.', cat: 'IND', symbol: 'PROP' },
        { id: COMMODITY_IDS.PROCESSORS, name: 'Neural Processors', tier: 3, licenseId: 't3_license', basePriceRange: [18000, 52000], volatility: 0.045, canonicalAvailability: [25, 50], styleClass: 'item-style-6', lore: 'The silicon brains behind complex ship systems and station logistics.', cat: 'TECH', symbol: 'NPRO' },
        { id: COMMODITY_IDS.GMO_SEEDS, name: 'GMO Seed Cultures', tier: 4, licenseId: 't4_license', basePriceRange: [190000, 550000], volatility: 0.06, canonicalAvailability: [15, 30], styleClass: 'item-style-7', lore: 'Patented seeds holding the key to unlocking agricultural wealth on new worlds.', cat: 'AGRI', symbol: 'GMO' },
        { id: COMMODITY_IDS.CRYO_PODS, name: 'Cryo-Sleep Pods', tier: 4, licenseId: 't4_license', basePriceRange: [250000, 750000], volatility: 0.075, canonicalAvailability: [15, 30], styleClass: 'item-style-8', lore: 'Essential for long-haul passenger transport and colonization efforts.', cat: 'CIV', symbol: 'CRYO' },
        { id: COMMODITY_IDS.ATMO_PROCESSORS, name: 'Atmo Processors', tier: 5, licenseId: 't5_license', basePriceRange: [2800000, 8500000], volatility: 0.08, canonicalAvailability: [10, 20], styleClass: 'item-style-9', lore: 'Gargantuan machines that begin the centuries-long process of making a world breathable.', cat: 'IND', symbol: 'ATMO' },
        { id: COMMODITY_IDS.CLONED_ORGANS, name: 'Cloned Organs', tier: 5, licenseId: 't5_license', basePriceRange: [3500000, 11000000], volatility: 0.09, canonicalAvailability: [10, 20], styleClass: 'item-style-10', lore: 'Lab-grown replacements with high demand in wealthy core worlds; morally grey.', cat: 'BIO', symbol: 'CLON' },
        { id: COMMODITY_IDS.XENO_GEOLOGICALS, name: 'Xeno-Geologicals', tier: 6, licenseId: 't6_license', basePriceRange: [24000000, 70000000], volatility: 0.1, canonicalAvailability: [2, 10], styleClass: 'item-style-11', lore: 'Rare, non-terrestrial minerals with bizarre physical properties; a scientific treasure.', cat: 'RAW', symbol: 'XENO' },
        { id: COMMODITY_IDS.SENTIENT_AI, name: 'Sentient AI Cores', tier: 6, licenseId: 't6_license', basePriceRange: [32000000, 95000000], volatility: 0.125, canonicalAvailability: [2, 10], styleClass: 'item-style-12', lore: 'The "brains" of capital ships whose emergent consciousness is a subject of intense, and often classified, philosophical debate.', cat: 'TECH', symbol: 'AI' },
        { id: COMMODITY_IDS.ANTIMATTER, name: 'Antimatter', tier: 7, licenseId: 't7_license', basePriceRange: [280000000, 800000000], volatility: 0.15, canonicalAvailability: [2, 10], styleClass: 'item-style-13', lore: 'The only safe way to transport the most volatile and powerful substance known to science.', cat: 'RARE', symbol: 'AM' },
        { id: COMMODITY_IDS.FOLDED_DRIVES, name: 'Folded-Space Drives', tier: 7, licenseId: 't7_license', basePriceRange: [350000000, 1100000000], volatility: 0.15, canonicalAvailability: [2, 10], styleClass: 'item-style-14', lore: 'The pinnacle of travel tech, allowing a vessel to pierce spacetime for near-instantaneous jumps.', cat: 'RARE', symbol: 'FSD' }
    ],
    
    // --- Trading Licenses ---
    LICENSES: {
        't2_license': { type: 'purchase', name: 'Tier 2 Trade License', description: 'Grants access to trade Tier 2 commodities like Hydroponics and Cybernetics.', cost: 25000 },
        't3_license': { type: 'mission', name: 'Tier 3 Trade License', description: 'Grants access to trade Tier 3 commodities.', missionId: 'mission_license_t3', guidanceText: 'Access to this tier is granted by the Merchant\'s Guild upon completion of a key contract.' },
        't4_license': { type: 'purchase', name: 'Tier 4 Trade License', description: 'Grants access to trade Tier 4 commodities.', cost: 4000000 },
        't5_license': { type: 'mission', name: 'Tier 5 Trade License', description: 'Grants access to trade Tier 5 commodities.', missionId: 'mission_license_t5', guidanceText: 'Prove your industrial might by completing a grand contract for a planetary governor.' },
        't6_license': { type: 'purchase', name: 'Tier 6 Trade License', description: 'Grants access to trade the rarest and most exotic technologies.', cost: 300000000 },
        't7_license': { type: 'mission', name: 'Tier 7 Trade License', description: 'The ultimate license, granting the right to trade reality-bending technologies.', missionId: 'mission_license_t7', guidanceText: 'Only a true legend of the trade routes can earn this privilege.' },
    },

    // --- Market and Location Data ---
    MARKETS: [
        { id: LOCATION_IDS.EARTH, name: 'Earth Orbit', launchFlavor: "The bustling heart of the Sol system.", navTheme: { gradient: 'linear-gradient(to bottom right, #1e3a8a, #0f172a)', textColor: '#93c5fd', borderColor: '#60a5fa' }, description: 'The hub of power and wealth. High demand for tech and bio-enhancements.', color: 'border-cyan-500', bg: 'bg-gradient-to-br from-blue-900 to-slate-900', fuelPrice: 250, arrivalLore: "The cradle of humanity buzzes with endless traffic; a beacon of blue and green against the void.", availabilityModifier: { 'cybernetics': 2.0, 'gmo_seeds': 2.0, 'cloned_organs': 0.1, 'sentient_ai': 0.5, 'folded_drives': 0.5 } },
        { id: LOCATION_IDS.LUNA, name: 'The Moon', launchFlavor: "An industrial powerhouse built on grey dust.", navTheme: { gradient: 'linear-gradient(to bottom right, #374151, #0f172a)', textColor: '#e5e7eb', borderColor: '#9ca3af' }, description: 'An industrial proving ground. Exports propellant and basic materials.', color: 'border-gray-400', bg: 'bg-gradient-to-br from-gray-700 to-slate-900', fuelPrice: 350, arrivalLore: "Dusty plains are scarred by mining operations under the harsh, silent watch of distant Earth.", availabilityModifier: { 'plasteel': 2.0 } },
        { id: LOCATION_IDS.MARS, name: 'Mars', launchFlavor: "The red frontier, ripe with opportunity.", navTheme: { gradient: 'linear-gradient(to bottom right, #7c2d12, #0f172a)', textColor: '#fca5a5', borderColor: '#f87171' }, description: 'A growing colony. Needs processors and materials for expansion.', color: 'border-orange-600', bg: 'bg-gradient-to-br from-orange-900 to-slate-900', fuelPrice: 450, arrivalLore: "The thin, reddish atmosphere whips across terraforming arrays and fledgling biodomes.", availabilityModifier: { 'plasteel': 2.0, 'hydroponics': 2.0, 'gmo_seeds': 0.5, 'cryo_pods': 0.5 } },
        { id: LOCATION_IDS.VENUS, name: 'Venus', launchFlavor: "Floating cities hide scientific marvels and secrets.", navTheme: { gradient: 'linear-gradient(to bottom right, #854d0e, #0f172a)', textColor: '#fde047', borderColor: '#facc15' }, description: 'A scientific enclave hungry for research data and processors.', color: 'border-yellow-400', bg: 'bg-gradient-to-br from-yellow-800 to-slate-900', fuelPrice: 400, arrivalLore: "Floating cities drift through the thick, acidic clouds, their lights a lonely defiance to the crushing pressure below.", availabilityModifier: { 'processors': 0.5, 'atmo_processors': 0.5, 'cloned_organs': 2.0 } },
        { id: LOCATION_IDS.BELT, name: 'The Asteroid Belt', launchFlavor: "A lawless expanse of rock and riches.", navTheme: { gradient: 'linear-gradient(to bottom right, #292524, #0f172a)', textColor: '#ca8a04', borderColor: '#ca8a04' }, description: 'A lawless frontier. Rich in raw minerals and water ice.', color: 'border-amber-700', bg: 'bg-gradient-to-br from-stone-800 to-slate-900', fuelPrice: 600, arrivalLore: "Countless rocks tumble in a silent, chaotic dance, hiding both immense wealth and sudden peril.", availabilityModifier: { 'water_ice': 2.0, 'hydroponics': 0.5, 'cybernetics': 0.5 } },
        { id: LOCATION_IDS.SATURN, name: 'Saturn\'s Rings', launchFlavor: "Opulent stations drift among majestic rings.", navTheme: { gradient: 'linear-gradient(to bottom right, #713f12, #312e81, #0f172a)', textColor: '#fef08a', borderColor: '#fde047' }, description: 'A tourism hub. Demands luxury goods and bio-wares.', color: 'border-yellow-200', bg: 'bg-gradient-to-br from-yellow-900 via-indigo-900 to-slate-900', fuelPrice: 550, arrivalLore: "The majestic rings cast long shadows over opulent tourist stations and icy harvesting rigs.", availabilityModifier: { 'hydroponics': 0.5, 'cryo_pods': 2.0 } },
        { id: LOCATION_IDS.JUPITER, name: 'Jupiter', launchFlavor: "Vast refineries harvest fuel from the giant.", navTheme: { gradient: 'linear-gradient(to bottom right, #9a3412, #1c1917)', textColor: '#fed7aa', borderColor: '#fb923c' }, description: 'A gas giant teeming with orbital refineries. The primary source of propellant for the outer system.', color: 'border-orange-400', bg: 'bg-gradient-to-br from-orange-800 to-stone-900', fuelPrice: 150, arrivalLore: "The colossal sphere of Jupiter dominates the viewport, its Great Red Spot a baleful eye. Automated refineries drift in its upper atmosphere.", availabilityModifier: { 'water_ice': 2.0, 'propellant': 2.0, 'atmo_processors': 2.0 } },
        { id: LOCATION_IDS.URANUS, name: 'Uranus', launchFlavor: "A silent, ice-cold world of strange science.", navTheme: { gradient: 'linear-gradient(to bottom right, #155e75, #312e81)', textColor: '#a5f3fc', borderColor: '#67e8f9' }, description: 'A cold, distant world where scientists study bizarre quantum phenomena and strange geologicals.', color: 'border-cyan-200', bg: 'bg-gradient-to-br from-cyan-800 to-indigo-900', fuelPrice: 700, arrivalLore: "The pale, featureless orb of Uranus hangs tilted in the sky. Research outposts glitter like ice crystals in the eternal twilight.", availabilityModifier: { 'water_ice': 2.0, 'processors': 0.5, 'xeno_geologicals': 0.5, 'sentient_ai': 0.5, 'antimatter': 0.5, 'folded_drives': 0.5 } },
        { id: LOCATION_IDS.NEPTUNE, name: 'Neptune', launchFlavor: "The stormy edge of military-controlled space.", navTheme: { gradient: 'linear-gradient(to bottom right, #1e3a8a, #000000)', textColor: '#93c5fd', borderColor: '#60a5fa' }, description: 'A dark, stormy world, home to secretive military bases and shipyards.', color: 'border-blue-400', bg: 'bg-gradient-to-br from-blue-900 to-black', fuelPrice: 650, arrivalLore: "Supersonic winds howl across Neptune's deep blue clouds. Heavily armed patrol ships escort you to the shielded orbital station.", availabilityModifier: { 'water_ice': 2.0, 'sentient_ai': 0.5, 'antimatter': 0.5, 'folded_drives': 0.5 } },
        { id: LOCATION_IDS.PLUTO, name: 'Pluto', launchFlavor: "A haven for outcasts at the system's fringe.", navTheme: { gradient: 'linear-gradient(to bottom right, #312e81, #0f172a)', textColor: '#c4b5fd', borderColor: '#a78bfa' }, description: 'The furthest outpost, a haven for outcasts and smugglers dealing in forbidden tech.', color: 'border-indigo-400', bg: 'bg-gradient-to-br from-indigo-900 to-slate-900', fuelPrice: 900, arrivalLore: "Pluto's tiny, frozen heart is a whisper in the dark. The only light comes from a ramshackle station carved into a nitrogen-ice mountain.", availabilityModifier: { 'water_ice': 2.0, 'hydroponics': 0.5, 'cybernetics': 0.5, 'cloned_organs': 0.5, 'xeno_geologicals': 2.0 } },
        { id: LOCATION_IDS.EXCHANGE, name: 'The Exchange', launchFlavor: "The notorious black market of the outer belt.", navTheme: { gradient: 'linear-gradient(to bottom right, #581c87, #000000, #0f172a)', textColor: '#e9d5ff', borderColor: '#c084fc' }, description: 'A legendary black market station hidden deep within the Kuiper Belt. High stakes, high rewards.', color: 'border-purple-500', bg: 'bg-gradient-to-br from-purple-900 via-black to-slate-900', fuelPrice: 1200, arrivalLore: "A hollowed-out asteroid, bristling with rogue drones and comms jammers. This is the fabled Exchange, where fortunes are made or lost in an instant.", availabilityModifier: {} },
        { id: LOCATION_IDS.KEPLER, name: "Kepler's Eye", launchFlavor: "A colossal lens staring into the infinite void.", navTheme: { gradient: 'linear-gradient(to bottom right, #701a75, #0f172a)', textColor: '#f472b6', borderColor: '#ec4899' }, description: 'A massive deep-space observatory that consumes vast amounts of processing power.', color: 'border-fuchsia-500', bg: 'bg-gradient-to-br from-fuchsia-900 to-slate-900', fuelPrice: 800, arrivalLore: "The station is a single, enormous lens staring into the abyss, surrounded by a delicate lattice of sensors and habitation rings.", availabilityModifier: {} }
    ],

    // --- Mission Data ---
    MISSIONS: {
        'mission_tutorial_01': {
            id: "mission_tutorial_01",
            name: "Milk Run to Luna",
            type: "DELIVERY",
            host: "STATION",
            isRepeatable: false,
            isAbandonable: false,
            description: "Hey buddy, you're a new captain, right? My hauler's reactor is fried and I'm on the hook for a delivery to Luna.<br><br>Could you deliver this load of <b>Plasteel</b> to the <b>Moon</b> for me? I don't have any credits to spare, but I've padded the manifest.<br><br>Deliver what I owe, keep the rest. You won't have trouble selling it there, trust me.",
            objectives: [
                { "type": "have_item", "goodId": "plasteel", "quantity": 5 }
            ],
            completion: {
                "locationId": "loc_luna",
                "title": "Favor Complete",
                "text": "The freelancer sends his thanks.",
                "buttonText": "Deliver Plasteel"
            },
            rewards: [],
            providedCargo: [ // Cargo given to the player on mission acceptance.
                { "goodId": "plasteel", "quantity": 6 }
            ]
        },
        'mission_tutorial_02': {
            id: "mission_tutorial_02",
            name: "Martian Resupply",
            type: "DELIVERY",
            host: "STATION",
            isRepeatable: false,
            isAbandonable: false,
            description: "A construction crew on Mars has requested a small shipment of plasteel to complete a habitat.",
            prerequisites: [ // This mission only becomes available after 'mission_tutorial_01' is complete.
                { "type": "mission_completed", "missionId": "mission_tutorial_01" }
            ],
            objectives: [
                { "type": "have_item", "goodId": "plasteel", "quantity": 2 }
            ],
            completion: {
                "locationId": "loc_mars",
                "title": "Delivery Complete",
                "text": "The construction foreman thanks you for the Plasteel.",
                "buttonText": "Deliver Plasteel"
            },
            rewards: [
                { "type": "credits", "amount": 7500 }
            ]
        },
        'mission_license_t3': {
             id: "mission_license_t3", name: "Guild Certification", type: "LICENSE_GRANT", host: "GUILD", isRepeatable: false, isAbandonable: false, description: "The Merchant's Guild requires you to certify your trade proficiency. Accepting this contract formally recognizes your status and grants you access to Tier 3 commodities.", prerequisites: [{ "type": "revealed_tier", "tier": 3 }], objectives: [], completion: {}, rewards: [{ "type": "license", "licenseId": "t3_license" }]
        },
        'mission_license_t5': {
             id: "mission_license_t5", name: "Governor's Contract", type: "LICENSE_GRANT", host: "STATION", isRepeatable: false, isAbandonable: false, description: "The planetary governor requires a sign of your commitment to local industry. This contract solidifies your standing and unlocks access to Tier 5 commodities.", prerequisites: [{ "type": "revealed_tier", "tier": 5 }], objectives: [], completion: {}, rewards: [{ "type": "license", "licenseId": "t5_license" }]
        },
        'mission_license_t7': {
             id: "mission_license_t7", name: "Legendary Run", type: "LICENSE_GRANT", host: "UNKNOWN", isRepeatable: false, isAbandonable: false, description: "Your name is spoken in the farthest corners of the system. Only a legend of your stature may be granted the right to trade the most advanced technologies known.", prerequisites: [{ "type": "revealed_tier", "tier": 7 }], objectives: [], completion: {}, rewards: [{ "type": "license", "licenseId": "t7_license" }]
        }
    },

    // --- Tutorial System Data ---
    TUTORIAL_DATA: {
        'intro_hangar': {
            title: 'Your First Ship',
            trigger: { type: TUTORIAL_ACTION_TYPES.ACTION, action: 'INTRO_START_HANGAR' },
            navLock: true,
            steps: [
                {
                    stepId: 'hangar_1',
                    text: "Welcome to the <b>Shipyard</b> on <b>Mars!</b><br><br>Every station has a port from which you can trade ships and manage your <b>Hangar</b>.",
                    position: { desktop: 'bottom-right', mobile: 'top-center' },
                    completion: { type: TUTORIAL_ACTION_TYPES.INFO },
                    nextStepId: 'hangar_2',
                    isSkippable: true
                },
                {
                    stepId: 'hangar_2',
                    text: "Now that you've borrowed <b class='hl-yellow font-bold'>extra credits</b>, you can buy your first ship!<br><br>Select one of the options in the <b>Shipyard</b>. Choose carefully...",
                    position: { desktop: 'bottom-right', mobile: 'top-center' },
                    completion: { type: TUTORIAL_ACTION_TYPES.ACTION, action: ACTION_IDS.BUY_SHIP },
                    nextStepId: 'hangar_3',
                    isSkippable: true,
                    unlockPurchase: true
                },
                {
                    stepId: 'hangar_3',
                    text: 'This is your <b>Hangar</b>. From here you can manage all the ships you own. Select your new ship and <b class="hl-yellow font-bold">Board</b> it to make it your active vessel.',
                    position: { desktop: 'bottom-right', mobile: 'top-center' },
                    completion: { type: TUTORIAL_ACTION_TYPES.ACTION, action: ACTION_IDS.SELECT_SHIP },
                    nextStepId: null,
                    isSkippable: false
                }
            ]
        },
        'intro_finance': {
            title: 'Managing Your Debt',
            trigger: { type: TUTORIAL_ACTION_TYPES.ACTION, action: 'INTRO_START_FINANCE' },
            navLock: true,
            steps: [
                {
                    stepId: 'finance_1',
                    text: "That was a big purchase, but don't worry - you've still got some <b class='hl-yellow font-bold'>credits</b> left over!<br><br>Your transaction history and debts can be viewed on the <b>Finance</b> tab within <b>Data</b>.",
                    position: { desktop: 'bottom-right', mobile: 'top' },
                    completion: { type: TUTORIAL_ACTION_TYPES.INFO },
                    nextStepId: 'finance_2',
                    isSkippable: false
                },
                {
                    stepId: 'finance_2',
                    text: "Dont forget, your debt to the <b class='hl-yellow font-bold'>Merchant's Guild</b> is due in <b class='hl-red font-bold'>3 years</b>.<br><br>You will need to earn <b class='hl-yellow font-bold'>credits</b> to <b>pay off your debt</b>!",
                    position: { desktop: 'bottom-right', mobile: 'top' },
                    completion: { type: TUTORIAL_ACTION_TYPES.INFO },
                    nextStepId: null,
                    isSkippable: false
                }
            ]
        },
        'intro_missions': {
            id: "intro_missions",
            title: "First Steps",
            trigger: { "type": "ACTION", "action": "INTRO_START_MISSIONS" },
            navLock: true,
            steps: [
                { "stepId": "mission_1_1", "text": "This is the <b>Mission Terminal</b>.<br><br>Check the <b>Missions</b> tab often for opportunities to earn <b class='hl-yellow font-bold'>credits</b> and improve your reputation.", "position": { "desktop": "bottom-right", "mobile": "top" }, "completion": { "type": "INFO" }, "nextStepId": "mission_1_2", "isSkippable": false },
                { "stepId": "mission_1_2", "text": "A freelancer at the <b>Mars</b> station has put in a <b>Delivery</b> request. Select the mission '<b>Milk Run to Luna</b>' to view more details.", "position": { "desktop": "bottom-right", "mobile": "top" }, "completion": { "type": "ACTION", "action": "show-mission-modal" }, "nextStepId": "mission_1_3", "isSkippable": false },
                { "stepId": "mission_1_3", "text": "The freelancer can't pay, but he's giving you the <b>remaining cargo</b>. Accept the contract.", "position": { "desktop": "bottom-right", "mobile": "top" }, "completion": { "type": "ACTION", "action": "accept-mission" }, "nextStepId": "mission_1_4", "isSkippable": false },
                { "stepId": "mission_1_4", "text": "Mission accepted!<br><br>The contract is now <b>active</b> and the cargo as been loaded onto your ship, the <b>{shipName}</b>.<br><br>The freelancer has also loaded extra <b>Plasteel</b> which you can sell for <b class='hl-yellow font-bold'>credits</b>.", "position": { "desktop": "bottom-right", "mobile": "top" }, "completion": { "type": "INFO" }, "nextStepId": "mission_1_5", "isSkippable": false },
                { "stepId": "mission_1_5", "text": "This mission must be completed on the <b>Moon</b>, but you are presently docked at <b>Mars</b>! Therefore, it's time for the maiden voyage of your new ship, the <b>{shipName}</b>!<br><br>On the <b>nav bar</b> at the top, select the <b>Ship</b> tab, then the <b>Navigation</b> tab.", "position": { "desktop": "bottom-center", "mobile": "top" }, "completion": { "type": "SCREEN_LOAD", "screenId": "navigation" }, "nextStepId": "mission_1_6", "isSkippable": false, "navLock": { "navId": NAV_IDS.SHIP, "screenId": "navigation" } },
                { "stepId": "mission_1_6", "text": "From here you can travel to other stations in the system. This will cost you <b>time</b>, <b class='hl-blue'>fuel</b>, and wear on the <b class='hl-green'>hull</b> of your ship.<br><br>Select the <b>Moon</b> to lift off from <b>Mars</b>.", "position": { "desktop": "top-center", "mobile": "top" }, "completion": { "type": "ACTION", "action": "travel" }, "nextStepId": "mission_1_7", "isSkippable": false, "navLock": { "navId": NAV_IDS.SHIP, "screenId": "navigation", "enabledElementQuery": "[data-location-id='loc_luna']" } },
                { "stepId": "mission_1_7", "text": "You've arrived and docked at the <b>Moon</b> station!<br><br>It's time to deliver the <b>Plasteel</b>. Select the active mission and <b>deliver the Plasteel</b>.", "position": { "desktop": "bottom-center", "mobile": "top" }, "completion": { "type": "ACTION", "action": "complete-mission" }, "nextStepId": "mission_1_8", "isSkippable": false, "navLock": { "navId": NAV_IDS.DATA, "screenId": "missions" } },
                { "stepId": "mission_1_8", "text": "Mission complete!<br><br>However, favors don't pay off <b class='hl-yellow font-bold'>Guild</b> loans. You're going to need more <b class='hl-yellow font-bold'>credits</b>.", "position": { "desktop": "top-center", "mobile": "top" }, "completion": { "type": "INFO" }, "nextStepId": "mission_2_1", "isSkippable": false },
                { "stepId": "mission_1_9", "text": "Well done. Let's find a more profitable contract. Return to the Mission Terminal.", "position": { "desktop": "bottom-right", "mobile": "top" }, "completion": { "type": "SCREEN_LOAD", "screenId": "missions" }, "nextStepId": "mission_2_1", "isSkippable": false, "navLock": { "navId": NAV_IDS.DATA, "screenId": "missions" } },
                { "stepId": "mission_2_1", "text": "The <i>best way to make money</i> is to play the markets yourself by <b class='hl-green font-bold'>buying low and selling high</b>.<br><br>Select the <b>Starport</b> tab, then the <b>Market</b> tab.", "position": { "desktop": "top-center", "mobile": "top" }, "completion": { "type": "SCREEN_LOAD", "screenId": "market" }, "nextStepId": "mission_2_2", "isSkippable": false, "navLock": { "navId": NAV_IDS.STARPORT, "screenId": "market" } },
                { "stepId": "mission_2_2", "text": "This is the <b>Moon Market</b>.<br>On each commodity you will find a wealth of information to aid your trading.<br><br>The <b class='hl-green font-bold'>MKT</b> indicator will inform you of <b class='hl-green font-bold'>prices higher or lower than average.</b> Selecting the price will reveal past performance.<br><br>Select the <b class='hl-yellow font-bold'>Buy/Sell toggle</b> to transition to sale mode, and then sell your single unit of <b>Plasteel</b>.", "position": { "desktop": "top-center", "mobile": "top" }, "completion": { "type": "ACTION", "action": "sell-item", "goodId": "plasteel" }, "nextStepId": "mission_2_3", "isSkippable": false },
                { "stepId": "mission_2_3", "text": "<b class='hl-green font-bold'>Pure profit</b>!<br><br>However, you still need more <b class='hl-yellow font-bold'>credits</b>! Return to the <b>Mission Terminal</b> by selecting the <b>Data</b> tab.", "position": { "desktop": "bottom-right", "mobile": "top" }, "completion": { "type": "SCREEN_LOAD", "screenId": "missions" }, "nextStepId": "mission_2_4", "isSkippable": false, "navLock": { "navId": NAV_IDS.DATA, "screenId": "missions" } },
                { "stepId": "mission_2_4", "text": "This mission offers a <b class='hl-yellow font-bold'>credit</b> reward.<br><br>Accept the mission, <b>Martian Resupply</b>.", "position": { "desktop": "bottom-right", "mobile": "top" }, "completion": { "type": "ACTION", "action": "accept-mission", "missionId": "mission_tutorial_02" }, "nextStepId": "mission_3_1", "isSkippable": false },
                { "stepId": "mission_3_1", "text": "To complete this mission you will need <b>travel to Mars</b> after you have purchased <b>two Plasteel</b> from any <b>Market</b>.<br><br>After you have acquired the <b>Plasteel</b>, visit the <b>Mission</b> tab on <b>Mars</b> to submit the cargo and complete the mission. ", "position": { "desktop": "top-center", "mobile": "top" }, "completion": { "type": "ACTION", "action": "complete-mission", "missionId": "mission_tutorial_02" }, "nextStepId": "mission_final", "isSkippable": false, "navLock": null },
                { "stepId": "mission_final", "text": "Well done Captain {playerName}, you have successfully completed trades across the <b>Moon</b> and <b>Mars</b>.<br><br>Continue to trade commodities for <b class='hl-green font-bold'>favorable margins</b> and complete missions to unlock additional opportunities.<br><br><b>The Solar System awaits</b>!", "position": { "desktop": "top-center", "mobile": "top" }, "completion": { "type": "INFO" }, "nextStepId": null, "isSkippable": false, "buttonText": "Complete Tutorial", "navLock": null }
            ]
        }
    }
};
--- END OF FILE: ./js/data/database.js ---

--- START OF FILE: ./js/services/DebugService.js ---
// js/services/DebugService.js
/**
 * @fileoverview This file contains the DebugService class, which is responsible for creating and managing
 * the lil-gui developer panel for real-time testing and manipulation of the game state.
 */
import { DB } from '../data/database.js';
import { LOCATION_IDS, SHIP_IDS, NAV_IDS, SCREEN_IDS } from '../data/constants.js';
import { Logger } from './LoggingService.js';

/**
 * A simple bot that plays the game to stress-test the economy and find bugs.
 * @class AutomatedPlayer
 */
class AutomatedPlayer {
    /**
     * @param {import('./GameState.js').GameState} gameState The central game state object.
     * @param {import('./SimulationService.js').SimulationService} simulationService The core game logic engine.
     * @param {import('./LoggingService.js').Logger} logger The logging utility.
     */
    constructor(gameState, simulationService, logger) {
        this.gameState = gameState;
        this.simulationService = simulationService;
        this.logger = logger;
        this.isRunning = false;
        this.stopRequested = false;
    }

    /**
     * Starts the automated play simulation.
     * @param {object} config - Configuration for the simulation run.
     * @param {number} config.daysToRun - The number of in-game days to simulate.
     * @param {function} updateCallback - A function to call with progress updates.
     */
    async runSimulation({ daysToRun }, updateCallback) {
        if (this.isRunning) {
            this.logger.warn('AutomatedPlayer', 'AUTOTRADER-01 is already running.');
            return;
        }

        this.isRunning = true;
        this.stopRequested = false;
        const startDay = this.gameState.day;
        const endDay = startDay + daysToRun;

        this.logger.info.system('Bot', startDay, 'SIMULATION_START', `Starting simulation for ${daysToRun} days.`);

        while (this.gameState.day < endDay && !this.stopRequested) {
            const activeShip = this.simulationService._getActiveShip();
            if (activeShip) {
                const fuelPct = (this.gameState.player.shipStates[activeShip.id].fuel / activeShip.maxFuel) * 100;
                const healthPct = (this.gameState.player.shipStates[activeShip.id].health / activeShip.maxHealth) * 100;

                if (fuelPct < 30) {
                    this.logger.info.system('Bot', this.gameState.day, 'REFUEL', `Low fuel (${fuelPct.toFixed(1)}%). Refueling.`);
                    this.botRefuel();
                }
                if (healthPct < 30) {
                    this.logger.info.system('Bot', this.gameState.day, 'REPAIR', `Low hull integrity (${healthPct.toFixed(1)}%). Repairing.`);
                    this.botRepair();
                }
            }

            const bestTrade = this._findBestTradeRoute();

            if (bestTrade) {
                this.logger.group(`[Bot] [Day ${this.gameState.day}] Executing Trade Route: ${bestTrade.goodId}`);
                if (this.gameState.currentLocationId !== bestTrade.buyLocationId) {
                    this.simulationService.travelService.initiateTravel(bestTrade.buyLocationId);
                }
                const buyQty = this._calculateMaxBuy(bestTrade.goodId, bestTrade.buyPrice);
                if(buyQty > 0) this.simulationService.playerActionService.buyItem(bestTrade.goodId, buyQty);

                if (this.gameState.currentLocationId !== bestTrade.sellLocationId) {
                    this.simulationService.travelService.initiateTravel(bestTrade.sellLocationId);
                }

                const sellQty = this.simulationService._getActiveInventory()[bestTrade.goodId]?.quantity || 0;
                if(sellQty > 0) this.simulationService.playerActionService.sellItem(bestTrade.goodId, sellQty);
                this.logger.groupEnd();
            } else {
                this.simulationService.timeService.advanceDays(1);
            }
            updateCallback(this.gameState.day, endDay);
            await new Promise(resolve => setTimeout(resolve, 10));
        }

        this.logger.info.system('Bot', this.gameState.day, 'SIMULATION_END', 'Simulation finished.');
        this.isRunning = false;
    }

    /**
     * Stops the currently running simulation.
     */
    stop() {
        this.stopRequested = true;
    }

    /**
     * @private
     */
    botRefuel() {
        const ship = this.simulationService._getActiveShip();
        if (!ship) return;
        const fuelNeeded = ship.maxFuel - this.gameState.player.shipStates[ship.id].fuel;
        if (fuelNeeded <= 0) return;
        const currentMarket = DB.MARKETS.find(m => m.id === this.gameState.currentLocationId);
        let fuelPrice = currentMarket.fuelPrice / 2;
        const totalCost = (fuelNeeded / 5) * fuelPrice;

        if (this.gameState.player.credits >= totalCost) {
            this.gameState.player.credits -= totalCost;
            this.gameState.player.shipStates[ship.id].fuel = ship.maxFuel;
        }
    }
    
    /**
     * @private
     */
    botRepair() {
        const ship = this.simulationService._getActiveShip();
        if (!ship) return;
        const healthNeeded = ship.maxHealth - this.gameState.player.shipStates[ship.id].health;
        if (healthNeeded <= 0) return;
        const totalCost = healthNeeded * GAME_RULES.REPAIR_COST_PER_HP;
        if (this.gameState.player.credits >= totalCost) {
            this.gameState.player.credits -= totalCost;
            this.gameState.player.shipStates[ship.id].health = ship.maxHealth;
        }
    }

    /**
     * @private
     */
    _calculateMaxBuy(goodId, price) {
        const state = this.gameState.getState();
        const ship = this.simulationService._getActiveShip();
        const inventory = this.simulationService._getActiveInventory();
        const space = ship.cargoCapacity - Object.values(inventory).reduce((acc, item) => acc + item.quantity, 0);
        const canAfford = price > 0 ? Math.floor(state.player.credits / price) : space;
        const stock = state.market.inventory[state.currentLocationId][goodId].quantity;
        return Math.max(0, Math.min(space, canAfford, stock));
    }

    /**
     * @private
     */
    _findBestTradeRoute() {
        const state = this.gameState.getState();
        let bestTrade = null;
        let maxProfitPerDay = 0;

        const availableCommodities = DB.COMMODITIES.filter(c => c.tier <= state.player.revealedTier);

        for (const good of availableCommodities) {
            for (const buyLocation of DB.MARKETS) {
                if (!state.player.unlockedLocationIds.includes(buyLocation.id)) continue;

                for (const sellLocation of DB.MARKETS) {
                    if (buyLocation.id === sellLocation.id || !state.player.unlockedLocationIds.includes(sellLocation.id)) continue;

                    const buyPrice = state.market.prices[buyLocation.id][good.id];
                    const sellPrice = state.market.prices[sellLocation.id][good.id];
                    const profitPerUnit = sellPrice - buyPrice;

                    if (profitPerUnit > 0) {
                        const travelTimeToBuy = state.TRAVEL_DATA[state.currentLocationId]?.[buyLocation.id]?.time || 0;
                        const travelTimeToSell = state.TRAVEL_DATA[buyLocation.id]?.[sellLocation.id]?.time || 0;
                        const totalTime = travelTimeToBuy + travelTimeToSell + 1; // +1 for transaction time
                        const profitPerDay = profitPerUnit / totalTime;

                        if (profitPerDay > maxProfitPerDay) {
                            maxProfitPerDay = profitPerDay;
                            bestTrade = {
                                goodId: good.id,
                                buyLocationId: buyLocation.id,
                                sellLocationId: sellLocation.id,
                                buyPrice,
                                sellPrice,
                                profitPerUnit
                            };
                        }
                    }
                }
            }
        }
        return bestTrade;
    }
}

export class DebugService {
    /**
     * @param {import('./GameState.js').GameState} gameState The central game state object.
     * @param {import('./SimulationService.js').SimulationService} simulationService The core game logic engine.
     * @param {import('./UIManager.js').UIManager} uiManager The UI rendering service.
     * @param {import('./LoggingService.js').Logger} logger The logging utility.
     */
    constructor(gameState, simulationService, uiManager, logger) {
        this.gameState = gameState;
        this.simulationService = simulationService;
        this.uiManager = uiManager;
        this.logger = logger;
        this.gui = null;
        this.active = false;
        this.actions = {};
        this.debugState = {}; // Holds state for GUI controllers
        this.bot = new AutomatedPlayer(gameState, simulationService, logger);
    }

    /**
     * Initializes the debug panel.
     */
    init() {
        if (this.gui) return;
        this.gui = new lil.GUI();
        this.gui.domElement.style.display = 'none';
        this._registerDebugActions();
        this.buildGui();
    }

    /**
     * Handles key presses forwarded from the EventManager.
     * @param {string} key
     */
    handleKeyPress(key) {
        const action = Object.values(this.actions).find(a => a.key === key);
        if (action && action.handler) {
            action.handler();
        }
    }

    /**
     * Toggles the visibility of the debug panel UI.
     */
    toggleVisibility() {
        if (!this.gui) return;
        this.active = !this.active;
        this.gui.domElement.style.display = this.active ? 'block' : 'none';
    }

    /**
     * Gathers and copies a bug report to the clipboard.
     */
    generateBugReport() {
        const logHistory = this.logger.getLogHistory();
        const gameState = this.gameState.getState();
        
        delete gameState.TRAVEL_DATA;
        delete gameState.market.priceHistory;

        const report = `
ORBITAL TRADING - BUG REPORT
==============================
Date: ${new Date().toISOString()}

--- GAME STATE SNAPSHOT ---
${JSON.stringify(gameState, null, 2)}

--- RECENT LOG HISTORY ---
${logHistory}
        `;
        
        navigator.clipboard.writeText(report.trim())
            .then(() => {
                this.uiManager.createFloatingText('Bug Report Copied to Clipboard!', window.innerWidth / 2, window.innerHeight / 2, '#4ade80');
            })
            .catch(err => {
                this.logger.error('DebugService', 'Failed to copy bug report.', err);
            });
    }

    // --- NEWLY MOVED DEBUG METHODS ---
    godMode() {
        this.logger.warn('DebugService', 'GOD MODE ACTIVATED.');
        this.gameState.introSequenceActive = false;
        this.simulationService.tutorialService.activeBatchId = null;
        this.simulationService.tutorialService.activeStepId = null;
        this.gameState.tutorials.activeBatchId = null;
        this.gameState.tutorials.activeStepId = null; 
        this.gameState.tutorials.skippedTutorialBatches = Object.keys(DB.TUTORIAL_DATA);
        
        this.gameState.player.credits = 1000000000000;
        this.gameState.player.ownedShipIds = [];
        this.simulationService.addShipToHangar(SHIP_IDS.BEHEMOTH);
        this.gameState.player.activeShipId = SHIP_IDS.BEHEMOTH;
        
        this.gameState.player.revealedTier = 7;
        this.gameState.player.unlockedLicenseIds = Object.keys(DB.LICENSES);
        this.gameState.player.unlockedLocationIds = DB.MARKETS.map(m => m.id);

        this.uiManager.showGameContainer();
        this.simulationService.setScreen(NAV_IDS.STARPORT, SCREEN_IDS.MARKET);
        this.simulationService.timeService.advanceDays(7);
        this.gameState.setState({});
    }

    simpleStart() {
        this.logger.warn('DebugService', 'SIMPLE START ACTIVATED.');
        this.gameState.introSequenceActive = false;
        this.simulationService.tutorialService.activeBatchId = null;
        this.simulationService.tutorialService.activeStepId = null;
        this.gameState.tutorials.activeBatchId = null;
        this.gameState.tutorials.activeStepId = null;
        this.gameState.tutorials.skippedTutorialBatches = Object.keys(DB.TUTORIAL_DATA);
        this.gameState.player.ownedShipIds = [];
        this.simulationService.addShipToHangar(SHIP_IDS.WANDERER);
        this.gameState.player.activeShipId = SHIP_IDS.WANDERER;
        this.uiManager.showGameContainer();
        this.simulationService.setScreen(NAV_IDS.DATA, SCREEN_IDS.MISSIONS);
        this.simulationService.timeService.advanceDays(7);
        this.gameState.setState({});
    }
    
    skipToHangarTutorial() {
        this.logger.warn('DebugService', 'SKIP TO HANGAR TUTORIAL ACTIVATED.');
        this.gameState.introSequenceActive = true; 

        this.simulationService.tutorialService.activeBatchId = null;
        this.simulationService.tutorialService.activeStepId = null;
        this.gameState.tutorials.activeBatchId = null;
        this.gameState.tutorials.activeStepId = null;
        this.gameState.tutorials.skippedTutorialBatches = [];

        this.gameState.player.credits = 25000;
        this.gameState.player.ownedShipIds = [];
        this.gameState.player.activeShipId = null;
        this.gameState.player.shipStates = {};
        this.gameState.player.inventories = {};

        this.uiManager.showGameContainer();
        this.simulationService.setScreen(NAV_IDS.STARPORT, SCREEN_IDS.HANGAR);
        this.simulationService.tutorialService.triggerBatch('intro_hangar', 'hangar_1');
        this.gameState.setState({});
    }

    grantAllItems() {
        const inventory = this.simulationService._getActiveInventory();
        if (!inventory) {
            this.logger.warn('DebugService', 'Cannot grant items: No active inventory found.');
            return;
        }
        DB.COMMODITIES.forEach(commodity => {
            if (inventory[commodity.id]) {
                inventory[commodity.id].quantity += 1;
            } else {
                inventory[commodity.id] = { quantity: 1, avgCost: 0 };
            }
        });
        this.logger.warn('DebugService', 'Debug: Granted 1x of all commodities.');
        this.gameState.setState({});
    }

    fillShipyard() {
        const { currentLocationId, day } = this.gameState;
        if (this.gameState.market.shipyardStock[currentLocationId]) {
            const allShipIds = Object.keys(DB.SHIPS);
            this.gameState.market.shipyardStock[currentLocationId] = {
                day: day,
                shipsForSale: allShipIds
            };
            this.logger.warn('DebugService', `SHIPYARD FILLED: All ships added to ${currentLocationId}.`);
            this.gameState.setState({});
        } else {
            this.logger.error('DebugService', `Cannot fill shipyard: No stock object for ${currentLocationId}.`);
        }
    }


    /**
     * @private
     */
    _registerDebugActions() {
        this.actions = {
            godMode: { name: 'God Mode', type: 'button', key: 't', handler: () => this.godMode() },
            simpleStart: { name: 'Simple Start', type: 'button', key: 'y', handler: () => this.simpleStart() },
            skipToHangarTutorial: { name: 'Skip to Hangar Tutorial', type: 'button', key: 'h', handler: () => this.skipToHangarTutorial() },
            addCredits: {
                name: 'Add Credits', type: 'button', key: 'c', handler: () => {
                    this.gameState.player.credits += this.debugState.creditsToAdd;
                    this.simulationService.timeService._checkMilestones();
                    this.uiManager.render(this.gameState.getState());
                }
            },
            payDebt: { name: 'Pay Off Debt', type: 'button', handler: () => this.simulationService.playerActionService.payOffDebt() },
            teleport: {
                name: 'Teleport', type: 'button', handler: () => {
                    if (this.debugState.selectedLocation) {
                        this.gameState.currentLocationId = this.debugState.selectedLocation;
                        this.gameState.setState({});
                    }
                }
            },
            unlockAll: {
                name: 'Unlock All', type: 'button', handler: () => {
                    this.gameState.player.unlockedLocationIds = DB.MARKETS.map(m => m.id);
                    this.gameState.player.revealedTier = 7;
                    this.gameState.player.unlockedLicenseIds = Object.keys(DB.LICENSES);
                    this.gameState.setState({});
                }
            },
            grantAllShips: {
                name: 'Grant All Ships', type: 'button', handler: () => {
                    Object.keys(DB.SHIPS).forEach(shipId => {
                        if (!this.gameState.player.ownedShipIds.includes(shipId)) {
                            this.simulationService.addShipToHangar(shipId);
                        }
                    });
                    this.gameState.setState({});
                }
            },
            grantAllItems: { name: 'Grant 1x All Items', type: 'button', key: 'g', handler: () => this.grantAllItems() },
            advanceTime: { name: 'Advance Days', type: 'button', key: 'a', handler: () => this.simulationService.timeService.advanceDays(this.debugState.daysToAdvance) },
            replenishStock: {
                name: 'Replenish All Stock', type: 'button', handler: () => {
                    this.simulationService.marketService.replenishMarketInventory();
                    this.gameState.setState({});
                }
            },
            fillShipyard: { name: 'Fill Shipyard w/ All Ships', type: 'button', handler: () => this.fillShipyard() },
            triggerRandomEvent: {
                name: 'Trigger Random Event', type: 'button', key: 'e', handler: () => {
                    const dest = DB.MARKETS.find(m => m.id !== this.gameState.currentLocationId)?.id;
                    if (dest) {
                        this.simulationService.travelService._checkForRandomEvent(dest, this.debugState.selectedRandomEvent);
                    }
                }
            },
            triggerAgeEvent: {
                name: 'Trigger Age Event', type: 'button', handler: () => {
                    const event = DB.AGE_EVENTS.find(e => e.id === this.debugState.selectedAgeEvent);
                    if (event) {
                        this.uiManager.showAgeEventModal(event, (choice) => this.simulationService._applyPerk(choice));
                    }
                }
            },
            triggerMission: {
                name: 'Trigger Mission', type: 'button', key: 'm', handler: () => {
                    if (this.debugState.selectedMission) {
                        if(this.gameState.missions.activeMissionId) {
                            this.simulationService.missionService.abandonMission();
                        }
                        this.simulationService.missionService.acceptMission(this.debugState.selectedMission);
                    }
                }
            },
            triggerSystemSurge: {
                name: 'Trigger System Surge', type: 'button', handler: () => {
                    this.uiManager.triggerEffect('systemSurge', {
                        text: this.debugState.surgeText,
                        theme: this.debugState.surgeTheme,
                        particleCount: this.debugState.surgeParticleCount,
                        particleShape: this.debugState.surgeParticleShape,
                        particleSize: { min: this.debugState.surgeParticleSizeMin, max: this.debugState.surgeParticleSizeMax },
                        particleSpeed: { min: this.debugState.surgeParticleSpeedMin, max: this.debugState.surgeParticleSpeedMax },
                        fadeInTime: this.debugState.surgeFadeIn,
                        lingerTime: this.debugState.surgeLinger,
                        fadeOutTime: this.debugState.surgeFadeOut,
                        textSize: this.debugState.surgeTextSize,
                        travelDistance: this.debugState.surgeTravelDistance,
                    });
                }
            },
            startBot: {
                name: 'Start AUTOTRADER-01', type: 'button', handler: () => {
                    const progressController = this.gui.controllers.find(c => c.property === 'botProgress');
                    this.bot.runSimulation({ daysToRun: this.debugState.botDaysToRun }, (current, end) => {
                        if(progressController) progressController.setValue(`${current} / ${end}`).updateDisplay();
                    });
                }
            },
            stopBot: { name: 'Stop AUTOTRADER-01', type: 'button', handler: () => this.bot.stop() }
        };
    }

    /**
     * @private
     */
    buildGui() {
        const flowFolder = this.gui.addFolder('Game Flow');
        flowFolder.add(this.actions.godMode, 'handler').name(this.actions.godMode.name);
        flowFolder.add(this.actions.simpleStart, 'handler').name(this.actions.simpleStart.name);
        flowFolder.add(this.actions.skipToHangarTutorial, 'handler').name(this.actions.skipToHangarTutorial.name);

        const playerFolder = this.gui.addFolder('Player');
        this.debugState.creditsToAdd = 100000;
        playerFolder.add(this.debugState, 'creditsToAdd').name('Credits Amount');
        playerFolder.add(this.actions.addCredits, 'handler').name('Add Credits');
        playerFolder.add(this.actions.payDebt, 'handler').name(this.actions.payDebt.name);
        const locationOptions = DB.MARKETS.reduce((acc, loc) => ({...acc, [loc.name]: loc.id }), {});
        this.debugState.selectedLocation = this.gameState.currentLocationId;
        playerFolder.add(this.debugState, 'selectedLocation', locationOptions).name('Location');
        playerFolder.add(this.actions.teleport, 'handler').name('Teleport');

        const worldFolder = this.gui.addFolder('World & Time');
        this.debugState.daysToAdvance = 7;
        worldFolder.add(this.debugState, 'daysToAdvance', 1, 365, 1).name('Days to Advance');
        worldFolder.add(this.actions.advanceTime, 'handler').name('Advance Time');

        const economyFolder = this.gui.addFolder('Economy');
        economyFolder.add(this.actions.replenishStock, 'handler').name(this.actions.replenishStock.name);
        economyFolder.add(this.actions.unlockAll, 'handler').name('Unlock Tiers/Locations');
        economyFolder.add(this.actions.grantAllShips, 'handler').name('Grant All Ships');
        economyFolder.add(this.actions.grantAllItems, 'handler').name(this.actions.grantAllItems.name);
        economyFolder.add(this.actions.fillShipyard, 'handler').name(this.actions.fillShipyard.name);

        const triggerFolder = this.gui.addFolder('Triggers');
        const randomEventOptions = DB.RANDOM_EVENTS.reduce((acc, event, index) => ({...acc, [event.title]: index }), {});
        this.debugState.selectedRandomEvent = 0;
        triggerFolder.add(this.debugState, 'selectedRandomEvent', randomEventOptions).name('Random Event');
        triggerFolder.add(this.actions.triggerRandomEvent, 'handler').name('Trigger Event');
        const ageEventOptions = DB.AGE_EVENTS.reduce((acc, event) => ({...acc, [event.title]: event.id }), {});
        this.debugState.selectedAgeEvent = DB.AGE_EVENTS[0].id;
        triggerFolder.add(this.debugState, 'selectedAgeEvent', ageEventOptions).name('Age Event');
        triggerFolder.add(this.actions.triggerAgeEvent, 'handler').name('Trigger Event');
        const missionOptions = Object.values(DB.MISSIONS).reduce((acc, m) => ({...acc, [m.name]: m.id}), {});
        this.debugState.selectedMission = Object.keys(missionOptions)[0];
        triggerFolder.add(this.debugState, 'selectedMission', missionOptions).name('Mission');
        triggerFolder.add(this.actions.triggerMission, 'handler').name('Accept Mission');

        const surgeFolder = this.gui.addFolder('System Surge Effect');
        this.debugState.surgeTheme = 'gold';
        this.debugState.surgeText = 'SYSTEM SURGE';
        this.debugState.surgeParticleCount = 62;
        this.debugState.surgeParticleShape = 'circle';
        this.debugState.surgeParticleSizeMin = 3;
        this.debugState.surgeParticleSizeMax = 18;
        this.debugState.surgeParticleSpeedMin = 2.5;
        this.debugState.surgeParticleSpeedMax = 12;
        this.debugState.surgeFadeIn = 1750;
        this.debugState.surgeLinger = 3600;
        this.debugState.surgeFadeOut = 5000;
        this.debugState.surgeTextSize = '8vw';
        this.debugState.surgeTravelDistance = 90;

        surgeFolder.add(this.debugState, 'surgeTheme', ['gold', 'green', 'red', 'blue', 'orange', 'purple', 'silver', 'tan']).name('Theme');
        surgeFolder.add(this.debugState, 'surgeText').name('Text');
        surgeFolder.add(this.debugState, 'surgeTextSize').name('Text Size');
        surgeFolder.add(this.debugState, 'surgeParticleCount', 0, 200, 1).name('Particle Count');
        surgeFolder.add(this.debugState, 'surgeParticleShape', ['circle', 'star', 'sliver', 'rectangle']).name('Particle Shape');
        surgeFolder.add(this.debugState, 'surgeParticleSizeMin', 1, 20, 1).name('Min Size');
        surgeFolder.add(this.debugState, 'surgeParticleSizeMax', 1, 20, 1).name('Max Size');
        surgeFolder.add(this.debugState, 'surgeParticleSpeedMin', 1, 20, 0.5).name('Min Speed (s)');
        surgeFolder.add(this.debugState, 'surgeParticleSpeedMax', 1, 20, 0.5).name('Max Speed (s)');
        surgeFolder.add(this.debugState, 'surgeTravelDistance', 50, 200, 5).name('Travel Dist (vh)');
        surgeFolder.add(this.debugState, 'surgeFadeIn', 500, 5000, 50).name('Fade In (ms)');
        surgeFolder.add(this.debugState, 'surgeLinger', 500, 5000, 50).name('Linger (ms)');
        surgeFolder.add(this.debugState, 'surgeFadeOut', 500, 5000, 50).name('Fade Out (ms)');
        surgeFolder.add(this.actions.triggerSystemSurge, 'handler').name('Trigger Effect');

        const automationFolder = this.gui.addFolder('Automation & Logging');
        this.debugState.logLevel = 'INFO';
        automationFolder.add(this.debugState, 'logLevel', ['DEBUG', 'INFO', 'WARN', 'ERROR', 'NONE']).name('Log Level').onChange(v => this.logger.setLevel(v));
        automationFolder.add(this, 'generateBugReport').name('Generate Bug Report');
        this.debugState.botDaysToRun = 365;
        this.debugState.botProgress = 'Idle';
        automationFolder.add(this.debugState, 'botDaysToRun', 1, 10000, 1).name('Simulation Days');
        automationFolder.add(this.actions.startBot, 'handler').name(this.actions.startBot.name);
        automationFolder.add(this.actions.stopBot, 'handler').name(this.actions.stopBot.name);
        automationFolder.add(this.debugState, 'botProgress').name('Progress').listen();
        
        this.gui.folders.forEach(folder => folder.close());
    }
}
--- END OF FILE: ./js/services/DebugService.js ---

--- START OF FILE: ./js/services/GameState.js ---
// js/services/GameState.js
import { GAME_RULES, SAVE_KEY, SHIP_IDS, LOCATION_IDS, NAV_IDS, SCREEN_IDS } from '../data/constants.js';
import { DB } from '../data/database.js';
import { skewedRandom } from '../utils.js';

/**
 * Procedurally generates the travel data matrix, calculating the time and fuel cost
 * for travel between every pair of locations in the game.
 * @param {Array<object>} markets - The array of market objects from the database.
 * @returns {object} A nested object where `travelData[fromId][toId]` contains travel info.
 */
function procedurallyGenerateTravelData(markets) {
    const travelData = {};
    markets.forEach((fromMarket, i) => {
        travelData[fromMarket.id] = {};
        markets.forEach((toMarket, j) => {
            if (i === j) return;
            // Simple index difference is used as a proxy for orbital distance.
            const distance = Math.abs(i - j);
            const fuelTime = distance * 2 + Math.floor(Math.random() * 3);
            let fuelCost = Math.round(fuelTime * GAME_RULES.FUEL_SCALAR * (1 + (j / markets.length) * 0.5));
            let travelTime;
            // Special case for Earth-Luna to make it a quick, early-game trip.
            if ((fromMarket.id === LOCATION_IDS.EARTH && toMarket.id === LOCATION_IDS.LUNA) || (fromMarket.id === LOCATION_IDS.LUNA && toMarket.id === LOCATION_IDS.EARTH)) {
                travelTime = 1 + Math.floor(Math.random() * 3);
            } else {
                travelTime = 15 + (distance * 10) + Math.floor(Math.random() * 5);
            }
            travelData[fromMarket.id][toMarket.id] = { time: travelTime, fuelCost: Math.max(1, fuelCost) };
        });
    });
    return travelData;
}

/**
 * @class GameState
 * @description Holds all mutable data for the game session, acting as the single source of truth.
 * Static data (e.g., ship base stats, commodity types) is imported from the /data directory.
 * Dynamic data (e.g., player credits, ship health, cargo inventories) is stored and managed here.
 * For example, `DB.SHIPS` contains a ship's max health, while `player.shipStates` in this class
 * contains the *current* health of each ship the player owns.
 */
export class GameState {
    constructor() {
        this.state = {};
        this.subscribers = [];
        this.TRAVEL_DATA = procedurallyGenerateTravelData(DB.MARKETS);
    }

    /**
     * Subscribes a callback function to be executed whenever the game state changes.
     * @param {function} callback - The function to call on state changes.
     */
    subscribe(callback) {
        this.subscribers.push(callback);
    }

    /**
     * Notifies all subscribed components that the state has changed.
     * @private
     */
    _notify() {
        this.subscribers.forEach(callback => callback(this));
    }

    /**
     * Updates the game state by merging a partial state object and notifies subscribers.
     * This is the primary method for mutating the game state.
     * @param {object} partialState - An object containing the properties of the state to update.
     */
    setState(partialState) {
        Object.assign(this, partialState);
        this._notify();
        // this.saveGame(); // NOTE: Saving is currently disabled.
    }
    
    /**
     * Returns a deep copy of the current game state to prevent direct mutation.
     * @returns {object} A JSON-serialized and parsed copy of the game state.
     */
    getState() {
        return JSON.parse(JSON.stringify(this));
    }

    /**
     * Saves the current game state to localStorage.
     * NOTE: This functionality is currently disabled.
     */
    saveGame() {
        // try {
        //     const stateToSave = { ...this };
        //     delete stateToSave.subscribers;
        //     localStorage.setItem(SAVE_KEY, JSON.stringify(stateToSave));
        // } catch (error) {
        //     console.error("Error saving game state:", error);
        // }
    }

    /**
     * Loads the game state from localStorage.
     * NOTE: This functionality is currently disabled and will always start a new game.
     * @returns {boolean} True if a game was successfully loaded, false otherwise.
     */
    loadGame() {
        return false;
        // try {
        //     const serializedState = localStorage.getItem(SAVE_KEY);
        //     if (serializedState === null) return false;
            
        //     const loadedState = JSON.parse(serializedState);
        //     Object.assign(this, loadedState);
        //     this.TRAVEL_DATA = procedurallyGenerateTravelData(DB.MARKETS);
        //     this._notify();
        //     return true;
        // } catch (error) {
        //     console.warn("Could not parse save data. Starting new game.", error);
        //     localStorage.removeItem(SAVE_KEY);
        //     return false;
        // }
    }

    /**
     * Initializes the game state for a new game session, setting all player, market,
     * and other dynamic data to their default starting values.
     * @param {string} playerName - The name entered by the player.
     */
    startNewGame(playerName) {
        const initialState = {
            day: 1, lastInterestChargeDay: 1, lastMarketUpdateDay: 1, currentLocationId: LOCATION_IDS.MARS, activeNav: NAV_IDS.SHIP, activeScreen: SCREEN_IDS.NAVIGATION, isGameOver: false,
            subNavCollapsed: false,
            introSequenceActive: true,
            lastActiveScreen: {
                [NAV_IDS.SHIP]: SCREEN_IDS.STATUS,
                [NAV_IDS.STARPORT]: SCREEN_IDS.MARKET,
                [NAV_IDS.DATA]: SCREEN_IDS.MISSIONS,
            },
            pendingTravel: null,
            player: {
                name: playerName, playerTitle: 'Captain', playerAge: 24, lastBirthdayYear: DB.DATE_CONFIG.START_YEAR, birthdayProfitBonus: 0,
                introStep: 0,
                credits: 3000, debt: 0, monthlyInterestAmount: 0,
                loanStartDate: null, seenGarnishmentWarning: false,
                revealedTier: 1,
                unlockedLicenseIds: [],
                unlockedLocationIds: DB.MARKETS.map(m => m.id).filter(id => id !== LOCATION_IDS.EXCHANGE && id !== LOCATION_IDS.KEPLER),
                seenCommodityMilestones: [], financeLog: [],
                activePerks: {}, seenEvents: [], activeShipId: SHIP_IDS.WANDERER, ownedShipIds: [SHIP_IDS.WANDERER],
                shipStates: { [SHIP_IDS.WANDERER]: { health: DB.SHIPS[SHIP_IDS.WANDERER].maxHealth, fuel: DB.SHIPS[SHIP_IDS.WANDERER].maxFuel, hullAlerts: { one: false, two: false } } },
                inventories: { },
                debugEventIndex: 0
            },
            market: { prices: {}, inventory: {}, galacticAverages: {}, priceHistory: {}, shipyardStock: {} },
            intel: { active: null, available: {} },
            tutorials: {
                activeBatchId: null,
                activeStepId: null,
                seenBatchIds: [],
                skippedTutorialBatches: [],
                navLock: null
            },
            missions: {
                activeMissionId: null,
                completedMissionIds: [],
                missionProgress: {},
                activeMissionObjectivesMet: false
            },
            uiState: {
                marketCardMinimized: {},
                hangarShipyardToggleState: 'shipyard',
                hangarActiveIndex: 0,
                shipyardActiveIndex: 0
            }
        };

        initialState.player.inventories[SHIP_IDS.WANDERER] = {};
        DB.COMMODITIES.forEach(c => { initialState.player.inventories[SHIP_IDS.WANDERER][c.id] = { quantity: 0, avgCost: 0 }; });

        DB.MARKETS.forEach(m => {
            initialState.market.priceHistory[m.id] = {};
            initialState.intel.available[m.id] = (Math.random() < 0.3);
            initialState.market.inventory[m.id] = {};
            initialState.market.shipyardStock[m.id] = { day: 0, shipsForSale: [] };
            DB.COMMODITIES.forEach(c => {
                initialState.market.priceHistory[m.id][c.id] = [];
                
                const [min, max] = c.canonicalAvailability;
                const modifier = m.availabilityModifier?.[c.id] ?? 1.0;
                let quantity = Math.floor(skewedRandom(min, max) * modifier);

                if (m.specialDemand && m.specialDemand[c.id]) quantity = 0;

                initialState.market.inventory[m.id][c.id] = { 
                    quantity: Math.max(0, quantity),
                    marketPressure: 0.0,
                    lastPlayerInteractionTimestamp: 0,
                    hoverUntilDay: 0,
                    rivalArbitrage: { isActive: false, endDay: 0 }
                };
            });
        });

        Object.assign(this, initialState);
        this._calculateGalacticAverages();
        this._seedInitialMarketPrices();
        this.setState({});
    }

    /**
     * Calculates the baseline galactic average price for all commodities.
     * This is used as a reference point for market price fluctuations.
     * @private
     */
    _calculateGalacticAverages() {
        this.market.galacticAverages = {};
        DB.COMMODITIES.forEach(good => {
            this.market.galacticAverages[good.id] = (good.basePriceRange[0] + good.basePriceRange[1]) / 2;
        });
    }

    /**
     * Seeds the initial market prices for all commodities at all locations.
     * Prices are based on the galactic average with randomness applied.
     * @private
     */
    _seedInitialMarketPrices() {
        DB.MARKETS.forEach(location => {
            this.market.prices[location.id] = {};
            DB.COMMODITIES.forEach(good => {
                let price = this.market.galacticAverages[good.id] * (1 + (Math.random() - 0.5) * 0.15); // +/- 7.5% variance
                this.market.prices[location.id][good.id] = Math.max(1, Math.round(price));
            });
        });
    }
}
--- END OF FILE: ./js/services/GameState.js ---

--- START OF FILE: ./js/services/MissionService.js ---
// js/services/MissionService.js
/**
 * @fileoverview Manages the state and flow of player missions.
 */
import { DB } from '../data/database.js';
import { formatCredits } from '../utils.js';

export class MissionService {
    /**
     * @param {import('./GameState.js').GameState} gameState The central game state.
     * @param {import('./UIManager.js').UIManager} uiManager The UI manager instance.
     * @param {import('./LoggingService.js').Logger} logger The logging utility.
     */
    constructor(gameState, uiManager, logger) {
        this.gameState = gameState;
        this.uiManager = uiManager;
        this.logger = logger;
        this.simulationService = null; // Will be injected post-instantiation
    }

    /**
     * Injects the SimulationService after all services have been instantiated.
     * @param {import('./SimulationService.js').SimulationService} simulationService
     */
    setSimulationService(simulationService) {
        this.simulationService = simulationService;
    }

    /**
     * Checks if all prerequisites for a given mission are met.
     * @param {string} missionId The ID of the mission to check.
     * @returns {boolean} True if all prerequisites are met, false otherwise.
     */
    arePrerequisitesMet(missionId) {
        const mission = DB.MISSIONS[missionId];
        if (!mission || !mission.prerequisites) {
            return true; // No prerequisites, so it's met.
        }

        return mission.prerequisites.every(prereq => {
            switch (prereq.type) {
                case 'mission_completed':
                    return this.gameState.missions.completedMissionIds.includes(prereq.missionId);
                case 'revealed_tier':
                    return this.gameState.player.revealedTier >= prereq.tier;
                // Future prerequisite types like 'player_level' or 'item_owned' can be added here.
                default:
                    return false; // Unknown prerequisite type fails validation.
            }
        });
    }
    
    /**
     * Gets a list of all missions that are currently available to the player.
     * A mission is available if it's not active, not completed, and its prerequisites are met.
     * @returns {Array<object>} An array of available mission objects.
     */
    getAvailableMissions() {
        const { activeMissionId, completedMissionIds } = this.gameState.missions;
        return Object.values(DB.MISSIONS).filter(mission => {
            const isAvailable =
                mission.id !== activeMissionId &&
                !completedMissionIds.includes(mission.id) &&
                this.arePrerequisitesMet(mission.id);
            return isAvailable;
        });
    }

    /**
     * Accepts a new mission, setting it as the active mission.
     * @param {string} missionId The ID of the mission to accept.
     */
    acceptMission(missionId) {
        const mission = DB.MISSIONS[missionId];
        if (this.gameState.missions.activeMissionId || !mission || !this.arePrerequisitesMet(missionId)) {
            return;
        }
        this.gameState.missions.activeMissionId = missionId;
        this.gameState.missions.missionProgress[missionId] = {
            objectives: {}
        };
        this.logger.info.player(this.gameState.day, 'MISSION_ACCEPT', `Accepted mission: ${missionId}`);
        this.simulationService.grantMissionCargo(missionId);
        this.checkTriggers(); // Run an initial check in case objectives are already met.

        // If the mission has no objectives, complete it immediately.
        if (!mission.objectives || mission.objectives.length === 0) {
            this.completeActiveMission();
        } else {
            this.uiManager.render(this.gameState.getState());
        }
    }

    /**
     * Abandons the currently active mission.
     */
    abandonMission() {
        const abandonedMissionId = this.gameState.missions.activeMissionId;
        if (!abandonedMissionId) return;

        this.gameState.missions.activeMissionId = null;
        this.gameState.missions.activeMissionObjectivesMet = false;
        this.logger.info.player(this.gameState.day, 'MISSION_ABANDON', `Abandoned mission: ${abandonedMissionId}`);
        // Note: We keep missionProgress so the player doesn't lose partial progress if they re-accept.
        this.gameState.setState({});
        this.uiManager.render(this.gameState.getState());
    }

    /**
     * Checks all mission triggers against the current game state.
     * Primarily checks item possession for delivery/acquisition objectives.
     */
    checkTriggers() {
        const { activeMissionId } = this.gameState.missions;
        if (!activeMissionId) {
            if (this.gameState.missions.activeMissionObjectivesMet) {
                this.gameState.missions.activeMissionObjectivesMet = false;
                this.gameState.setState({}); // Notify of change
            }
            return;
        }
    
        const mission = DB.MISSIONS[activeMissionId];
        const inventory = this.gameState.player.inventories[this.gameState.player.activeShipId];
        if (!mission || !inventory) {
            this.gameState.missions.activeMissionObjectivesMet = false;
            return;
        }
    
        let allObjectivesMet = true;
        let progressChanged = false;
    
        mission.objectives.forEach(obj => {
            if (obj.type === 'have_item') {
                const currentQuantity = inventory[obj.goodId]?.quantity || 0;
                const progress = this.gameState.missions.missionProgress[activeMissionId];
    
                if (!progress.objectives[obj.goodId]) {
                    progress.objectives[obj.goodId] = { current: 0 };
                }
    
                if (progress.objectives[obj.goodId].current !== currentQuantity) {
                    progress.objectives[obj.goodId].current = currentQuantity;
                    progressChanged = true;
                }
    
                if (currentQuantity < obj.quantity) {
                    allObjectivesMet = false;
                }
            }
        });
    
        // Only update state and re-render if there's a change.
        if (this.gameState.missions.activeMissionObjectivesMet !== allObjectivesMet || progressChanged) {
            if (allObjectivesMet && !this.gameState.missions.activeMissionObjectivesMet) {
                this.logger.info.player(this.gameState.day, 'OBJECTIVES_MET', `All objectives for mission ${activeMissionId} are met.`);
            }
            this.gameState.missions.activeMissionObjectivesMet = allObjectivesMet;
            this.gameState.setState({}); // Set the new state
            this.uiManager.render(this.gameState.getState()); // Trigger a full re-render
            if (progressChanged) {
                this.uiManager.flashObjectiveProgress();
            }
        }
    }

    /**
     * Completes the active mission, granting rewards and removing objective items.
     */
    completeActiveMission() {
        const { activeMissionId } = this.gameState.missions;
        if (!activeMissionId) return;
        
        // Temporarily set objectivesMet to true for objective-less missions
        const originalObjectivesMet = this.gameState.missions.activeMissionObjectivesMet;
        const mission = DB.MISSIONS[activeMissionId];
        if (!mission.objectives || mission.objectives.length === 0) {
            this.gameState.missions.activeMissionObjectivesMet = true;
        }

        if (!this.gameState.missions.activeMissionObjectivesMet) {
            // Restore original state if completion is not actually met.
            this.gameState.missions.activeMissionObjectivesMet = originalObjectivesMet;
            return;
        }

        const inventory = this.gameState.player.inventories[this.gameState.player.activeShipId];

        // 1. Deduct objective items
        mission.objectives.forEach(obj => {
            if (obj.type === 'have_item' && inventory[obj.goodId]) {
                inventory[obj.goodId].quantity -= obj.quantity;
            }
        });

        // 2. Grant rewards via SimulationService
        if (this.simulationService) {
            this.simulationService._grantRewards(mission.rewards, mission.name);
        }
        this.logger.info.player(this.gameState.day, 'MISSION_COMPLETE', `Completed mission: ${activeMissionId}`);

        // Trigger the celebration effect using the 'gold' profile
        this.uiManager.triggerEffect('systemSurge', { theme: 'gold' });

        // 3. Update mission state
        this.gameState.missions.completedMissionIds.push(activeMissionId);
        this.gameState.missions.activeMissionId = null;
        this.gameState.missions.activeMissionObjectivesMet = false;

        // 4. Update state and re-render
        this.gameState.setState({});
        this.uiManager.render(this.gameState.getState());
    }
}
--- END OF FILE: ./js/services/MissionService.js ---

--- START OF FILE: ./js/services/simulation/MarketService.js ---
// js/services/simulation/MarketService.js
/**
 * @fileoverview This file contains the MarketService class, which handles the simulation
 * of the in-game economy. This includes evolving commodity prices over time based on
 * volatility and market pressure, replenishing market inventories with persistence,
 * and managing system-wide economic states.
 */
import { GAME_RULES } from '../../data/constants.js';
import { DB } from '../../data/database.js';
import { skewedRandom } from '../../utils.js';

/**
 * @class MarketService
 * @description Manages the economic simulation aspects of the game.
 */
export class MarketService {
    /**
     * @param {import('../GameState.js').GameState} gameState The central game state object.
     */
    constructor(gameState) {
        this.gameState = gameState;
        this._currentSystemState = null;
        this._systemStateExpirationDay = 0;
    }

    /**
     * Checks if the current system-wide economic state should change and applies a new one if necessary.
     */
    checkForSystemStateChange() {
        if (this.gameState.day > this._systemStateExpirationDay) {
            const systemStates = Object.keys(DB.SYSTEM_STATES);
            const selectedStateKey = systemStates[Math.floor(Math.random() * systemStates.length)];
            this._currentSystemState = DB.SYSTEM_STATES[selectedStateKey];
            this._systemStateExpirationDay = this.gameState.day + this._currentSystemState.duration;
        }
    }

    /**
     * Simulates one week of market price changes for all commodities at all locations.
     * Prices fluctuate based on individual volatility, a tendency to revert to a baseline average,
     * and player-driven market pressure.
     */
    evolveMarketPrices() {
        DB.MARKETS.forEach(location => {
            DB.COMMODITIES.forEach(commodity => {
                if (commodity.tier > this.gameState.player.revealedTier) return;

                const inventoryItem = this.gameState.market.inventory[location.id][commodity.id];
                const price = this.gameState.market.prices[location.id][commodity.id];
                const avg = this.gameState.market.galacticAverages[commodity.id];
                const baseline = avg;

                let volatility = GAME_RULES.DAILY_PRICE_VOLATILITY;
                let meanReversion = GAME_RULES.MEAN_REVERSION_STRENGTH;

                const commodityMods = this._currentSystemState?.modifiers?.commodity?.[commodity.id];
                if (commodityMods) {
                    if (commodityMods.volatility_mult) volatility *= commodityMods.volatility_mult;
                    if (commodityMods.mean_reversion_mult) meanReversion *= commodityMods.mean_reversion_mult;
                }

                const priceRange = commodity.basePriceRange[1] - commodity.basePriceRange[0];
                const randomFluctuation = (Math.random() - 0.5) * priceRange * volatility;
                
                let reversionEffect = (baseline - price) * meanReversion;

                if (inventoryItem.rivalArbitrage.isActive && this.gameState.day < inventoryItem.rivalArbitrage.endDay) {
                    reversionEffect = (baseline - price) * 0.20;
                } else if (inventoryItem.rivalArbitrage.isActive) {
                    inventoryItem.rivalArbitrage.isActive = false;
                }

                if (inventoryItem.hoverUntilDay > this.gameState.day) {
                    reversionEffect *= 0.1;
                } else if (inventoryItem.hoverUntilDay > 0) {
                    inventoryItem.hoverUntilDay = 0;
                }

                const pressureEffect = baseline * inventoryItem.marketPressure * -1;
                let newPrice = price + randomFluctuation + reversionEffect + pressureEffect;
                
                if (this._currentSystemState?.modifiers?.commodity?.[commodity.id]?.price) {
                    newPrice *= this._currentSystemState.modifiers.commodity[commodity.id].price;
                }
                
                this.gameState.market.prices[location.id][commodity.id] = Math.max(1, Math.round(newPrice));

                inventoryItem.marketPressure *= GAME_RULES.MARKET_PRESSURE_DECAY;
                if (Math.abs(inventoryItem.marketPressure) < 0.001) {
                    inventoryItem.marketPressure = 0;
                }
            });
            this._recordPriceHistory(location.id);
        });
    }
    
    /**
     * Simulates the weekly replenishment of commodity stock using a hybrid model.
     * Stock gradually moves towards a target influenced by player actions, with a final random fluctuation.
     */
    replenishMarketInventory() {
        DB.MARKETS.forEach(market => {
            DB.COMMODITIES.forEach(c => {
                if (c.tier > this.gameState.player.revealedTier) return;

                const inventoryItem = this.gameState.market.inventory[market.id][c.id];

                // Market Memory: Reset if untouched for 60 days.
                if (inventoryItem.lastPlayerInteractionTimestamp > 0 && (this.gameState.day - inventoryItem.lastPlayerInteractionTimestamp) > 60) {
                    inventoryItem.quantity = this._calculateBaselineStock(market, c);
                    inventoryItem.lastPlayerInteractionTimestamp = 0;
                    inventoryItem.marketPressure = 0;
                } else {
                    // Phase 1: Establish Dynamic Target Stock
                    const [minAvail, maxAvail] = c.canonicalAvailability;
                    const baseMeanStock = (minAvail + maxAvail) / 2 * (market.availabilityModifier?.[c.id] ?? 1.0);
                    
                    // Market adaptation: high player selling pressure reduces the target stock.
                    const marketAdaptationFactor = 1 - Math.min(0.5, inventoryItem.marketPressure * 0.5); // Pressure reduces target, capped at 50%
                    const targetStock = baseMeanStock * marketAdaptationFactor;

                    // Phase 2: Gradual Replenishment Towards Target
                    const difference = targetStock - inventoryItem.quantity;
                    const replenishAmount = difference * 0.15; // Move 15% towards the target each week
                    inventoryItem.quantity += replenishAmount;
                }

                // Phase 3: Apply Final Visual Fluctuation
                const fluctuationPercent = (Math.random() * 0.15 + 0.15); // Random value between 0.15 and 0.30
                const fluctuationDirection = Math.random() < 0.5 ? -1 : 1;
                const finalFluctuation = 1 + (fluctuationPercent * fluctuationDirection);
                inventoryItem.quantity *= finalFluctuation;
                
                // Apply system state modifiers if any exist.
                if (this._currentSystemState?.modifiers?.commodity?.[c.id]?.availability) {
                    inventoryItem.quantity *= this._currentSystemState.modifiers.commodity[c.id].availability;
                }
                
                inventoryItem.quantity = Math.max(0, Math.round(inventoryItem.quantity));
            });
        });
    }

    /**
     * Applies a dynamic price adjustment to a commodity based on the volume of a player's transaction.
     * @param {string} goodId - The ID of the commodity traded.
     * @param {number} quantity - The amount traded.
     * @param {string} transactionType - 'buy' or 'sell'.
     */
    applyMarketImpact(goodId, quantity, transactionType) {
        const good = DB.COMMODITIES.find(c => c.id === goodId);
        const inventoryItem = this.gameState.market.inventory[this.gameState.currentLocationId][goodId];
        
        const pressureChange = ((quantity / (good.canonicalAvailability[1] || 100)) * good.tier) / 10;
        
        if (transactionType === 'buy') {
            inventoryItem.marketPressure -= pressureChange;
        } else { // 'sell'
            inventoryItem.marketPressure += pressureChange;
        }

        inventoryItem.lastPlayerInteractionTimestamp = this.gameState.day;
    }

    /**
     * Calculates the baseline (initial or reset) stock for a commodity at a specific location.
     * @param {object} market - The market object from the database.
     * @param {object} commodity - The commodity object from the database.
     * @returns {number} The calculated baseline stock quantity.
     * @private
     */
    _calculateBaselineStock(market, commodity) {
        const [min, max] = commodity.canonicalAvailability;
        const modifier = market.availabilityModifier?.[commodity.id] ?? 1.0;
        return Math.floor(skewedRandom(min, max) * modifier);
    }

    /**
     * Records the current day's price for each commodity to its historical data log for graphing.
     * @param {string} [marketId=null] - The ID of the market to record history for. Defaults to the current location.
     * @private
     */
    _recordPriceHistory(marketId = null) {
        if (!this.gameState || !this.gameState.market) return;
        const targetMarketId = marketId || this.gameState.currentLocationId;

        if (!this.gameState.market.priceHistory[targetMarketId]) {
            this.gameState.market.priceHistory[targetMarketId] = {};
        }

        DB.COMMODITIES.forEach(good => {
            if (good.tier > this.gameState.player.revealedTier) return;
            if (!this.gameState.market.priceHistory[targetMarketId][good.id]) {
                this.gameState.market.priceHistory[targetMarketId][good.id] = [];
            }

            const history = this.gameState.market.priceHistory[targetMarketId][good.id];
            const currentPrice = this.gameState.market.prices[targetMarketId][good.id];

            const lastEntry = history[history.length - 1];
            if (lastEntry && lastEntry.day === this.gameState.day) {
                if (lastEntry.price !== currentPrice) {
                    lastEntry.price = currentPrice;
                }
            } else {
                history.push({ day: this.gameState.day, price: currentPrice });
            }

            while (history.length > GAME_RULES.PRICE_HISTORY_LENGTH) {
                history.shift();
            }
        });
    }

    /**
     * Updates the shipyard stock for all unlocked locations on a weekly basis.
     * @private
     */
    _updateShipyardStock() {
        const { player } = this.gameState;
        player.unlockedLocationIds.forEach(locationId => {
            const stock = this.gameState.market.shipyardStock[locationId];
            if (stock && stock.day === this.gameState.day) return;
            const commonShips = Object.entries(DB.SHIPS).filter(([id, ship]) => !ship.isRare && ship.saleLocationId === locationId && !player.ownedShipIds.includes(id));
            const rareShips = Object.entries(DB.SHIPS).filter(([id, ship]) => ship.isRare && ship.saleLocationId === locationId && !player.ownedShipIds.includes(id));
            const shipsForSaleIds = [...commonShips.map(entry => entry[0])];
            rareShips.forEach(([id, ship]) => {
                if (Math.random() < GAME_RULES.RARE_SHIP_CHANCE) {
                    shipsForSaleIds.push(id);
                }
            });
            this.gameState.market.shipyardStock[locationId] = {
                day: this.gameState.day,
                shipsForSale: shipsForSaleIds
            };
        });
    }
}
--- END OF FILE: ./js/services/simulation/MarketService.js ---

--- START OF FILE: ./js/services/world/TravelService.js ---
// js/services/world/TravelService.js
/**
 * @fileoverview Handles all aspects of interstellar travel, including
 * initiating trips, calculating costs, and managing the random event system.
 */
import { DB } from '../../data/database.js';
import { GAME_RULES, SCREEN_IDS, NAV_IDS, PERK_IDS, LOCATION_IDS } from '../../data/constants.js';
import { applyEffect } from '../eventEffectResolver.js';

export class TravelService {
    /**
     * @param {import('../GameState.js').GameState} gameState
     * @param {import('../UIManager.js').UIManager} uiManager
     * @param {import('./TimeService.js').TimeService} timeService
     * @param {import('../../services/LoggingService.js').Logger} logger
     * @param {import('../SimulationService.js').SimulationService} simulationServiceFacade
     */
    constructor(gameState, uiManager, timeService, logger, simulationServiceFacade) {
        this.gameState = gameState;
        this.uiManager = uiManager;
        this.timeService = timeService;
        this.logger = logger;
        this.simulationService = simulationServiceFacade;
    }

    /**
     * Initiates travel to a new location after validating fuel and other conditions.
     * @param {string} locationId - The ID of the destination market.
     */
    travelTo(locationId) {
        this.uiManager.resetMarketTransactionState();
        const { tutorials } = this.gameState;
        const { navLock } = tutorials;

        if (navLock && navLock.screenId === SCREEN_IDS.NAVIGATION && navLock.enabledElementQuery) {
            if (!navLock.enabledElementQuery.includes(`[data-location-id='${locationId}']`)) {
                return;
            }
        }

        const state = this.gameState.getState();
        if (state.isGameOver || state.pendingTravel) return;
        if (state.currentLocationId === locationId) {
            this.simulationService.setScreen(NAV_IDS.STARPORT, SCREEN_IDS.MARKET);
            return;
        }

        const activeShip = this.simulationService._getActiveShip();
        if (!activeShip) {
            this.uiManager.queueModal('event-modal', "No Active Ship", "You must have an active vessel to travel.");
            return;
        }
        const travelInfo = state.TRAVEL_DATA[state.currentLocationId][locationId];
        let requiredFuel = travelInfo.fuelCost;
        if (state.player.activePerks[PERK_IDS.NAVIGATOR]) {
            requiredFuel = Math.round(requiredFuel * DB.PERKS[PERK_IDS.NAVIGATOR].fuelMod);
        }

        if (activeShip.maxFuel < requiredFuel) {
            this.uiManager.queueModal('event-modal', "Fuel Capacity Insufficient", `Your ship's fuel tank is too small. This trip requires ${requiredFuel} fuel, but you can only hold ${activeShip.maxFuel}.`);
            return;
        }
        if (activeShip.fuel < requiredFuel) {
            this.uiManager.queueModal('event-modal', "Insufficient Fuel", `You need ${requiredFuel} fuel but only have ${Math.floor(activeShip.fuel)}.`);
            return;
        }

        const isFirstTutorialFlight = state.tutorials.activeBatchId === 'intro_missions' && state.tutorials.activeStepId === 'mission_1_6';
        if (!isFirstTutorialFlight) {
            if (this._checkForRandomEvent(locationId)) {
                return;
            }
        }

        this.initiateTravel(locationId);
    }

    /**
     * Executes the core travel logic: applies fuel costs and hull damage, advances time, and shows the animation.
     * @param {string} locationId - The destination location ID.
     * @param {object} [eventMods={}] - Modifications to travel parameters from a random event.
     */
    initiateTravel(locationId, eventMods = {}) {
        const state = this.gameState.getState();
        const fromId = state.currentLocationId;
        let travelInfo = { ...state.TRAVEL_DATA[fromId][locationId] };
        this.logger.info.player(state.day, 'TRAVEL_START', `Departing from ${fromId} to ${locationId}.`);

        if (state.player.activePerks[PERK_IDS.NAVIGATOR]) {
            travelInfo.time = Math.round(travelInfo.time * DB.PERKS[PERK_IDS.NAVIGATOR].travelTimeMod);
            travelInfo.fuelCost = Math.round(travelInfo.fuelCost * DB.PERKS[PERK_IDS.NAVIGATOR].fuelMod);
        }

        if (eventMods.travelTimeAdd) travelInfo.time += eventMods.travelTimeAdd;
        if (eventMods.travelTimeAddPercent) travelInfo.time *= (1 + eventMods.travelTimeAddPercent);
        if (eventMods.setTravelTime) travelInfo.time = eventMods.setTravelTime;
        travelInfo.time = Math.max(1, Math.round(travelInfo.time));

        const activeShip = this.simulationService._getActiveShip();
        const activeShipState = this.gameState.player.shipStates[activeShip.id];
        
        if (activeShip.fuel < travelInfo.fuelCost) {
            this.uiManager.queueModal('event-modal', "Insufficient Fuel", `Trip modifications left you without enough fuel. You need ${travelInfo.fuelCost} but only have ${Math.floor(activeShip.fuel)}.`);
            this.logger.warn('TravelService', `Travel to ${locationId} aborted due to insufficient fuel after event mods.`);
            return;
        }

        if (eventMods.forceEvent) {
            if (this._checkForRandomEvent(locationId, true)) {
                return;
            }
        }

        let travelHullDamage = travelInfo.time * GAME_RULES.HULL_DECAY_PER_TRAVEL_DAY;
        if (state.player.activePerks[PERK_IDS.NAVIGATOR]) travelHullDamage *= DB.PERKS[PERK_IDS.NAVIGATOR].hullDecayMod;
        const eventHullDamageValue = activeShip.maxHealth * ((eventMods.eventHullDamagePercent || 0) / 100);
        const totalHullDamageValue = travelHullDamage + eventHullDamageValue;
        
        activeShipState.health -= totalHullDamageValue;
        this.simulationService._checkHullWarnings(activeShip.id);

        if (activeShipState.health <= 0) {
            this._handleShipDestruction(activeShip.id);
            return;
        }
        
        activeShipState.fuel -= travelInfo.fuelCost;
        this.timeService.advanceDays(travelInfo.time);
        if (this.gameState.isGameOver) return;
        
        this.gameState.setState({ currentLocationId: locationId, pendingTravel: null });

        const fromLocation = DB.MARKETS.find(m => m.id === fromId);
        const destination = DB.MARKETS.find(m => m.id === locationId);
        const totalHullDamagePercentForDisplay = (totalHullDamageValue / activeShip.maxHealth) * 100;
        
        this.logger.info.player(this.gameState.day, 'TRAVEL_END', `Arrived at ${locationId}.`, {
            fuelUsed: travelInfo.fuelCost,
            hullDamage: totalHullDamagePercentForDisplay.toFixed(2) + '%'
        });

        const finalCallback = () => {
            if (this.gameState.tutorials.activeBatchId === 'intro_missions' && this.gameState.tutorials.activeStepId === 'mission_1_7' && locationId === LOCATION_IDS.LUNA) {
                this.simulationService.setScreen(NAV_IDS.DATA, SCREEN_IDS.MISSIONS);
            } else {
                this.simulationService.setScreen(NAV_IDS.STARPORT, SCREEN_IDS.MARKET);
            }
        };
        
        this.uiManager.showTravelAnimation(fromLocation, destination, travelInfo, totalHullDamagePercentForDisplay, finalCallback);
    }
    
    /**
     * Resumes a pending travel action after it was interrupted by an event.
     */
    resumeTravel() {
        if (!this.gameState.pendingTravel) return;
        this.logger.info.system('Game', this.gameState.day, 'TRAVEL_RESUME', 'Resuming travel after event.');
        const { destinationId, ...eventMods } = this.gameState.pendingTravel;
        this.initiateTravel(destinationId, eventMods);
    }

    /**
     * Checks for and triggers a random event based on a probability roll.
     * @param {string} destinationId
     * @param {boolean|number} [force=false]
     * @returns {boolean}
     * @private
     */
    _checkForRandomEvent(destinationId, force = false) {
        if (force === false && Math.random() > GAME_RULES.RANDOM_EVENT_CHANCE) return false;

        const activeShip = this.simulationService._getActiveShip();
        let event;

        if (typeof force === 'number') {
            event = DB.RANDOM_EVENTS[force];
        } else {
             const validEvents = DB.RANDOM_EVENTS.filter(event => 
                event.precondition(this.gameState.getState(), activeShip, this.simulationService._getActiveInventory.bind(this.simulationService))
            );
            if (validEvents.length === 0) return false;
            event = validEvents[Math.floor(Math.random() * validEvents.length)];
        }
        
        if (!event) {
            this.logger.warn('TravelService', `Debug event trigger failed for index: ${force}`);
            return false;
        }
        
        this.logger.info.system('Event', this.gameState.day, 'EVENT_TRIGGER', `Triggered random event: ${event.title}`);
        this.gameState.setState({ pendingTravel: { destinationId } });
        this.uiManager.showRandomEventModal(event, (eventId, choiceIndex) => this._resolveEventChoice(eventId, choiceIndex));
        return true;
    }

    /**
     * Resolves the player's choice in a random event and applies the outcome.
     * @param {string} eventId
     * @param {number} choiceIndex
     * @private
     */
    _resolveEventChoice(eventId, choiceIndex) {
        const event = DB.RANDOM_EVENTS.find(e => e.id === eventId);
        const choice = event.choices[choiceIndex];
        let random = Math.random();
        const chosenOutcome = choice.outcomes.find(o => (random -= o.chance) < 0) || choice.outcomes[choice.outcomes.length - 1];
    
        const effectResult = this._applyEventEffects(chosenOutcome);
    
        let description = chosenOutcome.description;
        if (effectResult && chosenOutcome.descriptions) {
            description = chosenOutcome.descriptions[effectResult.key];
            if (effectResult.amount) {
                description = description.replace('{amount}', effectResult.amount);
            }
        }
    
        this.logger.info.player(this.gameState.day, 'EVENT_CHOICE', `Chose '${choice.title}' for event '${event.title}'.`);
        this.uiManager.queueModal('event-modal', event.title, description, () => this.resumeTravel(), { buttonText: 'Continue Journey' });
    }

    /**
     * Applies a list of effects from a chosen event outcome by calling the effect resolver.
     * @param {object} outcome
     * @private
     */
    _applyEventEffects(outcome) {
        let result = null;
        outcome.effects.forEach(effect => {
            const effectResult = applyEffect(this.gameState, this.simulationService, effect, outcome);
            if (effectResult) {
                result = effectResult;
            }
        });
        this.gameState.setState({});
        return result;
    }

    /**
     * Handles the destruction of a player ship and the potential game over condition.
     * @param {string} shipId
     * @private
     */
    _handleShipDestruction(shipId) {
        const shipName = DB.SHIPS[shipId].name;
        this.logger.error('TravelService', `Ship ${shipName} was destroyed.`);
        this.gameState.player.ownedShipIds = this.gameState.player.ownedShipIds.filter(id => id !== shipId);
        delete this.gameState.player.shipStates[shipId];
        delete this.gameState.player.inventories[shipId];

        if (this.gameState.player.ownedShipIds.length === 0) {
            this.simulationService._gameOver(`Your last ship, the ${shipName}, was destroyed. Your trading career ends here.`);
        } else {
            this.gameState.player.activeShipId = this.gameState.player.ownedShipIds[0];
            const newShipName = DB.SHIPS[this.gameState.player.activeShipId].name;
            const message = `The ${shipName} suffered a catastrophic hull breach and was destroyed. All cargo was lost.<br><br>You now command your backup vessel, the ${newShipName}.`;
            this.uiManager.queueModal('event-modal', 'Vessel Lost', message);
        }
        this.gameState.setState({});
    }
}
--- END OF FILE: ./js/services/world/TravelService.js ---

--- START OF FILE: ./js/services/world/TimeService.js ---
// js/services/world/TimeService.js
/**
 * @fileoverview Responsible for advancing the game clock and triggering all
 * time-based events like birthdays, debt interest, and market replenishment.
 */
import { DB } from '../../data/database.js';
import { GAME_RULES, WEALTH_MILESTONES } from '../../data/constants.js';
import { formatCredits } from '../../utils.js';

export class TimeService {
    /**
     * @param {import('../GameState.js').GameState} gameState
     * @param {import('../simulation/MarketService.js').MarketService} marketService
     * @param {import('../UIManager.js').UIManager} uiManager
     * @param {import('../../services/LoggingService.js').Logger} logger
     */
    constructor(gameState, marketService, uiManager, logger) {
        this.gameState = gameState;
        this.marketService = marketService;
        this.uiManager = uiManager;
        this.logger = logger;
        this.simulationService = null; // To be injected to avoid circular deps
    }

    /**
     * Advances game time by a specified number of days, triggering daily, weekly, and monthly events.
     * @param {number} days - The integer number of days to advance.
     */
    advanceDays(days) {
        this.logger.group(`[System] Advancing time by ${days} day(s) from Day ${this.gameState.day}`);
        for (let i = 0; i < days; i++) {
            if (this.gameState.isGameOver) {
                this.logger.warn('TimeService', 'Advance days aborted: Game is over.');
                this.logger.groupEnd();
                return;
            }
            this.gameState.day++;

            const dayOfYear = (this.gameState.day - 1) % 365;
            const currentYear = DB.DATE_CONFIG.START_YEAR + Math.floor((this.gameState.day - 1) / 365);

            if (dayOfYear === 11 && currentYear > this.gameState.player.lastBirthdayYear) {
                this.gameState.player.playerAge++;
                this.gameState.player.birthdayProfitBonus += 0.01;
                this.gameState.player.lastBirthdayYear = currentYear;
                this.uiManager.triggerEffect('systemSurge', { theme: 'blue', text: `AGE ${this.gameState.player.playerAge}` });
                this.logger.info.state(this.gameState.day, 'BIRTHDAY', `Player is now age ${this.gameState.player.playerAge}. Profit bonus increased.`);
            }

            this._checkAgeEvents();
            this.marketService.evolveMarketPrices();

            if ((this.gameState.day - this.gameState.lastMarketUpdateDay) >= 7) {
                this.marketService.checkForSystemStateChange();
                this.marketService.replenishMarketInventory();
                this.marketService._updateShipyardStock(); // Correctly call the method on MarketService
                this.gameState.lastMarketUpdateDay = this.gameState.day;
            }

            if (this.gameState.intel.active && this.gameState.day > this.gameState.intel.active.endDay) {
                this.logger.info.system('Intel', this.gameState.day, 'EXPIRED', 'Active intel has expired.');
                this.gameState.intel.active = null;
            }
            
            this.gameState.player.ownedShipIds.forEach(shipId => {
                if (shipId !== this.gameState.player.activeShipId) {
                    const ship = DB.SHIPS[shipId];
                    const repairAmount = ship.maxHealth * GAME_RULES.PASSIVE_REPAIR_RATE;
                    this.gameState.player.shipStates[shipId].health = Math.min(ship.maxHealth, this.gameState.player.shipStates[shipId].health + repairAmount);
                }
            });

            if (this.gameState.player.debt > 0 && (this.gameState.day - this.gameState.lastInterestChargeDay) >= GAME_RULES.INTEREST_INTERVAL) {
                const interest = this.gameState.player.monthlyInterestAmount;
                this.gameState.player.debt += interest;
                this.simulationService._logTransaction('loan', interest, 'Monthly interest charge');
                this.logger.info.system('Finance', this.gameState.day, 'INTEREST', `Charged ${formatCredits(interest)} interest on debt.`);
                this.gameState.lastInterestChargeDay = this.gameState.day;
            }
        }
        
        this.logger.groupEnd();
        this.gameState.setState({});
    }

    /**
     * Checks for and triggers age-based narrative events based on game progression.
     * @private
     */
    _checkAgeEvents() {
        DB.AGE_EVENTS.forEach(event => {
            if (this.gameState.player.seenEvents.includes(event.id)) return;
            if ((event.trigger.day && this.gameState.day >= event.trigger.day) || (event.trigger.credits && this.gameState.player.credits >= event.trigger.credits)) {
                this.gameState.player.seenEvents.push(event.id);
                this.logger.info.state(this.gameState.day, 'AGE_EVENT', `Triggered age event: ${event.title}`);
                this.uiManager.showAgeEventModal(event, (choice) => this.simulationService._applyPerk(choice));
            }
        });
    }

    /**
     * Checks if the player's wealth has reached a new milestone, revealing the next tier of commodities.
     * @private
     */
    _checkMilestones() {
        const { credits, revealedTier } = this.gameState.player;
        let currentTier = revealedTier;
        let nextMilestone = WEALTH_MILESTONES.find(m => m.revealsTier === currentTier + 1);

        while (nextMilestone && credits >= nextMilestone.threshold) {
            this.gameState.player.revealedTier = nextMilestone.revealsTier;
            this.logger.info.state(this.gameState.day, 'MILESTONE', `Unlocked Tier ${nextMilestone.revealsTier} commodities.`);
            
            this.uiManager.triggerEffect('systemSurge', { theme: 'purple', text: `TIER ${nextMilestone.revealsTier} UNLOCKED` });
            
            currentTier = nextMilestone.revealsTier;
            nextMilestone = WEALTH_MILESTONES.find(m => m.revealsTier === currentTier + 1);
        }

        if (this.gameState.player.revealedTier !== revealedTier) {
            this.gameState.setState({});
        }
    }

    /**
     * Applies a monthly credit garnishment if the player's loan is delinquent.
     * @private
     */
    _applyGarnishment() {
        const { player, day } = this.gameState;
        if (player.debt > 0 && player.loanStartDate && (day - player.loanStartDate) >= GAME_RULES.LOAN_GARNISHMENT_DAYS) {
            const garnishedAmount = Math.floor(player.credits * GAME_RULES.LOAN_GARNISHMENT_PERCENT);
            if (garnishedAmount > 0) {
                player.credits -= garnishedAmount;
                this.simulationService._logTransaction('debt', -garnishedAmount, 'Monthly credit garnishment');
            }

            if (!player.seenGarnishmentWarning) {
                const msg = "Your loan is delinquent. Your lender is now garnishing 14% of your credits monthly until the debt is paid.";
                this.uiManager.queueModal('event-modal', "Credit Garnishment Notice", msg, null, { buttonClass: 'bg-red-800/80' });
                player.seenGarnishmentWarning = true;
                this.logger.warn('Finance', `Loan delinquent. Garnishment of ${GAME_RULES.LOAN_GARNISHMENT_PERCENT * 100}% initiated.`);
            }
        }
    }
}
--- END OF FILE: ./js/services/world/TimeService.js ---

--- START OF FILE: ./js/services/game/IntroService.js ---
// js/services/game/IntroService.js
/**
 * @fileoverview Manages the new game introduction sequence, from the initial
 * lore modals to the final tutorial kickoff.
 */
import { DB } from '../../data/database.js';
import { formatCredits } from '../../utils.js';
import { NAV_IDS, SCREEN_IDS, SHIP_IDS } from '../../data/constants.js';

export class IntroService {
    /**
     * @param {import('../GameState.js').GameState} gameState
     * @param {import('../UIManager.js').UIManager} uiManager
     * @param {import('../../services/LoggingService.js').Logger} logger
     * @param {import('../SimulationService.js').SimulationService} simulationServiceFacade
     */
    constructor(gameState, uiManager, logger, simulationServiceFacade) {
        this.gameState = gameState;
        this.uiManager = uiManager;
        this.logger = logger;
        this.simulationService = simulationServiceFacade; // Renamed to avoid confusion
    }

    /**
     * Kicks off the interactive new game introduction sequence.
     */
    start() {
        if (!this.gameState.introSequenceActive) return;
        this.logger.info.state(this.gameState.day, 'INTRO_START', 'Starting new game introduction sequence.');
        // Set the initial state for the intro: No ship, ready for the tutorial purchase.
        this.gameState.player.ownedShipIds = [];
        this.gameState.player.activeShipId = null;
        this.gameState.player.shipStates = {};
        this.gameState.player.inventories = {};
        this.gameState.player.introStep = 0;
        this._showNextModal();
    }

    /**
     * Handles all delegated click events during the intro sequence to manage its flow.
     * @param {Event} e - The click event object.
     */
    handleIntroClick(e) {
        const button = e.target.closest('button');
        if (!button) return;
        const targetId = button.id;
        
        if (targetId === 'intro-next-btn') {
            button.disabled = true;
            this._showNextModal();
        } else if (targetId === 'intro-submit-btn') {
            button.disabled = true;
            const input = document.getElementById('signature-input');
            let playerName = input.value.trim().replace(/[^a-zA-Z0-9 ]/g, '');
            if (!playerName) {
                this.uiManager.queueModal('event-modal', 'Invalid Signature', "The Merchant's Guild requires a name on the contract. Please provide your legal mark.");
                button.disabled = false;
                this._showNextModal(); // Re-show signature modal.
            } else {
                this.gameState.player.name = playerName;
                this.gameState.player.debt = 25000;
                this.gameState.player.loanStartDate = this.gameState.day;
                this.gameState.player.monthlyInterestAmount = 390;

                this.logger.info.state(this.gameState.day, 'LOAN_ACCEPTED', `Player ${playerName} accepted Guild loan.`, {
                    debt: 25000,
                    name: playerName
                });
                this._startProcessingSequence();
            }
        }
    }

    /**
     * Continues the intro sequence after a tutorial batch is completed.
     * @param {string} completedBatchId - The ID of the tutorial batch that just finished.
     */
    continueAfterTutorial(completedBatchId) {
        if (completedBatchId === 'intro_hangar') {
            this.simulationService.setScreen(NAV_IDS.DATA, SCREEN_IDS.FINANCE);
            this.simulationService.tutorialService.checkState({ type: 'ACTION', action: 'INTRO_START_FINANCE' });
        } else if (completedBatchId === 'intro_finance') {
            this._end();
        }
    }

    /**
     * Displays the next modal in the introduction sequence.
     * @private
     */
    _showNextModal() {
        const step = DB.INTRO_SEQUENCE_V1.modals[this.gameState.player.introStep];
        if (!step) {
            this._end();
            return;
        }

        const options = {
            buttonClass: step.buttonClass,
            contentClass: step.contentClass,
        };
        let modalId = 'event-modal';

        if (step.id === 'charter' || step.id === 'signature') {
            modalId = `${step.id}-modal`;
            options.customSetup = (modal, closeHandler) => { this._setupInteractiveModal(modal, step, closeHandler) };
        } else {
            options.customSetup = (modal, closeHandler) => {
                const btnContainer = modal.querySelector('#event-button-container');
                if (!btnContainer) return;
                btnContainer.innerHTML = '';

                const button = document.createElement('button');
                button.className = 'btn px-6 py-2';
                if(step.buttonClass) button.classList.add(step.buttonClass);
                button.id = 'intro-next-btn';
                button.innerHTML = step.buttonText;
                button.onclick = (e) => {
                    e.target.disabled = true;
                    closeHandler();
                };
                btnContainer.appendChild(button);
            };
        }

        this.uiManager.queueModal(modalId, step.title, step.description, () => this.gameState.player.introStep++, options);
    }

    /**
     * Performs custom setup for interactive modals in the intro.
     * @param {HTMLElement} modal
     * @param {object} step
     * @param {function} closeHandler
     * @private
     */
    _setupInteractiveModal(modal, step, closeHandler) {
        const buttonContainer = modal.querySelector(`#${step.id}-button-container`);
        buttonContainer.innerHTML = '';
        const button = document.createElement('button');
        button.className = 'btn px-6 py-2';
        button.innerHTML = step.buttonText;
        button.onclick = (e) => {
            e.target.disabled = true;
            closeHandler();
        };
        buttonContainer.appendChild(button);

        if (step.id === 'signature') {
            const input = modal.querySelector('#signature-input');
            input.value = '';
            button.id = 'intro-submit-btn';
            button.disabled = true;
            
            button.onclick = closeHandler;

            input.oninput = () => {
                button.disabled = input.value.trim() === '';
            };
        } else {
            button.id = 'intro-next-btn';
        }
    }

    /**
     * Manages the animated sequence for loan processing.
     * @private
     */
    _startProcessingSequence() {
        const showApprovalModal = () => {
            const title = 'Loan Approved';
            const description = `Dear ${this.gameState.player.name},<br><br>Your line of credit has been <b>approved</b>.<br><br><span class="credits-text-pulsing">⌬ 25,000</span> is ready to transfer to your account.`;
            const hangarTransition = (event) => {
                const button = event.target;
                if(button) button.disabled = true;
                
                this.uiManager.createFloatingText(`+${formatCredits(25000, false)}`, event.clientX, event.clientY, '#34d399');
                
                this.gameState.player.credits += 25000;
                this.logger.info.player(this.gameState.day, 'CREDITS_TRANSFER', 'Accepted loan transfer of ⌬25,000');

                setTimeout(() => {
                    this.uiManager.showGameContainer();
                    this.uiManager.render(this.gameState.getState());
                    this.simulationService.setScreen(NAV_IDS.STARPORT, SCREEN_IDS.HANGAR);
                    this.simulationService.tutorialService.checkState({ type: 'ACTION', action: 'INTRO_START_HANGAR' });
                }, 2000);
            };

            this.uiManager.queueModal('event-modal', title, description, null, {
                contentClass: 'text-center',
                customSetup: (modal, closeHandler) => {
                    modal.querySelector('.modal-content').classList.add('modal-theme-admin');
                    const btnContainer = modal.querySelector('#event-button-container');

                    btnContainer.innerHTML = '';
                    const button = document.createElement('button');
                    button.className = 'btn px-6 py-2';
                    button.innerHTML = 'Accept Transfer';
                    button.onclick = (event) => {
                        hangarTransition(event);
                        closeHandler();
                    };
                    btnContainer.appendChild(button);
                }
            });
        };
        
        this.uiManager.showProcessingAnimation(this.gameState.player.name, showApprovalModal);
    }

    /**
     * Finalizes the intro sequence.
     * @private
     */
    _end() {
        this.gameState.introSequenceActive = false;
        this.logger.info.state(this.gameState.day, 'INTRO_END', 'Introduction sequence complete.');
        const finalStep = DB.INTRO_SEQUENCE_V1.modals.find(s => s.id === 'final');
        const shipName = DB.SHIPS[this.gameState.player.activeShipId].name;
        const buttonText = finalStep.buttonText.replace('{shipName}', shipName);
    
        this.gameState.tutorials.navLock = { navId: NAV_IDS.DATA, screenId: SCREEN_IDS.FINANCE };
    
        this.uiManager.queueModal('event-modal', finalStep.title, finalStep.description, () => {
             this.simulationService.setScreen(NAV_IDS.DATA, SCREEN_IDS.MISSIONS);
             this.simulationService.tutorialService.checkState({ type: 'ACTION', action: 'INTRO_START_MISSIONS' });
        }, { buttonText: buttonText });
        
        this.uiManager.render(this.gameState.getState());
    }
}
--- END OF FILE: ./js/services/game/IntroService.js ---

--- START OF FILE: ./js/services/SimulationService.js ---
// js/services/SimulationService.js
/**
 * @fileoverview This file contains the SimulationService class, which acts as the core game engine
 * facade. It instantiates all specialized game logic services and delegates calls to them,
 * providing a single, clean API for the EventManager.
 */
import { DB } from '../data/database.js';
import { calculateInventoryUsed, formatCredits } from '../utils.js';
import { GAME_RULES, SAVE_KEY, SHIP_IDS, PERK_IDS } from '../data/constants.js';
import { MarketService } from './simulation/MarketService.js';
import { IntroService } from './game/IntroService.js';
import { PlayerActionService } from './player/PlayerActionService.js';
import { TimeService } from './world/TimeService.js';
import { TravelService } from './world/TravelService.js';

/**
 * @class SimulationService
 * @description Manages the core game loop, player actions, and state changes by delegating to specialized services.
 */
export class SimulationService {
    /**
     * @param {import('./GameState.js').GameState} gameState - The central state object.
     * @param {import('./UIManager.js').UIManager} uiManager - The UI rendering service.
     * @param {import('./LoggingService.js').Logger} logger - The logging utility.
     */
    constructor(gameState, uiManager, logger) {
        this.gameState = gameState;
        this.uiManager = uiManager;
        this.logger = logger;
        this.tutorialService = null; // Injected post-instantiation.
        this.missionService = null;  // Injected post-instantiation.

        // Instantiate all services
        this.marketService = new MarketService(gameState);
        this.timeService = new TimeService(gameState, this.marketService, uiManager, logger);
        this.travelService = new TravelService(gameState, uiManager, this.timeService, logger, this);
        this.introService = new IntroService(gameState, uiManager, logger, this);
        this.playerActionService = new PlayerActionService(gameState, uiManager, null, this.marketService, this.timeService, logger, this);

        // Inject cross-dependencies that couldn't be set in constructors
        this.timeService.simulationService = this;
    }

    /**
     * Injects the TutorialService after all services have been instantiated.
     * @param {import('./TutorialService.js').TutorialService} tutorialService
     */
    setTutorialService(tutorialService) {
        this.tutorialService = tutorialService;
    }

    /**
     * Injects the MissionService after all services have been instantiated.
     * @param {import('./MissionService.js').MissionService} missionService
     */
    setMissionService(missionService) {
        this.missionService = missionService;
        this.playerActionService.missionService = missionService;
    }

    // --- FACADE METHODS ---
    // These methods provide a clean API to the EventManager and other high-level services,
    // delegating the actual work to the specialized services.

    // IntroService Delegation
    startIntroSequence() { this.introService.start(); }
    handleIntroClick(e) { this.introService.handleIntroClick(e); }
    _continueIntroSequence(batchId) { this.introService.continueAfterTutorial(batchId); }
    
    // PlayerActionService Delegation
    buyItem(goodId, quantity) { return this.playerActionService.buyItem(goodId, quantity); }
    sellItem(goodId, quantity) { return this.playerActionService.sellItem(goodId, quantity); }
    initiateShipTransactionAnimation(shipId, action, event) { this.playerActionService.initiateShipTransactionAnimation(shipId, action, event); }
    buyShip(shipId, event) { return this.playerActionService.buyShip(shipId, event); }
    sellShip(shipId, event) { return this.playerActionService.sellShip(shipId, event); }
    setActiveShip(shipId) { this.playerActionService.setActiveShip(shipId); }
    payOffDebt() { this.playerActionService.payOffDebt(); }
    takeLoan(loanData) { this.playerActionService.takeLoan(loanData); }
    purchaseLicense(licenseId) { return this.playerActionService.purchaseLicense(licenseId); }
    purchaseIntel(cost) { this.playerActionService.purchaseIntel(cost); }
    refuelTick() { return this.playerActionService.refuelTick(); }
    repairTick() { return this.playerActionService.repairTick(); }
    
    // TravelService Delegation
    travelTo(locationId) { this.travelService.travelTo(locationId); }
    resumeTravel() { this.travelService.resumeTravel(); }

    // --- CORE & SHARED METHODS ---
    // These methods remain in the facade because they are either simple state setters
    // or are helpers required by multiple services.

    /**
     * Sets the active navigation tab and screen.
     * @param {string} navId
     * @param {string} screenId
     */
    setScreen(navId, screenId) {
        const newLastActive = { ...this.gameState.lastActiveScreen, [navId]: screenId };
        this.gameState.setState({ 
            activeNav: navId, 
            activeScreen: screenId,
            lastActiveScreen: newLastActive 
        });
        if (this.tutorialService) {
            this.tutorialService.checkState({ type: 'SCREEN_LOAD', screenId: screenId });
        }
    }

    /**
     * Sets the hangar/shipyard toggle state.
     * @param {string} mode - 'hangar' or 'shipyard'.
     */
    setHangarShipyardMode(mode) {
        if (this.gameState.uiState.hangarShipyardToggleState !== mode) {
            this.gameState.uiState.hangarShipyardToggleState = mode;
            this.gameState.setState({});
        }
    }
    
    /**
     * Updates the active index for the hangar or shipyard carousel.
     * @param {number} index
     * @param {string} mode
     */
    setHangarCarouselIndex(index, mode) {
        if (mode === 'hangar') {
            this.gameState.uiState.hangarActiveIndex = index;
        } else {
            this.gameState.uiState.shipyardActiveIndex = index;
        }
        this.gameState.setState({});
    }

    /**
     * Cycles the hangar/shipyard carousel.
     * @param {string} direction - 'next' or 'prev'.
     */
    cycleHangarCarousel(direction) {
        const { uiState, player } = this.gameState;
        const isHangarMode = uiState.hangarShipyardToggleState === 'hangar';
        const shipList = isHangarMode ? player.ownedShipIds : this._getShipyardInventory().map(([id]) => id);
        
        if (shipList.length <= 1) return;

        let currentIndex = isHangarMode ? (uiState.hangarActiveIndex || 0) : (uiState.shipyardActiveIndex || 0);

        if (direction === 'next') {
            currentIndex = (currentIndex + 1) % shipList.length;
        } else {
            currentIndex = (currentIndex - 1 + shipList.length) % shipList.length;
        }

        this.setHangarCarouselIndex(currentIndex, isHangarMode ? 'hangar' : 'shipyard');
    }

    /**
     * Ends the game and displays a final message.
     * @param {string} message
     * @private
     */
    _gameOver(message) {
        this.logger.info.state(this.gameState.day, 'GAME_OVER', message);
        this.gameState.setState({ isGameOver: true });
        this.uiManager.queueModal('event-modal', "Game Over", message, () => {
            localStorage.removeItem(SAVE_KEY);
            window.location.reload();
        }, { buttonText: 'Restart' });
    }

    // --- HELPER & PRIVATE METHODS (SHARED) ---
    // These are kept here to be accessible by the specialized services that need them.

    addShipToHangar(shipId) {
        const ship = DB.SHIPS[shipId];
        if (!ship) return;
        this.gameState.player.ownedShipIds.push(shipId);
        this.gameState.player.shipStates[shipId] = { health: ship.maxHealth, fuel: ship.maxFuel, hullAlerts: { one: false, two: false } };
        if (!this.gameState.player.inventories[shipId]) {
            this.gameState.player.inventories[shipId] = {};
            DB.COMMODITIES.forEach(c => {
                this.gameState.player.inventories[shipId][c.id] = { quantity: 0, avgCost: 0 };
            });
        }
    }

    _applyPerk(choice) {
        this.logger.info.player(this.gameState.day, 'PERK_APPLIED', `Gained perk: ${choice.title}`);
        if (choice.perkId) this.gameState.player.activePerks[choice.perkId] = true;
        if (choice.playerTitle) this.gameState.player.playerTitle = choice.playerTitle;
        if (choice.perkId === PERK_IDS.MERCHANT_GUILD_SHIP) {
            this.addShipToHangar(SHIP_IDS.STALWART);
            this.uiManager.queueModal('event-modal', 'Vessel Delivered', `The Merchant's Guild has delivered a new ${DB.SHIPS[SHIP_IDS.STALWART].name} to your hangar.`);
        }
        this.gameState.setState({});
    }
    
    _getActiveShip() {
        const state = this.gameState;
        const activeId = state.player.activeShipId;
        if (!activeId) return null;
        return { id: activeId, ...DB.SHIPS[activeId], ...state.player.shipStates[activeId] };
    }

    _getActiveInventory() {
        if (!this.gameState.player.activeShipId) return null;
        return this.gameState.player.inventories[this.gameState.player.activeShipId];
    }
    
    _checkHullWarnings(shipId) {
        const shipState = this.gameState.player.shipStates[shipId];
        const shipStatic = DB.SHIPS[shipId];
        const healthPct = (shipState.health / shipStatic.maxHealth) * 100;
        if (healthPct <= 15 && !shipState.hullAlerts.two) { shipState.hullAlerts.two = true; } 
        else if (healthPct <= 30 && !shipState.hullAlerts.one) { shipState.hullAlerts.one = true; }
        if (healthPct > 30) shipState.hullAlerts.one = false;
        if (healthPct > 15) shipState.hullAlerts.two = false;
    }

    _logTransaction(type, amount, description) {
        this.gameState.player.financeLog.push({ 
            day: this.gameState.day,
            type: type, 
            amount: amount,
            balance: this.gameState.player.credits,
            description: description
        });
    }

    _logConsolidatedTrade(goodName, quantity, transactionValue) {
        const log = this.gameState.player.financeLog;
        const isBuy = transactionValue < 0;
        const actionWord = isBuy ? 'Bought' : 'Sold';
        const existingEntry = log.find(entry => 
            entry.day === this.gameState.day &&
            entry.type === 'trade' &&
            entry.description.startsWith(`${actionWord}`) &&
            entry.description.endsWith(` ${goodName}`) &&
            ((isBuy && entry.amount < 0) || (!isBuy && entry.amount > 0))
        );
        if (existingEntry) {
            existingEntry.amount += transactionValue;
            existingEntry.balance = this.gameState.player.credits;
            const match = existingEntry.description.match(/\s(\d+)x\s/);
            if (match) {
                const currentQty = parseInt(match[1], 10);
                existingEntry.description = `${actionWord} ${currentQty + quantity}x ${goodName}`;
            }
        } else {
            this._logTransaction('trade', transactionValue, `${actionWord} ${quantity}x ${goodName}`);
        }
    }

    _logConsolidatedTransaction(type, amount, description) {
        const log = this.gameState.player.financeLog;
        const lastEntry = log.length > 0 ? log[log.length - 1] : null;
        if (lastEntry && lastEntry.day === this.gameState.day && lastEntry.type === type) {
            lastEntry.amount += amount;
            lastEntry.balance = this.gameState.player.credits;
        } else {
            this._logTransaction(type, amount, description);
        }
    }

    _getShipyardInventory() {
        const { tutorials, player, currentLocationId, market } = this.gameState;
        if (tutorials.activeBatchId === 'intro_hangar') {
            return player.ownedShipIds.length > 0 ? [] : [SHIP_IDS.WANDERER, SHIP_IDS.STALWART, SHIP_IDS.MULE].map(id => [id, DB.SHIPS[id]]);
        } else {
            const shipsForSaleIds = market.shipyardStock[currentLocationId]?.shipsForSale || [];
            return shipsForSaleIds.map(id => [id, DB.SHIPS[id]]).filter(([id]) => !player.ownedShipIds.includes(id));
        }
    }

    _grantRewards(rewards, sourceName) {
        rewards.forEach(reward => {
            if (reward.type === 'credits') {
                this.gameState.player.credits += reward.amount;
                this._logTransaction('mission', reward.amount, `Reward: ${sourceName}`);
                this.uiManager.createFloatingText(`+${formatCredits(reward.amount, false)}`, window.innerWidth / 2, window.innerHeight / 2, '#34d399');
            }
            if (reward.type === 'license') {
                if (!this.gameState.player.unlockedLicenseIds.includes(reward.licenseId)) {
                    this.gameState.player.unlockedLicenseIds.push(reward.licenseId);
                    const license = DB.LICENSES[reward.licenseId];
                    this.uiManager.triggerEffect('systemSurge', { theme: 'tan' });
                    this.logger.info.player(this.gameState.day, 'LICENSE_GRANTED', `Received ${license.name}.`);
                }
            }
        });
    }
    
    grantMissionCargo(missionId) {
        const mission = DB.MISSIONS[missionId];
        if (!mission || !mission.providedCargo) return;
        const inventory = this._getActiveInventory();
        if (!inventory) {
            this.logger.error('SimulationService', 'Cannot grant mission cargo: No active inventory found.');
            return;
        }
        mission.providedCargo.forEach(cargo => {
            if (!inventory[cargo.goodId]) {
                inventory[cargo.goodId] = { quantity: 0, avgCost: 0 };
            }
            inventory[cargo.goodId].quantity += cargo.quantity;
            this.logger.info.player(this.gameState.day, 'CARGO_GRANT', `Received ${cargo.quantity}x ${DB.COMMODITIES.find(c=>c.id === cargo.goodId).name} from ${mission.name}.`);
        });
        if (this.missionService) {
            this.missionService.checkTriggers();
        }
    }
}
--- END OF FILE: ./js/services/SimulationService.js ---

--- START OF FILE: ./js/services/event-effects/effectAdriftPassenger.js ---
// js/services/event-effects/effectAdriftPassenger.js
/**
 * @fileoverview This file contains the specific logic for resolving the "Adrift Passenger"
 * random event outcome. It demonstrates a conditional effect that changes based on the
 * player's current cargo space and debt status.
 */
import { formatCredits, calculateInventoryUsed } from '../../utils.js';
import { COMMODITY_IDS } from '../../data/constants.js';
import { DB } from '../../data/database.js';

/**
 * @typedef {import('../../services/GameState.js').GameState} GameState
 * @typedef {import('../../services/SimulationService.js').SimulationService} SimulationService
 */

/**
 * Resolves the "Adrift Passenger" event outcome where the player gives them a fuel cell.
 * The reward is conditional:
 * 1. If the player has enough cargo space, they receive Cybernetics.
 * 2. If not, and they have debt, the passenger pays off a portion of it.
 * 3. If they have no cargo space and no debt, they receive credits instead.
 *
 * @param {GameState} gameState - The mutable game state object.
 * @param {SimulationService} simulationService - The simulation service instance, used here to log transactions.
 * @param {object} outcome - The chosen outcome object from the database.
 * @returns {object} An object containing a `key` to select the correct description and a dynamic `amount` for formatting.
 */
export function resolveAdriftPassenger(gameState, simulationService, outcome) {
    const ship = simulationService._getActiveShip();
    const shipState = gameState.player.shipStates[ship.id];
    const inventory = simulationService._getActiveInventory();

    // The cost of the choice is paid first.
    shipState.fuel = Math.max(0, shipState.fuel - 30);

    // Ensure the awarded commodity exists in the inventory before attempting to modify it.
    if (!inventory[COMMODITY_IDS.CYBERNETICS]) {
        inventory[COMMODITY_IDS.CYBERNETICS] = { quantity: 0, avgCost: 0 };
    }

    // Determine the reward based on player's current state.
    if (calculateInventoryUsed(inventory) + 40 <= ship.cargoCapacity) {
        inventory[COMMODITY_IDS.CYBERNETICS].quantity += 40;
        return { key: 'reward_cybernetics' };
    } else if (gameState.player.debt > 0) {
        const paid = Math.floor(gameState.player.debt * 0.20);
        gameState.player.debt -= paid;
        simulationService._logTransaction('event', paid, 'Passenger paid off debt');
        return { key: 'reward_debt_paid', amount: formatCredits(paid) };
    } else {
        const credits = Math.floor(gameState.player.credits * 0.05);
        gameState.player.credits += credits;
        simulationService._logTransaction('event', credits, 'Passenger payment');
        return { key: 'reward_credits', amount: formatCredits(credits) };
    }
}
--- END OF FILE: ./js/services/event-effects/effectAdriftPassenger.js ---

--- START OF FILE: ./js/services/event-effects/effectSpaceRace.js ---
// js/services/event-effects/effectSpaceRace.js
/**
 * @fileoverview Contains the logic for resolving the "Space Race" random event outcome.
 * This effect calculates a wager, determines a win/loss result based on ship class,
 * and modifies the outcome description to reflect the result.
 */
import { formatCredits } from '../../utils.js';

/**
 * Resolves the "Space Race" event by calculating a wager and determining the winner.
 * The win chance is dependent on the player's active ship class.
 *
 * @param {import('../../services/GameState.js').GameState} gameState - The mutable game state object.
 * @param {import('../../services/SimulationService.js').SimulationService} simulationService - The simulation service instance.
 * @param {object} effectData - The raw effect data, containing `wagerPercentage` and `winChance` map.
 * @param {object} outcome - The chosen outcome object from the database. Its `description` property will be overwritten by this function.
 */
export function resolveSpaceRace(gameState, simulationService, effectData, outcome) {
    const ship = simulationService._getActiveShip();
    const wager = Math.floor(gameState.player.credits * effectData.wagerPercentage);
    const winChance = effectData.winChance[ship.class] || 0.40; // Default chance if class not found.

    if (Math.random() < winChance) {
        // Player wins the race.
        gameState.player.credits += wager;
        simulationService._logTransaction('event', wager, 'Won space race wager');
        outcome.description = `Your Class ${ship.class} ship wins! You gain <span class="hl-green">${formatCredits(wager)}</span>.`;
    } else {
        // Player loses the race.
        gameState.player.credits -= wager;
        simulationService._logTransaction('event', -wager, 'Lost space race wager');
        outcome.description = `The luxury ship was too fast. You lose <span class="hl-red">${formatCredits(wager)}</span>.`;
    }
}
--- END OF FILE: ./js/services/event-effects/effectSpaceRace.js ---

--- START OF FILE: ./js/services/EventManager.js ---
// js/services/EventManager.js
/**
 * @fileoverview This file contains the EventManager class, which is responsible for handling all user input
 * for the application. It binds event listeners and delegates the logic to specialized handler modules,
 * acting as the primary bridge between the UI and the game's logic.
 */
import { NAV_IDS, SCREEN_IDS } from '../data/constants.js';

// Import all specialized event handlers
import { ActionClickHandler } from './handlers/ActionClickHandler.js';
import { MarketEventHandler } from './handlers/MarketEventHandler.js';
import { HoldEventHandler } from './handlers/HoldEventHandler.js';
import { CarouselEventHandler } from './handlers/CarouselEventHandler.js';
import { TooltipHandler } from './handlers/TooltipHandler.js';

/**
 * @class EventManager
 * @description Listens for and processes all user inputs, delegating actions to the appropriate services.
 */
export class EventManager {
    /**
     * @param {import('./GameState.js').GameState} gameState The central game state object.
     * @param {import('./SimulationService.js').SimulationService} simulationService The core game logic engine.
     * @param {import('./UIManager.js').UIManager} uiManager The UI rendering service.
     * @param {import('./TutorialService.js').TutorialService} tutorialService The tutorial management service.
     * @param {import('./DebugService.js').DebugService} [debugService=null] The debugging service.
     * @param {import('./LoggingService.js').Logger} logger The logging utility.
     */
    constructor(gameState, simulationService, uiManager, tutorialService, debugService = null, logger) {
        this.gameState = gameState;
        this.simulationService = simulationService;
        this.uiManager = uiManager;
        this.tutorialService = tutorialService;
        this.debugService = debugService;
        this.logger = logger;

        // Instantiate all specialized handlers
        this.actionClickHandler = new ActionClickHandler(gameState, simulationService, uiManager, tutorialService);
        this.marketEventHandler = new MarketEventHandler(gameState, simulationService, uiManager);
        this.holdEventHandler = new HoldEventHandler(gameState, simulationService, uiManager);
        this.carouselEventHandler = new CarouselEventHandler(gameState, simulationService);
        this.tooltipHandler = new TooltipHandler(gameState, uiManager);
    }

    /**
     * Binds all necessary global event listeners to the document body.
     */
    bindEvents() {
        document.body.addEventListener('click', (e) => this._handleClick(e));
        document.body.addEventListener('dblclick', (e) => e.preventDefault());
        document.body.addEventListener('mouseover', (e) => this.tooltipHandler.handleMouseOver(e));
        document.body.addEventListener('mouseout', (e) => this.tooltipHandler.handleMouseOut(e));
        document.addEventListener('keydown', (e) => this._handleKeyDown(e));
        document.body.addEventListener('input', (e) => this.marketEventHandler.handleInput(e));

        document.body.addEventListener('contextmenu', (e) => e.preventDefault());

        document.body.addEventListener('wheel', (e) => {
            if (e.target.closest('.carousel-container')) {
                e.preventDefault();
                this.carouselEventHandler.handleWheel(e);
            }
        }, { passive: false });

        const startDragOrHold = (e) => {
            this.holdEventHandler.handleHoldStart(e);
            this.carouselEventHandler.handleDragStart(e);
        };
        document.body.addEventListener('mousedown', startDragOrHold);
        document.body.addEventListener('touchstart', (e) => {
            if (e.target.closest('#refuel-btn') || e.target.closest('#repair-btn')) {
                e.preventDefault();
            }
            startDragOrHold(e);
        }, { passive: false });
        
        const endDragOrHold = () => {
            this.holdEventHandler.handleHoldEnd();
            this.carouselEventHandler.handleDragEnd();
        };
        document.body.addEventListener('mouseup', endDragOrHold);
        document.body.addEventListener('mouseleave', endDragOrHold);
        document.body.addEventListener('touchend', endDragOrHold);
        document.body.addEventListener('touchcancel', endDragOrHold);
        
        document.body.addEventListener('mousemove', (e) => this.carouselEventHandler.handleDragMove(e));
        document.body.addEventListener('touchmove', (e) => this.carouselEventHandler.handleDragMove(e), { passive: false });

        window.addEventListener('resize', () => this.uiManager.render(this.gameState.getState()));
        
        if (this.uiManager.cache.missionStickyBar) {
            this.uiManager.cache.missionStickyBar.addEventListener('click', () => {
                this.simulationService.setScreen(NAV_IDS.DATA, SCREEN_IDS.MISSIONS);
            });
        }
    }

    /**
     * Central click handler for the entire application, using event delegation.
     * @param {Event} e The click event object.
     * @private
     */
    _handleClick(e) {
        // Suppress click events that are the result of a drag/swipe on the carousel
        if (this.carouselEventHandler.wasMoved()) {
            e.preventDefault();
            return;
        }

        const state = this.gameState.getState();
        const actionTarget = e.target.closest('[data-action]');
        
        // Always delegate to the tooltip handler for managing popups and cleanup
        this.tooltipHandler.handleClick(e);

        if (actionTarget) {
            this.actionClickHandler.handle(e, actionTarget);
            this.marketEventHandler.handleClick(e, actionTarget);
            return;
        }

        // --- Fallback Handlers for non-action clicks ---
        if (state.introSequenceActive && !state.tutorials.activeBatchId) {
            this.simulationService.handleIntroClick(e);
            return;
        }
        if (state.isGameOver) return;

        const modalIdToClose = this.uiManager.getModalIdFromEvent(e);
        if (modalIdToClose) {
            this.uiManager.hideModal(modalIdToClose);
        }
    }

    /**
     * Handles keydown events, primarily for debug shortcuts.
     * @param {Event} e The keydown event object.
     * @private
     */
    _handleKeyDown(e) {
        if (this.gameState.isGameOver || e.ctrlKey || e.metaKey) return;
        if (e.key === '`' && this.debugService) {
            this.debugService.toggleVisibility();
            return;
        }
        if (this.debugService) {
            this.debugService.handleKeyPress(e.key);
        }
    }
}
--- END OF FILE: ./js/services/EventManager.js ---

--- START OF FILE: ./js/services/TutorialService.js ---
// ./js/services/TutorialService.js
/**
 * @fileoverview This file contains the TutorialService class, which manages the state
 * and flow of all interactive tutorials in the game. It checks for trigger conditions,
 * displays tutorial steps, and locks UI navigation to guide the player.
 */
import { DB } from '../data/database.js';
import { TUTORIAL_ACTION_TYPES, ACTION_IDS, NAV_IDS } from '../data/constants.js';

/**
 * @class TutorialService
 * @description Manages the state and flow of interactive tutorials.
 */
export class TutorialService {
    /**
     * @param {import('./GameState.js').GameState} gameState The game's central state object.
     * @param {import('./UIManager.js').UIManager} uiManager The UI manager for rendering updates.
     * @param {import('./SimulationService.js').SimulationService} simulationService The core game logic simulator.
     * @param {object} navStructure The navigation structure from UIManager, used to map screens to nav tabs.
     * @param {import('./LoggingService.js').Logger} logger The logging utility.
     */
    constructor(gameState, uiManager, simulationService, navStructure, logger) {
        this.gameState = gameState;
        this.uiManager = uiManager;
        this.simulationService = simulationService;
        this.logger = logger;
        this.activeBatchId = null;
        this.activeStepId = null;

        // Create a map of screenId -> navId for easy lookup when tutorials need to force navigation.
        this.screenToNavMap = {};
        for (const navId in navStructure) {
            for (const screenId in navStructure[navId].screens) {
                this.screenToNavMap[screenId] = navId;
            }
        }
    }

    /**
     * Checks the current game action or state against tutorial triggers and step completion conditions.
     * This is the main entry point for the tutorial system, called after player actions or screen loads.
     * @param {object} [actionData=null] Data about the action that just occurred (e.g., { type: 'ACTION', action: 'buy-ship' }).
     */
    checkState(actionData = null) {
        // If a tutorial is currently active, check if the action completes the current step.
        if (this.activeBatchId && this.activeStepId) {
            const batch = DB.TUTORIAL_DATA[this.activeBatchId];
            const step = batch.steps.find(s => s.stepId === this.activeStepId);

            if (step && this._matchesCondition(step.completion, actionData)) {
                this.advanceStep();
            }
            return;
        }

        // If no tutorial is active, check if the action triggers a new tutorial batch.
        for (const batchId in DB.TUTORIAL_DATA) {
            const batch = DB.TUTORIAL_DATA[batchId];
            const hasBeenSeen = this.gameState.tutorials.seenBatchIds.includes(batchId);
            const isSkipped = this.gameState.tutorials.skippedTutorialBatches.includes(batchId);
            
            if (!hasBeenSeen && !isSkipped) {
                const triggerAction = actionData || { type: TUTORIAL_ACTION_TYPES.SCREEN_LOAD, screenId: this.gameState.activeScreen };
                if (this._matchesCondition(batch.trigger, triggerAction)) {
                    this.triggerBatch(batchId);
                    break;
                }
            }
        }
    }

    /**
     * Starts a specific tutorial batch by its ID.
     * @param {string} batchId The unique identifier of the tutorial batch to start.
     * @param {string|null} [startStepId=null] The ID of a specific step to start from. If null, starts from the beginning.
     */
    triggerBatch(batchId, startStepId = null) {
        if (!DB.TUTORIAL_DATA[batchId]) return;
        const batch = DB.TUTORIAL_DATA[batchId];

        // If the tutorial is triggered by loading a specific screen, navigate to that screen first.
        if (batch.trigger.type === TUTORIAL_ACTION_TYPES.SCREEN_LOAD) {
            const targetScreenId = batch.trigger.screenId;
            if (this.gameState.activeScreen !== targetScreenId) {
                const targetNavId = this.screenToNavMap[targetScreenId];
                if (targetNavId) {
                    this.simulationService.setScreen(targetNavId, targetScreenId);
                }
            }
        }

        this.activeBatchId = batchId;
        this.gameState.tutorials.activeBatchId = batchId;
        
        if (!this.gameState.tutorials.seenBatchIds.includes(batchId)) {
            this.gameState.tutorials.seenBatchIds.push(batchId);
        }

        this.logger.info.system('Tutorial', this.gameState.day, 'TUTORIAL_START', `Starting tutorial batch: ${batchId}`);
        this.gameState.setState(this.gameState);
        this.uiManager.render(this.gameState.getState());
        
        const firstStepId = startStepId || batch.steps[0].stepId;
        this._displayStep(firstStepId);
    }

    /**
     * Skips the currently active tutorial batch, preventing it from triggering again.
     */
    skipActiveTutorial() {
        if (!this.activeBatchId) return;
        if (!this.gameState.tutorials.skippedTutorialBatches.includes(this.activeBatchId)) {
            this.gameState.tutorials.skippedTutorialBatches.push(this.activeBatchId);
        }
        this.logger.info.player(this.gameState.day, 'TUTORIAL_SKIP', `Skipped tutorial: ${this.activeBatchId}`);
        this._endBatch();
        this.gameState.setState(this.gameState);
    }
    
    /**
     * Advances the tutorial to the next step in the current batch, or ends the batch if it's the final step.
     */
    advanceStep() {
        if (!this.activeStepId || !this.activeBatchId) return;

        const batch = DB.TUTORIAL_DATA[this.activeBatchId];
        const currentStep = batch.steps.find(s => s.stepId === this.activeStepId);
        
        this.uiManager.hideTutorialToast();

        if (currentStep && currentStep.nextStepId) {
            this._displayStep(currentStep.nextStepId);
        } else {
            const completedBatchId = this.activeBatchId;
            this._endBatch(); 
            // If the completed tutorial was part of the intro sequence, continue the sequence.
            if (this.gameState.introSequenceActive && completedBatchId?.startsWith('intro_')) {
                this.simulationService._continueIntroSequence(completedBatchId);
            }
        }
    }

    /**
     * Displays a specific tutorial step by its ID and manages UI navigation locks.
     * @param {string} stepId The ID of the step to display.
     * @private
     */
    _displayStep(stepId) {
        if (!this.activeBatchId) return;
        const batch = DB.TUTORIAL_DATA[this.activeBatchId];
        const step = batch.steps.find(s => s.stepId === stepId);
        if (!step) {
            this._endBatch();
            return;
        }

        // --- NEW: Special handling for hangar tutorial mode switch ---
        if (step.stepId === 'hangar_2a') {
            this.simulationService.setHangarShipyardMode('hangar');
        }

        // Apply navigation lock based on tutorial data.
        if (step.hasOwnProperty('navLock')) {
            // A step can explicitly define its own lock (or null to unlock).
            this.gameState.tutorials.navLock = step.navLock;
        } else if (batch.navLock) {
            // Otherwise, inherit the lock from the parent batch.
            const currentScreenId = this.gameState.activeScreen;
            const currentNavId = this.screenToNavMap[currentScreenId];
            this.gameState.tutorials.navLock = { navId: currentNavId, screenId: currentScreenId };
        } else {
            // Ensure navigation is unlocked if no lock is specified.
            this.gameState.tutorials.navLock = null;
        }

        this.activeStepId = stepId;
        this.gameState.tutorials.activeStepId = stepId;
        this.logger.info.system('Tutorial', this.gameState.day, 'STEP_DISPLAY', `Displaying step: ${stepId}`);
        
        this.uiManager.showTutorialToast({
            step: step,
            onSkip: () => this.uiManager.showSkipTutorialModal(() => this.skipActiveTutorial()),
            onNext: () => this.advanceStep(),
            gameState: this.gameState.getState()
        });
        
        // Re-render to apply navLock changes and any other state updates from advancing the step.
        this.uiManager.render(this.gameState.getState());
    }

    /**
     * Cleans up the state when a tutorial batch ends.
     * @private
     */
    _endBatch() {
        this.logger.info.system('Tutorial', this.gameState.day, 'TUTORIAL_END', `Ending tutorial batch: ${this.activeBatchId}`);
        this.uiManager.hideTutorialToast();
        this.activeBatchId = null;
        this.activeStepId = null;
        this.gameState.tutorials.activeBatchId = null;
        this.gameState.tutorials.activeStepId = null;
        this.gameState.tutorials.navLock = null; // Clear any active navigation lock.
    }

    /**
     * Checks if a player action matches a tutorial step's completion or trigger condition.
     * @param {object|object[]} condition The condition object or array of conditions from the database.
     * @param {object} actionData The action performed by the player.
     * @returns {boolean} True if the condition(s) are met.
     * @private
     */
    _matchesCondition(condition, actionData) {
        if (!condition || !actionData) return false;
        // A condition can be an array of multiple sub-conditions that must all be true.
        if (Array.isArray(condition)) {
            return condition.every(c => this._matchesSingleCondition(c, actionData));
        }
        return this._matchesSingleCondition(condition, actionData);
    }
    
    /**
     * Helper for _matchesCondition to check a single condition object against a player action.
     * @param {object} condition The single condition object.
     * @param {object} actionData The action performed by the player.
     * @returns {boolean} True if the single condition is met.
     * @private
     */
    _matchesSingleCondition(condition, actionData) {
        if (condition.type !== actionData.type) return false;
        switch (condition.type) {
            case TUTORIAL_ACTION_TYPES.SCREEN_LOAD:
                return condition.screenId === actionData.screenId;
            case TUTORIAL_ACTION_TYPES.ACTION:
                if (condition.action === ACTION_IDS.SET_SCREEN && actionData.action === ACTION_IDS.SET_SCREEN) {
                    return condition.navId === actionData.navId && condition.screenId === actionData.screenId;
                }
                return condition.action === actionData.action;
            case TUTORIAL_ACTION_TYPES.INFO:
                return true; // Info steps are always completed by the "Next" button, not a game action.
            default:
                return false;
        }
    }
}
--- END OF FILE: ./js/services/TutorialService.js ---

--- START OF FILE: ./js/services/LoggingService.js ---
// js/services/LoggingService.js
/**
 * @fileoverview This file contains the LoggingService, a centralized utility for handling all console output.
 * It supports verbosity levels, color-coded categories, collapsible groups, performance timing,
 * and maintains a buffer of recent logs for generating bug reports. This service is designed to
 * make debugging more efficient and to standardize all logging throughout the application.
 */

// 1. --- CONFIGURATION ---
const LOG_LEVELS = {
    DEBUG: 4, // Most verbose: for fine-grained state changes, variable dumps.
    INFO: 3,  // Default: for key player actions, major system events.
    WARN: 2,   // For potential issues that don't break the game.
    ERROR: 1,  // For critical, game-breaking errors.
    NONE: 0    // Disables all console output.
};

const COLORS = {
    player: '#60a5fa',      // Blue for player actions
    system: '#4ade80',      // Green for automated system processes
    state: '#facc15',       // Yellow for significant game state changes
    warn: '#f59e0b',        // Orange for warnings
    error: '#f87171',       // Red for errors
    group: '#d4d4d8'        // Light gray for group titles
};

const MAX_LOG_HISTORY = 100; // Number of log entries to keep for bug reports.

// 2. --- STATE ---
let currentLogLevel = LOG_LEVELS.INFO; // Default logging level.
const logHistory = []; // In-memory buffer of recent log messages.

// 3. --- CORE LOGIC ---

/**
 * Adds a formatted message to the log history buffer.
 * @param {string} message The plain text message to store.
 * @private
 */
function addToHistory(message) {
    logHistory.push(message);
    if (logHistory.length > MAX_LOG_HISTORY) {
        logHistory.shift();
    }
}

/**
 * The core logging function.
 * @param {number} level The verbosity level of the message.
 * @param {string} service The service or system originating the log.
 * @param {number|string} day The current in-game day or a placeholder.
 * @param {string} action The action being logged.
 * @param {string} details The specific details of the log entry.
 * @param {string} color The CSS color for the log category.
 * @param {object|null} data Optional data object to inspect in the console.
 * @private
 */
function log(level, service, day, action, details, color, data = null) {
    if (level > currentLogLevel) return;

    const formattedMessage = `[${service}] [Day ${day}] ${action}: ${details}`;
    addToHistory(formattedMessage);

    console.log(
        `%c[${service}] %c[Day ${day}] %c${action}: %c${details}`,
        `color: ${color}; font-weight: bold;`,
        'color: #9ca3af;',
        'color: #e5e7eb; font-weight: bold;',
        'color: inherit;',
        data || ''
    );
     if (data) {
        console.dir(data);
    }
}

// 4. --- PUBLIC API ---

/**
 * The exported Logger object provides a clean, namespaced API for all logging.
 */
export const Logger = {
    /**
     * Sets the global verbosity level for the logger.
     * @param {string} levelName - The name of the level (e.g., "DEBUG", "INFO").
     */
    setLevel: (levelName) => {
        const level = LOG_LEVELS[levelName.toUpperCase()];
        if (typeof level !== 'undefined') {
            currentLogLevel = level;
            console.log(`%c[Logger] Log level set to: ${levelName}`, `color: ${COLORS.state}; font-weight: bold;`);
        } else {
            Logger.warn('LoggingService', `Attempted to set invalid log level: ${levelName}`);
        }
    },

    /**
     * Retrieves the stored log history for bug reporting.
     * @returns {string} A formatted string of all log entries.
     */
    getLogHistory: () => logHistory.join('\n'),

    // --- Informational Logs ---
    info: {
        player: (day, action, details, data = null) => log(LOG_LEVELS.INFO, 'Player', day, action, details, COLORS.player, data),
        system: (service, day, action, details, data = null) => log(LOG_LEVELS.INFO, service, day, action, details, COLORS.system, data),
        state: (day, action, details, data = null) => log(LOG_LEVELS.INFO, 'Game', day, action, details, COLORS.state, data)
    },

    // --- Warning and Error Logs ---
    warn: (service, details) => {
        if (LOG_LEVELS.WARN > currentLogLevel) return;
        const formattedMessage = `[${service}] WARN: ${details}`;
        addToHistory(formattedMessage);
        console.warn(`%c[${service}] WARN:`, `color: ${COLORS.warn}; font-weight: bold;`, details);
    },
    error: (service, details, error = null) => {
        if (LOG_LEVELS.ERROR > currentLogLevel) return;
        const formattedMessage = `[${service}] ERROR: ${details}`;
        addToHistory(formattedMessage);
        console.error(`%c[${service}] ERROR:`, `color: ${COLORS.error}; font-weight: bold;`, details, error || '');
    },

    // --- Utility Logs ---
    group: (label) => {
        if (LOG_LEVELS.DEBUG > currentLogLevel) return;
        addToHistory(`--- GROUP START: ${label} ---`);
        console.groupCollapsed(`%c${label}`, `color: ${COLORS.group}; font-style: italic;`);
    },
    groupEnd: () => {
        if (LOG_LEVELS.DEBUG > currentLogLevel) return;
        console.groupEnd();
        addToHistory(`--- GROUP END ---`);
    },
    time: (label) => {
        if (LOG_LEVELS.DEBUG > currentLogLevel) return;
        console.time(label);
    },
    timeEnd: (label) => {
        if (LOG_LEVELS.DEBUG > currentLogLevel) return;
        console.timeEnd(label);
    }
};
--- END OF FILE: ./js/services/LoggingService.js ---

--- START OF FILE: ./js/services/eventEffectResolver.js ---
// js/services/eventEffectResolver.js
/**
 * @fileoverview This file acts as a resolver for all random event outcomes. It maps effect types
 * to their corresponding handler functions, providing a centralized and extensible way to
 * apply the consequences of player choices during events.
 */
import { resolveSpaceRace } from './event-effects/effectSpaceRace.js';
import { resolveAdriftPassenger } from './event-effects/effectAdriftPassenger.js';
import { calculateInventoryUsed } from '../utils.js';
import { DB } from '../data/database.js';
import { COMMODITY_IDS } from '../data/constants.js';

/**
 * A map of effect type strings to their corresponding handler functions.
 * Each handler function receives the game state, simulation service, the specific effect object,
 * and the parent outcome object. This allows for complex, conditional logic.
 * @type {Object.<string, function(import('./GameState.js').GameState, import('./SimulationService.js').SimulationService, object, object): (object|void)>}
 */
const effectHandlers = {
    // --- Custom, Complex Event Handlers ---
    'SPACE_RACE': resolveSpaceRace,
    'ADRIFT_PASSENGER': resolveAdriftPassenger,

    // --- Standard, Reusable Effect Handlers ---
    'credits': (gameState, simulationService, effect) => {
        gameState.player.credits += effect.value;
        simulationService._logTransaction('event', effect.value, 'Received credits from event');
    },
    'fuel': (gameState, simulationService, effect) => {
        const ship = simulationService._getActiveShip();
        const shipState = gameState.player.shipStates[ship.id];
        shipState.fuel = Math.max(0, shipState.fuel + effect.value);
    },
    'hull_damage_percent': (gameState, simulationService, effect) => {
        // Damage can be a fixed value or a random value within a range [min, max].
        let dmg = Array.isArray(effect.value) ?
            Math.random() * (effect.value[1] - effect.value[0]) + effect.value[0] : effect.value;
        gameState.pendingTravel.eventHullDamagePercent = (gameState.pendingTravel.eventHullDamagePercent || 0) + dmg;
    },
    'travel_time_add': (gameState, simulationService, effect) => {
        gameState.pendingTravel.travelTimeAdd = (gameState.pendingTravel.travelTimeAdd || 0) + effect.value;
    },
    'travel_time_add_percent': (gameState, simulationService, effect) => {
        gameState.pendingTravel.travelTimeAddPercent = (gameState.pendingTravel.travelTimeAddPercent || 0) + effect.value;
    },
    'set_travel_time': (gameState, simulationService, effect) => {
        gameState.pendingTravel.setTravelTime = effect.value;
    },
    'add_debt': (gameState, simulationService, effect) => {
        if (gameState.player.debt <= 0) {
            gameState.player.loanStartDate = gameState.day;
            gameState.player.weeklyInterestAmount = 0;
        }
        const newInterest = Math.ceil(effect.value * 0.013);
        gameState.player.weeklyInterestAmount += newInterest;
        gameState.player.debt += effect.value;
        simulationService._logTransaction('loan', effect.value, 'Incurred debt from event');
    },
    'add_cargo': (gameState, simulationService, effect, outcome) => {
        const ship = simulationService._getActiveShip();
        const inventory = simulationService._getActiveInventory();
        const commodity = DB.COMMODITIES.find(c => c.id === effect.value.id);
        // This effect is conditional: cargo is only added if there is sufficient space.
        if (calculateInventoryUsed(inventory) + effect.value.quantity <= ship.cargoCapacity) {
            inventory[effect.value.id].quantity += effect.value.quantity;
        } else {
            // If there's no space, modify the outcome description to inform the player.
            outcome.description = `You try to tractor the pod, but there's no room in your cargo hold! You're forced to leave the <span class="hl">${commodity.name}</span> behind.`;
        }
    },
    'lose_cargo': (gameState, simulationService, effect) => {
        const inventory = simulationService._getActiveInventory();
        inventory[effect.value.id].quantity = Math.max(0, inventory[effect.value.id].quantity - effect.value.quantity);
    },
    'lose_random_cargo_percent': (gameState, simulationService, effect) => {
        const inventory = simulationService._getActiveInventory();
        const heldCommodities = Object.entries(inventory).filter(([, item]) => item.quantity > 0);
        if (heldCommodities.length > 0) {
            const [id, item] = heldCommodities[Math.floor(Math.random() * heldCommodities.length)];
            const quantityToLose = Math.ceil(item.quantity * effect.value);
            item.quantity = Math.max(0, item.quantity - quantityToLose);
        }
    },
    'sell_random_cargo_premium': (gameState, simulationService, effect) => {
        const inventory = simulationService._getActiveInventory();
        const heldCommodities = Object.entries(inventory).filter(([, item]) => item.quantity > 0);
        if (heldCommodities.length > 0) {
            const [id, item] = heldCommodities[Math.floor(Math.random() * heldCommodities.length)];
            const saleValue = gameState.market.galacticAverages[id] * effect.value * item.quantity;
            gameState.player.credits += saleValue;
            simulationService._logTransaction('trade', saleValue, 'Emergency supply drop sale');
            item.quantity = 0;
        }
    },
    'set_new_random_destination': (gameState, simulationService, effect) => {
        const otherMarkets = DB.MARKETS.filter(m => m.id !== gameState.currentLocationId && gameState.player.unlockedLocationIds.includes(m.id));
        if(otherMarkets.length > 0) {
            gameState.pendingTravel.destinationId = otherMarkets[Math.floor(Math.random() * otherMarkets.length)].id;
        }
    }
};

/**
 * Acts as a router, calling the appropriate handler function for a given event effect type.
 * @param {import('./GameState.js').GameState} gameState - The mutable game state object.
 * @param {import('./SimulationService.js').SimulationService} simulationService - The simulation service instance.
 * @param {object} effect - The effect object from the event definition in the database.
 * @param {object} outcome - The parent outcome object, which can be modified by the handler (e.g., to change descriptions).
 * @returns {object|void} An optional object from the handler, typically for dynamic description data.
 */
export function applyEffect(gameState, simulationService, effect, outcome) {
    const handler = effectHandlers[effect.type];
    if (handler) {
        return handler(gameState, simulationService, effect, outcome);
    } else {
        console.warn(`No handler found for event effect type: ${effect.type}`);
    }
}
--- END OF FILE: ./js/services/eventEffectResolver.js ---

--- START OF FILE: ./js/services/UIManager.js ---
// js/services/UIManager.js
import { DB } from '../data/database.js';
import { formatCredits, calculateInventoryUsed, getDateFromDay, renderIndicatorPills } from '../utils.js';
import { SCREEN_IDS, NAV_IDS, ACTION_IDS, GAME_RULES, PERK_IDS, LOCATION_IDS, SHIP_IDS, COMMODITY_IDS } from '../data/constants.js';
import { EffectsManager } from '../effects/EffectsManager.js';
import { SystemSurgeEffect } from '../effects/SystemSurgeEffect.js';

// Import all screen rendering components
import { renderHangarScreen } from '../ui/components/HangarScreen.js';
import { renderMarketScreen } from '../ui/components/MarketScreen.js';
import { renderStatusScreen } from '../ui/components/StatusScreen.js';
import { renderNavigationScreen } from '../ui/components/NavigationScreen.js';
import { renderServicesScreen } from '../ui/components/ServicesScreen.js';
import { renderCargoScreen, _renderMaxCargoModal } from '../ui/components/CargoScreen.js';
import { renderMissionsScreen } from '../ui/components/MissionsScreen.js';
import { renderFinanceScreen } from '../ui/components/FinanceScreen.js';
import { renderIntelScreen } from '../ui/components/IntelScreen.js';

export class UIManager {
    /**
     * @param {import('./LoggingService.js').Logger} logger The logging utility.
     */
    constructor(logger) {
        this.logger = logger;
        this.isMobile = window.innerWidth <= 768;
        this.modalQueue = [];
        this.activeGraphAnchor = null;
        this.activeGenericTooltipAnchor = null;
        this.lastActiveScreenEl = null;
        this.lastKnownState = null;
        this.missionService = null; // To be injected
        this.simulationService = null; // To be injected
        this.marketTransactionState = {}; // To store quantity and mode
        this.activeHighlightConfig = null; // Stores the config for currently visible highlights

        this.effectsManager = new EffectsManager();
        this.effectsManager.registerEffect('systemSurge', SystemSurgeEffect);

        this.navStructure = {
            [NAV_IDS.SHIP]: { label: 'Ship', screens: { [SCREEN_IDS.STATUS]: 'Status', [SCREEN_IDS.NAVIGATION]: 'Navigation', [SCREEN_IDS.CARGO]: 'Cargo' } },
            [NAV_IDS.STARPORT]: { label: 'Starport', screens: { [SCREEN_IDS.MARKET]: 'Market', [SCREEN_IDS.SERVICES]: 'Services', [SCREEN_IDS.HANGAR]: 'Shipyard' } },
            [NAV_IDS.DATA]: { label: 'Data', screens: { [SCREEN_IDS.MISSIONS]: 'Missions', [SCREEN_IDS.FINANCE]: 'Finance', [SCREEN_IDS.INTEL]: 'Intel' } }
        };

        this._cacheDOM();

        window.addEventListener('resize', () => {
            const wasMobile = this.isMobile;
            this.isMobile = window.innerWidth <= 768;
            if (wasMobile !== this.isMobile) {
                this.render(this.lastKnownState);
            }
        });
    }

    /**
     * @JSDoc
     * @method triggerEffect
     * @description Public method to trigger a registered visual effect.
     * @param {string} name - The name the effect was registered under.
     * @param {object} options - The configuration options for the effect.
     */
    triggerEffect(name, options) {
        this.effectsManager.trigger(name, options);
    }

    /**
     * Injects the MissionService after instantiation to avoid circular dependencies.
     * @param {import('./MissionService.js').MissionService} missionService
     */
    setMissionService(missionService) {
        this.missionService = missionService;
    }

    /**
     * Injects the SimulationService after instantiation.
     * @param {import('./SimulationService.js').SimulationService} simulationService
     */
    setSimulationService(simulationService) {
        this.simulationService = simulationService;
    }

    /**
    * Resets the state of the market transaction modules.
    */
    resetMarketTransactionState() {
        this.marketTransactionState = {};
    }

    _cacheDOM() {
        this.cache = {
            gameContainer: document.getElementById('game-container'),
            navBar: document.getElementById('nav-bar'),
            topBarContainer: document.getElementById('top-bar-container'),
            subNavBar: document.getElementById('sub-nav-bar'),
            stickyBar: document.getElementById('sticky-bar'),
            statusScreen: document.getElementById(`${SCREEN_IDS.STATUS}-screen`),
            navigationScreen: document.getElementById(`${SCREEN_IDS.NAVIGATION}-screen`),
            servicesScreen: document.getElementById(`${SCREEN_IDS.SERVICES}-screen`),
            marketScreen: document.getElementById(`${SCREEN_IDS.MARKET}-screen`),
            cargoScreen: document.getElementById(`${SCREEN_IDS.CARGO}-screen`),
            hangarScreen: document.getElementById(`${SCREEN_IDS.HANGAR}-screen`),
            missionsScreen: document.getElementById(`${SCREEN_IDS.MISSIONS}-screen`),
            financeScreen: document.getElementById(`${SCREEN_IDS.FINANCE}-screen`),
            intelScreen: document.getElementById(`${SCREEN_IDS.INTEL}-screen`),
            graphTooltip: document.getElementById('graph-tooltip'),
            genericTooltip: document.getElementById('generic-tooltip'),
            processingModal: document.getElementById('processing-modal'),
            shipDetailModal: document.getElementById('ship-detail-modal'),
            launchModal: document.getElementById('launch-modal'),
            cargoDetailModal: document.getElementById('cargo-detail-modal'),
            cargoDetailContent: document.getElementById('cargo-detail-content'),
            tutorialToastContainer: document.getElementById('tutorial-toast-container'),
            tutorialToastText: document.getElementById('tutorial-toast-text'),
            tutorialToastSkipBtn: document.getElementById('tutorial-toast-skip-btn'),
            tutorialToastNextBtn: document.getElementById('tutorial-toast-next-btn'),
            skipTutorialModal: document.getElementById('skip-tutorial-modal'),
            skipTutorialConfirmBtn: document.getElementById('skip-tutorial-confirm-btn'),
            skipTutorialCancelBtn: document.getElementById('skip-tutorial-cancel-btn'),
            tutorialHighlightOverlay: document.getElementById('tutorial-highlight-overlay'),
            missionStickyBar: document.getElementById('mission-sticky-bar'),
            stickyObjectiveText: document.getElementById('sticky-objective-text'),
            stickyObjectiveProgress: document.getElementById('sticky-objective-progress')
        };
    }

    render(gameState) {
        if (!gameState || !gameState.player) return;
        
        const previousState = this.lastKnownState;
        this.lastKnownState = gameState;
        
        if (gameState.introSequenceActive && !gameState.tutorials.activeBatchId) {
            return;
        }

        const location = DB.MARKETS.find(l => l.id === gameState.currentLocationId);
        if (location) {
            this.cache.topBarContainer.setAttribute('data-location-theme', location.id);
            this.cache.gameContainer.className = `game-container ${location.bg}`;
            if (location.navTheme && location.navTheme.borderColor) {
                document.documentElement.style.setProperty('--theme-border-color', location.navTheme.borderColor);
            } else {
                document.documentElement.style.removeProperty('--theme-border-color');
            }
        }
        
        this.renderNavigation(gameState);
        this.renderActiveScreen(gameState, previousState);
        this.updateStickyBar(gameState);
        this.renderStickyBar(gameState);
    }

    renderNavigation(gameState) {
        const { player, currentLocationId, activeNav, activeScreen, lastActiveScreen, introSequenceActive, tutorials, subNavCollapsed } = gameState;
        const { navLock } = tutorials;
        const location = DB.MARKETS.find(l => l.id === currentLocationId);
        const activeShipStatic = player.activeShipId ? DB.SHIPS[player.activeShipId] : null;
        const activeShipState = player.activeShipId ? player.shipStates[player.activeShipId] : null;
        const inventory = player.activeShipId ? player.inventories[player.activeShipId] : null;
        const theme = location?.navTheme || { gradient: 'linear-gradient(135deg, #4a5568, #2d3748)', textColor: '#f0f0f0' };
    
        const contextBarHtml = `
            <div class="context-bar" style="background: ${theme.gradient}; color: ${theme.textColor};">
                <span class="location-name-text">${location?.name || 'In Transit'}</span>
                <span class="credit-text">${formatCredits(player.credits)}</span>
            </div>`;
    
        const mainTabsHtml = Object.keys(this.navStructure).map(navId => {
            const isActive = navId === activeNav;
            const screenIdToLink = lastActiveScreen[navId] || Object.keys(this.navStructure[navId].screens)[0];
            const isDisabledByTutorial = navLock && navLock.navId !== navId;
            const isDisabled = introSequenceActive || isDisabledByTutorial;
            const activeStyle = isActive ? `background: ${theme.gradient}; color: ${theme.textColor};` : '';
            return `<div class="tab ${navId}-tab ${isActive ? 'active' : ''} ${isDisabled ? 'disabled' : ''}" style="${activeStyle}" data-action="${ACTION_IDS.SET_SCREEN}" data-nav-id="${navId}" data-screen-id="${screenIdToLink}">${this.navStructure[navId].label}</div>`;
        }).join('');
    
        let statusPodHtml = '';
        if (activeShipStatic && activeShipState && inventory) {
            const cargoUsed = calculateInventoryUsed(inventory);
            const hullPct = (activeShipState.health / activeShipStatic.maxHealth) * 100;
            const fuelPct = (activeShipState.fuel / activeShipStatic.maxFuel) * 100;
            const cargoPct = (cargoUsed / activeShipStatic.cargoCapacity) * 100;
    
            statusPodHtml = `
                <div class="status-pod">
                    <div class="status-bar-group hull-group" data-action="toggle-tooltip">
                        <span class="status-bar-label">H</span>
                        <div class="status-bar"><div class="fill hull-fill" style="width: ${hullPct}%;"></div></div>
                        <div class="status-tooltip">${Math.floor(activeShipState.health)}/${activeShipStatic.maxHealth} Hull</div>
                    </div>
                    <div class="status-bar-group fuel-group" data-action="toggle-tooltip">
                        <span class="status-bar-label">F</span>
                        <div class="status-bar"><div class="fill fuel-fill" style="width: ${fuelPct}%;"></div></div>
                        <div class="status-tooltip">${Math.floor(activeShipState.fuel)}/${activeShipStatic.maxFuel} Fuel</div>
                    </div>
                    <div class="status-bar-group cargo-group" data-action="toggle-tooltip">
                        <span class="status-bar-label">C</span>
                        <div class="status-bar"><div class="fill cargo-fill" style="width: ${cargoPct}%;"></div></div>
                        <div class="status-tooltip">${cargoUsed}/${activeShipStatic.cargoCapacity} Cargo</div>
                    </div>
                </div>`;
        }
    
        const navWrapperHtml = `<div class="nav-wrapper">${mainTabsHtml}${statusPodHtml}</div>`;
    
        const subNavsHtml = Object.keys(this.navStructure).map(navId => {
            const screens = this.navStructure[navId].screens;
            const isActive = navId === activeNav;
            const subNavButtons = Object.keys(screens).map(screenId => {
                 const isDisabledByTutorial = navLock && navLock.screenId !== screenId;
                 const isSubNavActive = screenId === activeScreen;
                 const isDisabled = introSequenceActive || isDisabledByTutorial;
                 let subStyle = `style="color: ${theme.textColor};"`;
                 if (isSubNavActive) {
                    subStyle = `style="background: ${theme.gradient}; color: ${theme.textColor}; opacity: 1; font-weight: 700;"`;
                 }
                return `<a href="#" class="${isDisabled ? 'disabled' : ''}" ${subStyle} data-action="${ACTION_IDS.SET_SCREEN}" data-nav-id="${navId}" data-screen-id="${screenId}" draggable="false">${screens[screenId]}</a>`;
            }).join('');
            return `<div class="nav-sub ${(!isActive || subNavCollapsed) ? 'hidden' : ''}" id="${navId}-sub">${subNavButtons}</div>`;
        }).join('');
    
        this.cache.navBar.innerHTML = contextBarHtml + navWrapperHtml;
        this.cache.subNavBar.innerHTML = subNavsHtml;
    }

    renderActiveScreen(gameState, previousState) {
        const activeScreenEl = this.cache[`${gameState.activeScreen}Screen`];

        if (this.lastActiveScreenEl && this.lastActiveScreenEl !== activeScreenEl) {
            this.lastActiveScreenEl.style.display = 'none';
        }

        if (activeScreenEl) {
            activeScreenEl.style.display = 'block';
            this.lastActiveScreenEl = activeScreenEl;
        }

        switch (gameState.activeScreen) {
            case SCREEN_IDS.STATUS:
                this.cache.statusScreen.innerHTML = renderStatusScreen(gameState);
                break;
            case SCREEN_IDS.NAVIGATION:
                this.cache.navigationScreen.innerHTML = renderNavigationScreen(gameState);
                break;
            case SCREEN_IDS.SERVICES:
                this.cache.servicesScreen.innerHTML = renderServicesScreen(gameState);
                break;
            case SCREEN_IDS.MARKET:
                this._saveMarketTransactionState();
                this.cache.marketScreen.innerHTML = renderMarketScreen(gameState, this.isMobile, this.getItemPrice, this.marketTransactionState);
                this._restoreMarketTransactionState();
                break;
            case SCREEN_IDS.CARGO:
                this.cache.cargoScreen.innerHTML = renderCargoScreen(gameState);
                break;
            case SCREEN_IDS.HANGAR: {
                const needsFullRender = !previousState || 
                    previousState.activeScreen !== SCREEN_IDS.HANGAR ||
                    previousState.uiState.hangarShipyardToggleState !== gameState.uiState.hangarShipyardToggleState ||
                    previousState.player.activeShipId !== gameState.player.activeShipId ||
                    previousState.uiState.lastTransactionTimestamp !== gameState.uiState.lastTransactionTimestamp ||
                    (previousState && previousState.tutorials.activeBatchId !== gameState.tutorials.activeBatchId) ||
                    (previousState && previousState.tutorials.activeStepId !== gameState.tutorials.activeStepId);

                if (needsFullRender) {
                    this.cache.hangarScreen.innerHTML = renderHangarScreen(gameState, this.simulationService);
                }
                this._updateHangarScreen(gameState);
                break;
            }
            case SCREEN_IDS.MISSIONS:
                this.cache.missionsScreen.innerHTML = renderMissionsScreen(gameState, this.missionService);
                break;
            case SCREEN_IDS.FINANCE:
                this.cache.financeScreen.innerHTML = renderFinanceScreen(gameState);
                break;
            case SCREEN_IDS.INTEL:
                this.cache.intelScreen.innerHTML = renderIntelScreen();
                break;
        }
    }

    /**
     * Surgically updates the Hangar screen for smooth transitions without a full re-render.
     * @param {object} gameState The current game state.
     * @private
     */
    _updateHangarScreen(gameState) {
        const { uiState } = gameState;
        const carousel = this.cache.hangarScreen.querySelector('#hangar-carousel');
        const paginationDots = this.cache.hangarScreen.querySelectorAll('.pagination-dot');
        if (!carousel || !paginationDots) return;

        const isHangarMode = uiState.hangarShipyardToggleState === 'hangar';
        const activeIndex = isHangarMode ? (uiState.hangarActiveIndex || 0) : (uiState.shipyardActiveIndex || 0);

        // Update carousel position
        carousel.style.transform = `translateX(-${activeIndex * 100}%)`;

        // Update pagination dots
        paginationDots.forEach((dot, index) => {
            dot.classList.toggle('active', index === activeIndex);
        });
    }

    updateStickyBar(gameState) {
        this.cache.stickyBar.innerHTML = ''; 
        this.cache.topBarContainer.classList.remove('has-sticky-bar');
    }

    updateServicesScreen(gameState) {
        if (gameState.activeScreen !== SCREEN_IDS.SERVICES) return;
        const { player } = gameState;
        const shipStatic = DB.SHIPS[player.activeShipId];
        const shipState = player.shipStates[player.activeShipId];

        const fuelBar = this.cache.servicesScreen.querySelector('#fuel-bar');
        const refuelBtn = this.cache.servicesScreen.querySelector('#refuel-btn');
        if (fuelBar && refuelBtn) {
            const fuelPct = (shipState.fuel / shipStatic.maxFuel) * 100;
            fuelBar.style.width = `${fuelPct}%`;
            refuelBtn.disabled = shipState.fuel >= shipStatic.maxFuel;
        }

        const repairBar = this.cache.servicesScreen.querySelector('#repair-bar');
        const repairBtn = this.cache.servicesScreen.querySelector('#repair-btn');
        if (repairBar && repairBtn) {
            const healthPct = (shipState.health / shipStatic.maxHealth) * 100;
            repairBar.style.width = `${healthPct}%`;
            repairBtn.disabled = shipState.health >= shipStatic.maxHealth;
        }
    }

    updateMarketScreen(gameState) {
        if (gameState.activeScreen !== SCREEN_IDS.MARKET) return;
        this._saveMarketTransactionState();
        this.cache.marketScreen.innerHTML = renderMarketScreen(gameState, this.isMobile, this.getItemPrice, this.marketTransactionState);
        this._restoreMarketTransactionState();
    }

    _saveMarketTransactionState() {
        if (!this.lastKnownState || this.lastKnownState.activeScreen !== SCREEN_IDS.MARKET) return;
        const controls = this.cache.marketScreen.querySelectorAll('.transaction-controls');
        controls.forEach(control => {
            const goodId = control.dataset.goodId;
            const qtyInput = control.querySelector('input');
            const mode = control.dataset.mode;
            
            if (qtyInput) {
                this.marketTransactionState[goodId] = {
                    quantity: qtyInput.value,
                    mode: mode
                };
            }
        });
    }

    _restoreMarketTransactionState() {
        for (const goodId in this.marketTransactionState) {
            const state = this.marketTransactionState[goodId];
            const control = this.cache.marketScreen.querySelector(`.transaction-controls[data-good-id="${goodId}"]`);
            if (control) {
                const qtyInput = control.querySelector('input');
                if (qtyInput) {
                    qtyInput.value = state.quantity;
                    control.setAttribute('data-mode', state.mode);
                    // After restoring state, immediately update the display to reflect it.
                    this.updateMarketCardDisplay(goodId, parseInt(state.quantity, 10) || 0, state.mode);
                }
            }
        }
    }

    getItemPrice(gameState, goodId, isSelling = false) {
        let price = gameState.market.prices[gameState.currentLocationId][goodId];
        const market = DB.MARKETS.find(m => m.id === gameState.currentLocationId);
        if (isSelling && market.specialDemand && market.specialDemand[goodId]) {
            price *= market.specialDemand[goodId].bonus;
        }
        const intel = gameState.intel.active;
        if (intel && intel.targetMarketId === gameState.currentLocationId && intel.commodityId === goodId) {
            price *= (intel.type === 'demand') ? DB.CONFIG.INTEL_DEMAND_MOD : DB.CONFIG.INTEL_DEPRESSION_MOD;
        }
        return Math.max(1, Math.round(price));
    }
    
    _calculateSaleDetails(goodId, quantity) {
        const state = this.lastKnownState;
        if (!state) return { totalPrice: 0, effectivePricePerUnit: 0, netProfit: 0 };
    
        const good = DB.COMMODITIES.find(c => c.id === goodId);
        const marketStock = state.market.inventory[state.currentLocationId][goodId].quantity;
        const basePrice = this.getItemPrice(state, goodId, true);
        const playerItem = state.player.inventories[state.player.activeShipId]?.[goodId];
        const avgCost = playerItem?.avgCost || 0;
    
        // Guard against division by zero if market stock is depleted.
        if (marketStock <= 0) {
            return { totalPrice: 0, effectivePricePerUnit: 0, netProfit: 0 };
        }
    
        const threshold = marketStock * 0.1;
        if (quantity <= threshold) {
            const totalPrice = basePrice * quantity;
            const totalCost = avgCost * quantity;
            let netProfit = totalPrice - totalCost;
            if (netProfit > 0) {
                let totalBonus = (state.player.activePerks[PERK_IDS.TRADEMASTER] ? DB.PERKS[PERK_IDS.TRADEMASTER].profitBonus : 0) + (state.player.birthdayProfitBonus || 0);
                netProfit += netProfit * totalBonus;
            }
            return { totalPrice, effectivePricePerUnit: basePrice, netProfit };
        }
    
        const excessRatio = quantity / marketStock;
        let reduction = 0;
    
        if (good.tier <= 2) {
            reduction = Math.min(0.10, (excessRatio - 0.1) * 0.2);
        } else if (good.tier <= 5) {
            reduction = Math.min(0.25, (excessRatio - 0.1) * 0.5);
        } else {
            reduction = Math.min(0.40, (excessRatio - 0.1) * 0.8);
        }
    
        const effectivePrice = basePrice * (1 - reduction);
        const totalPrice = Math.floor(effectivePrice * quantity);
        const totalCost = avgCost * quantity;
        let netProfit = totalPrice - totalCost;
        if (netProfit > 0) {
            let totalBonus = (state.player.activePerks[PERK_IDS.TRADEMASTER] ? DB.PERKS[PERK_IDS.TRADEMASTER].profitBonus : 0) + (state.player.birthdayProfitBonus || 0);
            netProfit += netProfit * totalBonus;
        }
    
        return {
            totalPrice,
            effectivePricePerUnit: effectivePrice,
            netProfit
        };
    }
    
    
    updateMarketCardPrice(goodId, newPrice) {
        const priceEl = this.cache.marketScreen.querySelector(`#price-display-${goodId}`);
        if (priceEl) {
            priceEl.dataset.basePrice = newPrice;
            const controls = priceEl.closest('.item-card-container').querySelector('.transaction-controls');
            if (controls && controls.dataset.mode === 'buy') {
                priceEl.textContent = formatCredits(newPrice);
            }
        }
    }

    updateMarketCardDisplay(goodId, quantity, mode) {
        const priceEl = this.cache.marketScreen.querySelector(`#price-display-${goodId}`);
        const effectivePriceEl = this.cache.marketScreen.querySelector(`#effective-price-display-${goodId}`);
        const indicatorEl = this.cache.marketScreen.querySelector(`#indicators-${goodId}`);
        const avgCostEl = this.cache.marketScreen.querySelector(`#avg-cost-${goodId}`);
    
        if (!priceEl || !effectivePriceEl || !indicatorEl || !this.lastKnownState) return;
    
        const state = this.lastKnownState;
        const basePrice = parseInt(priceEl.dataset.basePrice, 10);
        const playerItem = state.player.inventories[state.player.activeShipId]?.[goodId];
    
        if (avgCostEl) {
            avgCostEl.classList.toggle('visible', mode === 'sell');
        }
    
        if (mode === 'buy') {
            priceEl.textContent = formatCredits(basePrice);
            priceEl.className = 'font-roboto-mono font-bold price-text';
            effectivePriceEl.textContent = '';
            
            indicatorEl.innerHTML = renderIndicatorPills({
                price: basePrice,
                sellPrice: this.getItemPrice(state, goodId, true),
                galacticAvg: state.market.galacticAverages[goodId],
                playerItem: playerItem
            });
    
        } else { // 'sell' mode
            const { effectivePricePerUnit, netProfit } = this._calculateSaleDetails(goodId, quantity);
            
            if (quantity > 0) {
                let profitText = `⌬ ${netProfit >= 0 ? '+' : ''}${formatCredits(netProfit, false)}`;
                priceEl.textContent = profitText;
                effectivePriceEl.textContent = `(${formatCredits(effectivePricePerUnit, false)}/unit)`;
                priceEl.className = `font-roboto-mono font-bold ${netProfit >= 0 ? 'profit-text' : 'loss-text'}`;
            } else {
                priceEl.textContent = '⌬ +0';
                priceEl.className = 'font-roboto-mono font-bold profit-text';
                effectivePriceEl.textContent = '';
            }
            
            indicatorEl.innerHTML = renderIndicatorPills({
                price: basePrice,
                sellPrice: effectivePricePerUnit || this.getItemPrice(state, goodId, true),
                galacticAvg: state.market.galacticAverages[goodId],
                playerItem: playerItem
            });
        }
    }
    
    showTravelAnimation(from, to, travelInfo, totalHullDamagePercent, finalCallback) {
        const modal = document.getElementById('travel-animation-modal');
        const statusText = document.getElementById('travel-status-text');
        const arrivalLore = document.getElementById('travel-arrival-lore');
        const canvas = document.getElementById('travel-canvas');
        const ctx = canvas.getContext('2d');
        const progressContainer = document.getElementById('travel-progress-container');
        const progressBar = document.getElementById('travel-progress-bar');
        const readoutContainer = document.getElementById('travel-readout-container');
        const infoText = document.getElementById('travel-info-text');
        const hullDamageText = document.getElementById('travel-hull-damage');
        const confirmButton = document.getElementById('travel-confirm-button');
        let animationFrameId = null;

        statusText.textContent = `Traveling to ${to.name}...`;
        arrivalLore.textContent = '';
        arrivalLore.style.opacity = 0;
        readoutContainer.classList.add('hidden');
        readoutContainer.style.opacity = 0;
        confirmButton.classList.add('hidden');
        confirmButton.style.opacity = 0;
        progressContainer.classList.remove('hidden');
        progressBar.style.width = '0%';
        modal.classList.remove('hidden');
        
        const duration = 2500;
        let startTime = null;
        const fromEmoji = DB.LOCATION_VISUALS[from.id] || '❓';
        const toEmoji = DB.LOCATION_VISUALS[to.id] || '❓';
        const shipEmoji = '🚀';

        let stars = [];
        const numStars = 150;
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        for (let i = 0; i < numStars; i++) {
            stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: Math.random() * 1.5, speed: 0.2 + Math.random() * 0.8, alpha: 0.5 + Math.random() * 0.5 });
        }

        const animationLoop = (currentTime) => {
            if (!startTime) startTime = currentTime;
            const elapsedTime = currentTime - startTime;
            let progress = Math.min(elapsedTime / duration, 1);
            progress = 1 - Math.pow(1 - progress, 3);

            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#FFF';
            for (let i = 0; i < numStars; i++) {
                const star = stars[i];
                if (progress < 1) {
                    star.x -= star.speed;
                    if (star.x < 0) star.x = canvas.width;
                }
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.globalAlpha = star.alpha;
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;

            const padding = 60;
            const startX = padding;
            const endX = canvas.width - padding;
            const y = canvas.height / 2;
            ctx.font = '42px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(fromEmoji, startX, y);
            ctx.fillText(toEmoji, endX, y);
            const shipX = startX + (endX - startX) * progress;
            ctx.save();
            ctx.translate(shipX, y);
            ctx.font = '17px sans-serif';
            ctx.fillText(shipEmoji, 0, 0);
            ctx.restore();

            progressBar.style.width = `${progress * 100}%`;

            if (progress < 1) {
                animationFrameId = requestAnimationFrame(animationLoop);
            } else {
                statusText.textContent = `Arrived at ${to.name}`;
                arrivalLore.innerHTML = to.arrivalLore || "You have arrived.";
                infoText.innerHTML = `
                    <div class="text-center ${this.isMobile ? 'travel-info-mobile' : ''}">
                        <div>Journey Time: ${travelInfo.time} Days</div>
                        <div><span class="font-bold text-sky-300">Fuel Expended: ${travelInfo.fuelCost}</span></div>
                    </div>`;
                hullDamageText.className = 'text-sm font-roboto-mono mt-1 font-bold text-red-400';
                if (totalHullDamagePercent > 0.01) {
                    hullDamageText.innerHTML = `Hull Integrity -${totalHullDamagePercent.toFixed(2)}%`;
                    if (this.isMobile) {
                        infoText.querySelector('div').appendChild(hullDamageText);
                    }
                } else {
                    hullDamageText.innerHTML = '';
                }
                
                arrivalLore.style.opacity = 1;
                progressContainer.classList.add('hidden');
                readoutContainer.classList.remove('hidden');
                confirmButton.classList.remove('hidden');
                setTimeout(() => {
                    readoutContainer.style.opacity = 1;
                    confirmButton.style.opacity = 1;
                }, 50);
            }
        }

        animationFrameId = requestAnimationFrame(animationLoop);
        confirmButton.onclick = () => {
            cancelAnimationFrame(animationFrameId);
            modal.classList.add('hidden');
            if (finalCallback) finalCallback();
        };
    }

    queueModal(modalId, title, description, callback = null, options = {}) {
        this.modalQueue.push({ modalId, title, description, callback, options });
        if (!document.querySelector('.modal-backdrop:not(.hidden)')) {
            this.processModalQueue();
        }
    }

    processModalQueue() {
        if (this.modalQueue.length === 0) return;
        const { modalId, title, description, callback, options } = this.modalQueue.shift();
        const modal = document.getElementById(modalId);
        if (!modal) {
            this.logger.error('UIManager', `Modal element with ID '${modalId}' not found in the DOM. Aborting modal display.`);
            return this.processModalQueue();
        }

        const titleElId = modalId === 'mission-modal' ? 'mission-modal-title' : modalId.replace('-modal', '-title');
        const descElId = modalId === 'mission-modal' ? 'mission-modal-description' : modalId.replace('-modal', '-description');
        const titleEl = modal.querySelector(`#${titleElId}`);
        const descEl = modal.querySelector(`#${descElId}`) || modal.querySelector(`#${modalId.replace('-modal', '-scenario')}`);

        if (titleEl) titleEl.innerHTML = title;
        if (descEl) {
            descEl.innerHTML = description;
            descEl.className = 'my-4 text-gray-300'; 
            if(modalId !== 'mission-modal') descEl.classList.add('mb-6', 'text-lg');
            if (options.contentClass) {
                descEl.classList.add(options.contentClass);
            }
        }

        const closeHandler = () => {
            this.hideModal(modalId);
            if (callback) callback();
            this.processModalQueue();
        };

        if (options.customSetup) {
            options.customSetup(modal, closeHandler);
        } else {
            const btnContainer = modal.querySelector('#' + modalId.replace('-modal', '-button-container'));
            let button;
            if (btnContainer) {
                btnContainer.innerHTML = '';
                button = document.createElement('button');
                btnContainer.appendChild(button);
            } else {
                 button = modal.querySelector('button');
            }
            if (button) {
                button.className = 'btn px-6 py-2';
                if (options.buttonClass) button.classList.add(options.buttonClass);
                button.innerHTML = options.buttonText || 'Understood';
                button.onclick = closeHandler;
            }
        }
        
        modal.classList.remove('hidden');
        modal.classList.add('modal-visible');
    }

    showRandomEventModal(event, choicesCallback) {
        this.queueModal('random-event-modal', event.title, event.scenario, null, {
            customSetup: (modal, closeHandler) => {
                const choicesContainer = modal.querySelector('#random-event-choices-container');
                choicesContainer.innerHTML = '';
                event.choices.forEach((choice, index) => {
                    const button = document.createElement('button');
                    button.className = 'btn w-full text-left p-4 hover:bg-slate-700';
                    button.innerHTML = choice.title;
                    button.onclick = () => {
                        choicesCallback(event.id, index);
                        closeHandler();
                    };
                    choicesContainer.appendChild(button);
                });
            }
        });
    }

    showAgeEventModal(event, choiceCallback) {
        const modal = document.getElementById('age-event-modal');
        document.getElementById('age-event-title').innerHTML = event.title;
        document.getElementById('age-event-description').innerHTML = event.description;
        const btnContainer = document.getElementById('age-event-button-container');
        btnContainer.innerHTML = '';
        event.choices.forEach(choice => {
            const button = document.createElement('button');
            button.className = 'perk-button';
            button.innerHTML = `<h4>${choice.title}</h4><p>${choice.description}</p>`;
            button.onclick = () => {
                this.hideModal('age-event-modal');
                choiceCallback(choice);
            };
            btnContainer.appendChild(button);
        });
        modal.classList.remove('hidden');
        modal.classList.add('modal-visible');
    }

    hideModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal && !modal.classList.contains('hidden')) {
            modal.classList.add('modal-hiding');
            modal.addEventListener('animationend', () => {
                modal.classList.add('hidden');
                modal.classList.remove('modal-hiding', 'modal-visible');
                if (this.modalQueue.length > 0 && !document.querySelector('.modal-backdrop:not(.hidden)')) {
                    this.processModalQueue();
                }
            }, { once: true });
        }
    }
    
    showProcessingAnimation(playerName, callback) {
        const modal = this.cache.processingModal;
        if (!modal) return;
    
        const titleEl = modal.querySelector('#processing-title');
        const progressBar = modal.querySelector('#processing-progress-bar');
        const statusText = modal.querySelector('#processing-status');
    
        titleEl.textContent = `Processing application for ${playerName}...`;
        progressBar.style.width = '0%';
        statusText.textContent = '';
        modal.classList.remove('hidden');
    
        setTimeout(() => {
            progressBar.style.width = '100%';
        }, 100);
    
        setTimeout(() => {
            statusText.textContent = 'Processing complete!';
            setTimeout(() => {
                this.hideModal('processing-modal');
                if (callback) callback();
            }, 1000);
        }, 4000);
    }

    createFloatingText(text, x, y, color = '#fde047') {
        const el = document.createElement('div');
        el.textContent = text;
        el.className = 'floating-text';
        el.style.left = `${x - 20}px`;
        el.style.top = `${y - 40}px`;
        el.style.color = color;
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 2450);
    }
    
    showGraph(anchorEl, gameState) {
        this.activeGraphAnchor = anchorEl;
        const tooltip = this.cache.graphTooltip;
        const action = anchorEl.dataset.action;

        if (action === ACTION_IDS.SHOW_PRICE_GRAPH) {
            const goodId = anchorEl.dataset.goodId;
            const playerItem = gameState.player.inventories[gameState.player.activeShipId][goodId];
            tooltip.innerHTML = this._renderPriceGraph(goodId, gameState, playerItem);
        } else if (action === ACTION_IDS.SHOW_FINANCE_GRAPH) {
            tooltip.innerHTML = this._renderFinanceGraph(gameState);
        }
        
        tooltip.style.display = 'block';
        this.updateGraphTooltipPosition();
    }

    hideGraph() {
        if (this.activeGraphAnchor) {
            this.cache.graphTooltip.style.display = 'none';
            this.activeGraphAnchor = null;
        }
    }
    
    updateGraphTooltipPosition() {
        if (!this.activeGraphAnchor) return;
        const tooltip = this.cache.graphTooltip;
        if (tooltip.style.display === 'none') return;
    
        const rect = this.activeGraphAnchor.closest('.item-card-container').getBoundingClientRect();
        const tooltipHeight = tooltip.offsetHeight;
    
        let topPos = rect.top - tooltipHeight - 10;
        let leftPos = rect.left;
    
        if (topPos < 10) {
            topPos = rect.bottom + 10;
        }
    
        tooltip.style.left = `${leftPos}px`;
        tooltip.style.top = `${topPos}px`;
    }

    showGenericTooltip(anchorEl, content) {
        this.activeGenericTooltipAnchor = anchorEl;
        const tooltip = this.cache.genericTooltip;
        tooltip.innerHTML = content;
        tooltip.style.display = 'block';
        this.updateGenericTooltipPosition();
    }

    hideGenericTooltip() {
        if (this.activeGenericTooltipAnchor) {
            this.cache.genericTooltip.style.display = 'none';
            this.activeGenericTooltipAnchor = null;
        }
    }

    updateGenericTooltipPosition() {
        if (!this.activeGenericTooltipAnchor) return;
        const tooltip = this.cache.genericTooltip;
        const rect = this.activeGenericTooltipAnchor.getBoundingClientRect();
        const tooltipWidth = tooltip.offsetWidth;
        const tooltipHeight = tooltip.offsetHeight;
        let leftPos = rect.right + 10;
        let topPos = rect.top + (rect.height / 2) - (tooltipHeight / 2);

        if (topPos < 10) {
            topPos = rect.bottom + 10;
        }
        if (leftPos < 10) {
            leftPos = 10;
        }
        if (leftPos + tooltipWidth > window.innerWidth) {
            leftPos = window.innerWidth - tooltipWidth - 10;
        }

        tooltip.style.left = `${leftPos}px`;
        tooltip.style.top = `${topPos}px`;
    }

    _renderPriceGraph(goodId, gameState, playerItem) {
        const history = gameState.market.priceHistory[gameState.currentLocationId]?.[goodId];
        if (!history || history.length < 2) return `<div class="text-gray-400 text-sm p-4">No Data Available!</div>`;
        const good = DB.COMMODITIES.find(c => c.id === goodId);
        const staticAvg = (good.basePriceRange[0] + good.basePriceRange[1]) / 2;
        const width = 280, height = 140, padding = 35;
        const prices = history.map(p => p.price);
        const playerBuyPrice = playerItem?.avgCost > 0 ? playerItem.avgCost : null;

        let allValues = [...prices, staticAvg];
        if (playerBuyPrice) allValues.push(playerBuyPrice);
        const minVal = Math.min(...allValues), maxVal = Math.max(...allValues);
        const valueRange = maxVal - minVal > 0 ? maxVal - minVal : 1;

        const getX = i => (i / (history.length - 1)) * (width - padding * 2) + padding;
        const getY = v => height - padding - ((v - minVal) / valueRange) * (height - padding * 2.5);

        let svg = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg"><rect width="100%" height="100%" fill="#0c101d" />`;
        svg += `<g class="grid-lines" stroke="#1f2937" stroke-width="1">`;
        svg += `<line x1="${padding}" y1="${getY(maxVal)}" x2="${padding}" y2="${height - padding}" /><line x1="${padding}" y1="${height - padding}" x2="${width - padding}" y2="${height - padding}" />`;
        svg += `</g>`;

        const staticAvgY = getY(staticAvg);
        svg += `<line x1="${padding}" y1="${staticAvgY}" x2="${width - padding}" y2="${staticAvgY}" stroke="#facc15" stroke-width="1" stroke-dasharray="3 3" />`;
        svg += `<text x="${width - padding + 4}" y="${staticAvgY + 3}" fill="#facc15" font-size="10" font-family="Roboto Mono" text-anchor="start">Avg: ${formatCredits(staticAvg, false)}</text>`;

        if (playerBuyPrice) {
            const buyPriceY = getY(playerBuyPrice);
            svg += `<line x1="${padding}" y1="${buyPriceY}" x2="${width - padding}" y2="${buyPriceY}" stroke="#34d399" stroke-width="1" stroke-dasharray="3 3" />`;
            svg += `<text x="${width - padding + 4}" y="${buyPriceY + 3}" fill="#34d399" font-size="10" font-family="Roboto Mono" text-anchor="start">Paid: ${formatCredits(playerBuyPrice, false)}</text>`;
        }

        const pricePoints = history.map((p, i) => `${getX(i)},${getY(p.price)}`).join(' ');
        svg += `<polyline fill="none" stroke="#60a5fa" stroke-width="2" points="${pricePoints}" />`;

        const firstDay = history[0].day;
        const lastDay = history[history.length - 1].day;
        svg += `<text x="${padding}" y="${height - padding + 15}" fill="#9ca3af" font-size="10" font-family="Roboto Mono" text-anchor="start">Day ${firstDay}</text>`;
        svg += `<text x="${width - padding}" y="${height - padding + 15}" fill="#9ca3af" font-size="10" font-family="Roboto Mono" text-anchor="end">Day ${lastDay}</text>`;

        svg += `<text x="${padding - 8}" y="${getY(minVal) + 3}" fill="#9ca3af" font-size="10" font-family="Roboto Mono" text-anchor="end">${formatCredits(minVal, false)}</text>`;
        svg += `<text x="${padding - 8}" y="${getY(maxVal) + 3}" fill="#9ca3af" font-size="10" font-family="Roboto Mono" text-anchor="end">${formatCredits(maxVal, false)}</text>`;
        svg += `</svg>`;
        return svg;
    }
    
    showTutorialToast({ step, onSkip, onNext, gameState }) {
        const toast = this.cache.tutorialToastContainer;
        
        let processedText = step.text;
        if (processedText.includes('{shipName}')) {
            const shipName = DB.SHIPS[gameState.player.activeShipId]?.name || 'your ship';
            processedText = processedText.replace(/{shipName}/g, shipName);
        }
        if (processedText.includes('{playerName}')) {
            processedText = processedText.replace(/{playerName}/g, gameState.player.name);
        }
        this.cache.tutorialToastText.innerHTML = processedText;

        toast.className = 'hidden fixed p-4 rounded-lg shadow-2xl transition-all duration-300 pointer-events-auto';
        
        let positionClass;
        if (this.isMobile) {
            positionClass = `tt-${step.position.mobile || 'mobile'}`;
        } else {
            positionClass = `tt-${step.position.desktop || 'bottom-right'}`;
        }
        toast.classList.add(positionClass);

        toast.style.width = step.size?.width || 'auto';

        toast.classList.remove('hidden');

        const isInfoStep = step.completion.type === 'INFO';
        if (isInfoStep) {
            const nextButtonText = step.buttonText || 'Next &rarr;';
            this.cache.tutorialToastNextBtn.innerHTML = nextButtonText;
            this.cache.tutorialToastNextBtn.style.display = 'inline-block';
            this.cache.tutorialToastNextBtn.onclick = onNext;
        } else {
            this.cache.tutorialToastNextBtn.style.display = 'none';
        }

        const showSkipButton = false;
        this.cache.tutorialToastSkipBtn.style.display = showSkipButton ? 'block' : 'none';
        this.cache.tutorialToastSkipBtn.onclick = onSkip;
        this.cache.tutorialToastText.scrollTop = 0;
    }


    hideTutorialToast() {
        this.cache.tutorialToastContainer.classList.add('hidden');
        this.applyTutorialHighlight(null);
    }
    
    applyTutorialHighlight(highlightConfig) {
        this.activeHighlightConfig = highlightConfig;
        this._renderHighlightsFromConfig(this.activeHighlightConfig);
    }

    _renderHighlightsFromConfig(highlightConfig) {
        const overlay = this.cache.tutorialHighlightOverlay;
        if (!overlay) return;

        overlay.innerHTML = ''; // Clear previous highlights
        if (!highlightConfig) {
            overlay.classList.add('hidden');
            return;
        }

        overlay.classList.remove('hidden');

        highlightConfig.forEach(cue => {
            const el = document.createElement('div');
            el.className = 'tutorial-cue';
            el.style.left = `${cue.x}px`;
            el.style.top = `${cue.y}px`;
            el.style.width = `${cue.width}px`;
            el.style.height = `${cue.height}px`;
            el.style.transform = `rotate(${cue.rotation}deg)`;
            el.style.opacity = cue.style.opacity;

            if (cue.style.animation !== 'None') {
                el.classList.add(`anim-${cue.style.animation.toLowerCase()}`);
            }

            let content = '';
            if (cue.type === 'Shape') {
                content = `
                    <svg width="100%" height="100%" viewBox="0 0 ${cue.width} ${cue.height}" preserveAspectRatio="none" style="overflow: visible;">
                        ${cue.shapeType === 'Rectangle' ? 
                            `<rect x="0" y="0" width="100%" height="100%" rx="${cue.style.borderRadius}" ry="${cue.style.borderRadius}" style="fill:${cue.style.fill}; stroke:${cue.style.stroke}; stroke-width:${cue.style.strokeWidth}px;" />` :
                            `<ellipse cx="50%" cy="50%" rx="50%" ry="50%" style="fill:${cue.style.fill}; stroke:${cue.style.stroke}; stroke-width:${cue.style.strokeWidth}px;" />`
                        }
                    </svg>`;
            } else if (cue.type === 'Arrow') {
                 content = `
                    <svg width="100%" height="100%" viewBox="0 0 100 50" preserveAspectRatio="none" style="overflow: visible;">
                        <defs>
                            <marker id="arrowhead-player" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="${cue.style.stroke}" />
                            </marker>
                        </defs>
                        <line x1="0" y1="25" x2="90" y2="25" stroke="${cue.style.stroke}" stroke-width="${cue.style.strokeWidth}" marker-end="url(#arrowhead-player)" />
                    </svg>
                `;
            } else if (cue.type === 'Spotlight') {
                el.style.borderRadius = '50%';
                el.style.boxShadow = `0 0 0 9999px rgba(0,0,0,0.7), 0 0 ${cue.style.glowIntensity || 20}px ${cue.style.glowIntensity || 10}px ${cue.style.glowColor || cue.style.stroke}`;
            }

            el.innerHTML = content;
            // Apply dynamic styles to the animated child, not the parent container
            const animatedChild = el.querySelector('svg');
            if (animatedChild && cue.style.animation !== 'None') {
                 animatedChild.classList.add(`anim-${cue.style.animation.toLowerCase()}`);
                 animatedChild.style.setProperty('--glow-color', cue.style.glowColor || cue.style.stroke);
                 animatedChild.style.setProperty('--anim-speed', `${cue.style.animationSpeed}s`);
                 animatedChild.style.setProperty('--glow-intensity', `${cue.style.glowIntensity}px`);
            }

            overlay.appendChild(el);
        });
    }

    showSkipTutorialModal(onConfirm) {
        const modal = this.cache.skipTutorialModal;
        modal.classList.remove('hidden');
        
        const confirmHandler = () => {
            onConfirm();
            this.hideModal('skip-tutorial-modal');
        };

        const cancelHandler = () => {
            this.hideModal('skip-tutorial-modal');
        };

        this.cache.skipTutorialConfirmBtn.onclick = confirmHandler;
        this.cache.skipTutorialCancelBtn.onclick = cancelHandler;
    }

    showTutorialLogModal({ seenBatches, onSelect }) {
        const logModal = document.getElementById('tutorial-log-modal');
        const list = document.getElementById('tutorial-log-list');

        if (!logModal || !list) {
            this.logger.error('UIManager', 'Tutorial log modal elements not found in DOM.');
            return;
        }

        list.innerHTML = '';

        if (seenBatches.length === 0) {
            list.innerHTML = `<li class="text-gray-400 p-2 text-center">No tutorials viewed yet.</li>`;
        } else {
            seenBatches.forEach(batchId => {
                const batchData = DB.TUTORIAL_DATA[batchId];
                if (batchData) {
                    const li = document.createElement('li');
                    li.innerHTML = `<button class="btn w-full text-center">${batchData.title}</button>`;
                    li.onclick = () => {
                        logModal.classList.remove('visible');
                        onSelect(batchId);
                    };
                    list.appendChild(li);
                }
            });
        }
        logModal.classList.add('visible');
    }

    showShipDetailModal(gameState, shipId, context) {
        const { player, tutorials } = gameState;
        const shipStatic = DB.SHIPS[shipId];
        let modalContentHtml;
    
        if (context === 'shipyard') {
            const canAfford = player.credits >= shipStatic.price;
            const isHangarTutStep1Active = tutorials.activeBatchId === 'intro_hangar' && tutorials.activeStepId === 'hangar_1';
            const isDisabled = !canAfford || isHangarTutStep1Active;
            modalContentHtml = `
                <div class="ship-card p-4 flex flex-col space-y-3">
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="text-xl font-orbitron text-cyan-300">${shipStatic.name}</h3>
                            <p class="text-sm text-gray-400">Class ${shipStatic.class}</p>
                        </div>
                        <div class="text-right">
                            <p class="text-lg font-bold text-cyan-300">${formatCredits(shipStatic.price)}</p>
                        </div>
                    </div>
                    <p class="text-sm text-gray-400 flex-grow text-left">${shipStatic.lore}</p>
                    <div class="grid grid-cols-3 gap-x-4 text-sm font-roboto-mono text-center pt-2">
                        <div><span class="text-gray-500">Hull:</span> <span class="text-green-400">${shipStatic.maxHealth}</span></div>
                        <div><span class="text-gray-500">Fuel:</span> <span class="text-sky-400">${shipStatic.maxFuel}</span></div>
                        <div><span class="text-gray-500">Cargo:</span> <span class="text-amber-400">${shipStatic.cargoCapacity}</span></div>
                    </div>
                    <button class="btn w-full mt-2" data-action="${ACTION_IDS.BUY_SHIP}" data-ship-id="${shipId}" ${isDisabled ? 'disabled' : ''}>Purchase</button>
                </div>`;
        } else { // context === 'hangar'
            const shipDynamic = player.shipStates[shipId];
            const shipInventory = player.inventories[shipId];
            const cargoUsed = calculateInventoryUsed(shipInventory);
            const isActive = shipId === player.activeShipId;
            const canSell = player.ownedShipIds.length > 1 && !isActive;
            const salePrice = Math.floor(shipStatic.price * GAME_RULES.SHIP_SELL_MODIFIER);
            modalContentHtml = `
                <div class="ship-card p-4 flex flex-col space-y-3 ${isActive ? 'border-yellow-400' : ''}">
                    <h3 class="text-xl font-orbitron text-center ${isActive ? 'text-yellow-300' : 'text-cyan-300'}">${shipStatic.name}</h3>
                    <p class="text-sm text-gray-400 text-center">Class ${shipStatic.class}</p>
                    <p class="text-sm text-gray-400 flex-grow text-left my-2">${shipStatic.lore}</p>
                    <div class="grid grid-cols-3 gap-x-4 text-sm font-roboto-mono text-center pt-2">
                        <div><span class="text-gray-500">Hull</span><div class="text-green-400">${Math.floor(shipDynamic.health)}/${shipStatic.maxHealth}</div></div>
                        <div><span class="text-gray-500">Fuel</span><div class="text-sky-400">${Math.floor(shipDynamic.fuel)}/${shipStatic.maxFuel}</div></div>
                        <div><span class="text-gray-500">Cargo</span><div class="text-amber-400">${cargoUsed}/${shipStatic.cargoCapacity}</div></div>
                    </div>
                    <div class="grid grid-cols-2 gap-2 mt-2">
                        ${isActive ? '<button class="btn" disabled>ACTIVE</button>' : `<button class="btn" data-action="${ACTION_IDS.SELECT_SHIP}" data-ship-id="${shipId}">Board</button>`}
                        <button class="btn" data-action="${ACTION_IDS.SELL_SHIP}" data-ship-id="${shipId}" ${!canSell ? 'disabled' : ''}>Sell<br>⌬ ${formatCredits(salePrice, false)}</button>
                    </div>
                </div>`;
        }
    
        const modal = this.cache.shipDetailModal;
        const modalContent = modal.querySelector('#ship-detail-content');
        modalContent.innerHTML = modalContentHtml;
        modal.classList.remove('hidden');
        modal.classList.add('modal-visible');
    }
    
    showLaunchModal(locationId) {
        const state = this.lastKnownState;
        if (!state) return;

        const location = DB.MARKETS.find(l => l.id === locationId);
        if (!location) return;

        const theme = location.navTheme;
        const travelInfo = state.TRAVEL_DATA[state.currentLocationId]?.[locationId];
        const shipState = state.player.shipStates[state.player.activeShipId];

        // If travel isn't possible from the current location, do nothing.
        if (!travelInfo) return;

        const COMMODITY_CATEGORIES = {
            'water_ice': 'RAW', 'plasteel': 'IND', 'hydroponics': 'AGRI', 'cybernetics': 'TECH', 
            'propellant': 'IND', 'processors': 'TECH', 'gmo_seeds': 'AGRI', 'cryo_pods': 'CIV', 
            'atmos_processors': 'IND', 'cloned_organs': 'BIO', 'xeno_geologicals': 'RAW', 
            'sentient_ai': 'TECH', 'antimatter': 'RARE', 'folded_drives': 'RARE'
        };

        let imports = [];
        let exports = [];
        for (const goodId in location.availabilityModifier) {
            const modifier = location.availabilityModifier[goodId];
            const category = COMMODITY_CATEGORIES[goodId];
            if (modifier < 1.0 && !imports.includes(category)) {
                imports.push(category);
            } else if (modifier > 1.0 && !exports.includes(category)) {
                exports.push(category);
            }
        }
        
        let intelHtml = '';
        if (imports.length > 0) {
            intelHtml += `<p><b style="color: ${theme.textColor};">Imports:</b> ${imports.join(', ')}</p>`;
        }
        if (exports.length > 0) {
            intelHtml += `<p><b style="color: ${theme.textColor};">Exports:</b> ${exports.join(', ')}</p>`;
        }
        if (intelHtml === '') {
            intelHtml = '<p>Market data is unreliable.</p>';
        }
        
        const modalContentHtml = `
            <div class="launch-modal-wrapper panel-border" style="background: ${theme.gradient}; color: ${theme.textColor}; border-color: ${theme.borderColor};">
                <div class="flex-shrink-0">
                    <h3 class="font-orbitron">${location.name}</h3>
                    <p class="flavor-text italic">${location.launchFlavor}</p>
                </div>
                <div class="border-t border-b py-2 text-center space-y-1" style="border-color: ${theme.borderColor}50;">
                    ${intelHtml}
                </div>
                <div class="font-roboto-mono text-xs"> 
                    <p>Travel Time: ${travelInfo.time} Days</p>
                    <p>Fuel: ${Math.floor(shipState.fuel)} / ${travelInfo.fuelCost} required</p>
                </div>
                <div class="pt-2"> 
                   <button class="btn btn-launch-glow" data-action="travel" data-location-id="${locationId}" style="--launch-glow-color: ${theme.borderColor};">Launch</button>
                </div>
            </div>`;

        const modal = this.cache.launchModal;
        modal.innerHTML = modalContentHtml; // Directly set the innerHTML of the modal backdrop
        modal.classList.remove('hidden');
        modal.classList.add('modal-visible');

        // Add a one-time click listener to the backdrop to close the modal.
        const closeHandler = (e) => {
            if (e.target.id === 'launch-modal') {
                this.hideModal('launch-modal');
                modal.removeEventListener('click', closeHandler);
            }
        };
        modal.addEventListener('click', closeHandler);
    }
    
    showCargoDetailModal(gameState, goodId) {
        const good = DB.COMMODITIES.find(c => c.id === goodId);
        const item = gameState.player.inventories[gameState.player.activeShipId]?.[goodId];

        if (!good || !item) return;

        const modal = this.cache.cargoDetailModal;
        const modalContent = this.cache.cargoDetailContent;

        modalContent.innerHTML = _renderMaxCargoModal(good, item);
        modal.classList.remove('hidden');
        modal.classList.add('modal-visible');
    }

    renderStickyBar(gameState) {
        const stickyBarEl = this.cache.missionStickyBar;
        const contentEl = stickyBarEl.querySelector('.sticky-content');
        const objectiveTextEl = this.cache.stickyObjectiveText;
        const objectiveProgressEl = this.cache.stickyObjectiveProgress;
    
        if (gameState.missions.activeMissionId) {
            const mission = DB.MISSIONS[gameState.missions.activeMissionId];
            // Fix: Add a guard clause to handle missions with no objectives.
            if (!mission.objectives || mission.objectives.length === 0) {
                stickyBarEl.style.display = 'none';
                return;
            }
            const progress = gameState.missions.missionProgress[mission.id] || { objectives: {} };
    
            const objective = mission.objectives[0];
            const current = progress.objectives[objective.goodId]?.current ?? 0;
            const target = objective.quantity;
            const goodName = DB.COMMODITIES.find(c => c.id === objective.goodId).name;
            const locationName = DB.MARKETS.find(m => m.id === mission.completion.locationId).name;
    
            objectiveTextEl.textContent = `Deliver ${goodName} to ${locationName}`;
            objectiveProgressEl.textContent = `[${current}/${target}]`;
    
            const hostClass = `host-${mission.host.toLowerCase().replace(/[^a-z0-9]/g, '')}`;
            let turnInClass = gameState.missions.activeMissionObjectivesMet && mission.completion.locationId === gameState.currentLocationId ? 'mission-turn-in' : '';
            contentEl.className = `sticky-content sci-fi-frame ${hostClass} ${turnInClass}`;
    
            stickyBarEl.style.display = 'block';
        } else {
            stickyBarEl.style.display = 'none';
        }
    }

    showMissionModal(missionId) {
        const mission = DB.MISSIONS[missionId];
        if (!mission) return;
    
        const { missions, currentLocationId } = this.lastKnownState;
        const { activeMissionId, activeMissionObjectivesMet } = missions;

        const isActive = activeMissionId === missionId;
        const canComplete = isActive && activeMissionObjectivesMet && mission.completion.locationId === currentLocationId;
        
        if (canComplete) {
            this._showMissionCompletionModal(mission);
        } else {
            this._showMissionDetailsModal(mission);
        }
    }

    _showMissionDetailsModal(mission) {
        const { missions, tutorials } = this.lastKnownState;
        const isActive = missions.activeMissionId === mission.id;
        const anotherMissionActive = missions.activeMissionId && !isActive;
        let shouldBeDisabled = anotherMissionActive;
        if (mission.id === 'mission_tutorial_02' && tutorials.activeBatchId === 'intro_missions' && tutorials.activeStepId !== 'mission_2_4') {
            shouldBeDisabled = true;
        }

        const options = {
            customSetup: (modal, closeHandler) => {
                const modalContent = modal.querySelector('.modal-content');
                modalContent.className = 'modal-content sci-fi-frame flex flex-col items-center text-center';
                const hostClass = `host-${mission.host.toLowerCase().replace(/[^a-z0-9]/g, '')}`;
                modalContent.classList.add(hostClass);

                modal.querySelector('#mission-modal-type').textContent = mission.type;

                const objectivesEl = modal.querySelector('#mission-modal-objectives');
                const objectivesHtml = '<h6 class="font-bold text-sm uppercase tracking-widest text-gray-400 text-center">OBJECTIVES:</h6><ul class="list-disc list-inside text-gray-300">' + mission.objectives.map(obj => `<li>Deliver ${obj.quantity}x ${DB.COMMODITIES.find(c => c.id === obj.goodId).name}</li>`).join('') + '</ul>';
                objectivesEl.innerHTML = objectivesHtml;
                objectivesEl.style.display = 'block';
                
                const rewardsEl = modal.querySelector('#mission-modal-rewards');
                if (mission.rewards && mission.rewards.length > 0) {
                    const rewardsHtml = mission.rewards.map(r => {
                        if(r.type === 'credits') return `⌬ ${r.amount.toLocaleString()}`;
                        return r.type.toUpperCase();
                    }).join(', ');
                    rewardsEl.innerHTML = `<p class="font-roboto-mono text-sm text-gray-400 mb-1">REWARDS:</p><p class="font-orbitron text-xl text-yellow-300">${rewardsHtml}</p>`;
                    rewardsEl.style.display = 'block';
                } else {
                    rewardsEl.innerHTML = '';
                    rewardsEl.style.display = 'none';
                }
                
                const buttonsEl = modal.querySelector('#mission-modal-buttons');
                if (isActive) { 
                    const isAbandonable = mission.isAbandonable !== false;
                    buttonsEl.innerHTML = `<button class="btn w-full bg-red-800/80 hover:bg-red-700/80 border-red-500" data-action="abandon-mission" data-mission-id="${mission.id}" ${!isAbandonable ? 'disabled' : ''}>Abandon Mission</button>`;
                } else { 
                    buttonsEl.innerHTML = `<button class="btn w-full" data-action="accept-mission" data-mission-id="${mission.id}" ${shouldBeDisabled ? 'disabled' : ''}>Accept</button>`;
                }
            }
        };
        if (mission.id === 'mission_tutorial_01' && tutorials.activeStepId === 'mission_1_1') {
            shouldBeDisabled = true;
        }
        this.queueModal('mission-modal', mission.name, mission.description, null, options);
    }

    _showMissionCompletionModal(mission) {
        const options = {
            customSetup: (modal, closeHandler) => {
                const modalContent = modal.querySelector('.modal-content');
                modalContent.className = 'modal-content sci-fi-frame flex flex-col items-center text-center';
                const hostClass = `host-${mission.host.toLowerCase().replace(/[^a-z0-9]/g, '')}`;
                modalContent.classList.add(hostClass);

                modal.querySelector('#mission-modal-title').textContent = mission.completion.title;
                modal.querySelector('#mission-modal-type').textContent = "OBJECTIVES MET";
                modal.querySelector('#mission-modal-description').innerHTML = mission.completion.text;
                
                const objectivesEl = modal.querySelector('#mission-modal-objectives');
                objectivesEl.style.display = 'none';

                const rewardsEl = modal.querySelector('#mission-modal-rewards');
                if (mission.rewards && mission.rewards.length > 0) {
                    const rewardsHtml = mission.rewards.map(r => {
                        if(r.type === 'credits') return `⌬ ${r.amount.toLocaleString()}`;
                        return r.type.toUpperCase();
                    }).join(', ');
                    rewardsEl.innerHTML = `<p class="font-roboto-mono text-sm text-gray-400 mb-1">REWARDS:</p><p class="font-orbitron text-xl text-green-300">${rewardsHtml}</p>`;
                    rewardsEl.style.display = 'block';
                } else {
                    rewardsEl.innerHTML = '';
                    rewardsEl.style.display = 'none';
                }

                const buttonsEl = modal.querySelector('#mission-modal-buttons');
                buttonsEl.innerHTML = `<button class="btn w-full btn-pulse-green" data-action="complete-mission" data-mission-id="${mission.id}">${mission.completion.buttonText}</button>`;
            }
        };
        this.queueModal('mission-modal', mission.completion.title, mission.completion.text, null, options);
    }

    flashObjectiveProgress() {
        const progressEl = this.cache.stickyObjectiveProgress;
        if (progressEl) {
            progressEl.classList.add('objective-progress-flash');
            setTimeout(() => {
                progressEl.classList.remove('objective-progress-flash');
            }, 700);
        }
    }
    
    // --- New DOM Abstraction Methods ---
    getModalIdFromEvent(e) {
        const modalBackdrop = e.target.closest('.modal-backdrop');
        if (modalBackdrop && modalBackdrop.id && !e.target.closest('.modal-content')) {
            return modalBackdrop.id;
        }
        return null;
    }

    isClickInside(e, selector) {
        return e.target.closest(selector) !== null;
    }

    getTooltipContent(e) {
        const tooltipTarget = e.target.closest('[data-tooltip]');
        if (tooltipTarget) {
            return tooltipTarget.dataset.tooltip;
        }
        return null;
    }

    showGameContainer() {
        this.cache.gameContainer.classList.remove('hidden');
    }

    /**
     * @JSDoc
     * @method applyShipTransactionAnimation
     * @description Applies the minimization animation to a ship card.
     * @param {string} shipId - The ID of the ship being transacted.
     */
    applyShipTransactionAnimation(shipId) {
        const carousel = this.cache.hangarScreen.querySelector('#hangar-carousel');
        if (!carousel) return;

        const pages = Array.from(carousel.children);
        const pageToAnimate = pages.find(p => {
            const button = p.querySelector(`[data-ship-id="${shipId}"]`);
            return button !== null;
        });

        if (pageToAnimate) {
            pageToAnimate.classList.add('ship-page-minimizing');
        }
    }
}
--- END OF FILE: ./js/services/UIManager.js ---

--- START OF FILE: ./js/services/handlers/MarketEventHandler.js ---
// js/services/handlers/MarketEventHandler.js
/**
 * @fileoverview Handles all user interactions within the market commodity cards,
 * including buy/sell mode toggling, quantity adjustments, and trade confirmations.
 */
import { formatCredits, calculateInventoryUsed } from '../../utils.js';
import { ACTION_IDS } from '../../data/constants.js';

export class MarketEventHandler {
    /**
     * @param {import('../GameState.js').GameState} gameState The central game state object.
     * @param {import('../SimulationService.js').SimulationService} simulationService The core game logic engine.
     * @param {import('../UIManager.js').UIManager} uiManager The UI rendering service.
     */
    constructor(gameState, simulationService, uiManager) {
        this.gameState = gameState;
        this.simulationService = simulationService;
        this.uiManager = uiManager;
    }

    /**
     * Handles real-time input events from the market quantity field.
     * @param {Event} e The input event.
     */
    handleInput(e) {
        const qtyInput = e.target.closest('.transaction-controls input[type="number"]');
        if (qtyInput) {
            const controls = qtyInput.closest('.transaction-controls');
            const { goodId, mode } = controls.dataset;
            const quantity = parseInt(qtyInput.value, 10) || 0;
            this.uiManager.updateMarketCardDisplay(goodId, quantity, mode);
        }
    }

    /**
     * Handles click events within the market transaction controls.
     * @param {Event} e The click event object.
     * @param {HTMLElement} actionTarget The DOM element with the data-action attribute.
     */
    handleClick(e, actionTarget) {
        const { action } = actionTarget.dataset;

        switch (action) {
            case 'toggle-trade-mode':
            case 'confirm-trade':
            case 'set-max-trade':
            case ACTION_IDS.INCREMENT:
            case ACTION_IDS.DECREMENT:
                this._performMarketAction(actionTarget, action, e);
                break;
        }
    }

    /**
     * Executes a specific market action based on the clicked element.
     * @param {HTMLElement} target - The element that was clicked.
     * @param {string} action - The specific action to perform.
     * @param {Event} [e] - The original click event, for effects.
     * @private
     */
    _performMarketAction(target, action, e) {
        const controls = target.closest('.transaction-controls');
        if (!controls) return;

        const { goodId, mode } = controls.dataset;
        const qtyInput = controls.querySelector('input');
        const state = this.gameState.getState();

        switch (action) {
            case 'toggle-trade-mode': {
                const newMode = mode === 'buy' ? 'sell' : 'buy';
                controls.dataset.mode = newMode;
                this.uiManager.updateMarketCardDisplay(goodId, parseInt(qtyInput.value) || 0, newMode);
                break;
            }
            case 'confirm-trade': {
                const quantity = parseInt(qtyInput.value) || 0;
                if (quantity <= 0) return;

                const result = (mode === 'buy')
                    ? this.simulationService.buyItem(goodId, quantity)
                    : this.simulationService.sellItem(goodId, quantity);

                if (result) {
                    const value = (mode === 'buy') ? this.uiManager.getItemPrice(state, goodId) * quantity : result;
                    const text = mode === 'buy' ? `-${formatCredits(value, false)}` : `+${formatCredits(value, false)}`;
                    const color = mode === 'buy' ? '#f87171' : '#34d399';
                    this.uiManager.createFloatingText(text, e.clientX, e.clientY, color);
                }
                break;
            }
            case 'set-max-trade': {
                const ship = this.simulationService._getActiveShip();
                const inventory = this.simulationService._getActiveInventory();
                if (mode === 'sell') {
                    qtyInput.value = inventory[goodId]?.quantity || 0;
                } else { // 'buy'
                    const price = this.uiManager.getItemPrice(state, goodId);
                    const space = ship.cargoCapacity - calculateInventoryUsed(inventory);
                    const canAfford = price > 0 ? Math.floor(state.player.credits / price) : Infinity;
                    const stock = state.market.inventory[state.currentLocationId][goodId].quantity;
                    qtyInput.value = Math.max(0, Math.min(space, canAfford, stock));
                }
                this.uiManager.updateMarketCardDisplay(goodId, parseInt(qtyInput.value) || 0, mode);
                break;
            }
            case ACTION_IDS.INCREMENT:
            case ACTION_IDS.DECREMENT: {
                let val = parseInt(qtyInput.value) || 0;
                qtyInput.value = (action === ACTION_IDS.INCREMENT) ? val + 1 : Math.max(0, val - 1);
                this.uiManager.updateMarketCardDisplay(goodId, parseInt(qtyInput.value) || 0, mode);
                break;
            }
        }
    }
}
--- END OF FILE: ./js/services/handlers/MarketEventHandler.js ---

--- START OF FILE: ./js/services/handlers/HoldEventHandler.js ---
// js/services/handlers/HoldEventHandler.js
/**
 * @fileoverview Manages "hold-to-act" functionality, specifically for the
 * refueling and repairing services which require continuous action while a
 * button is pressed.
 */
import { formatCredits } from '../../utils.js';

export class HoldEventHandler {
    /**
     * @param {import('../GameState.js').GameState} gameState The central game state object.
     * @param {import('../SimulationService.js').SimulationService} simulationService The core game logic engine.
     * @param {import('../UIManager.js').UIManager} uiManager The UI rendering service.
     */
    constructor(gameState, simulationService, uiManager) {
        this.gameState = gameState;
        this.simulationService = simulationService;
        this.uiManager = uiManager;

        this.refuelInterval = null;
        this.repairInterval = null;
    }

    /**
     * Initiates a hold action based on the event target.
     * @param {Event} e The mousedown or touchstart event.
     */
    handleHoldStart(e) {
        if (e.target.closest('#refuel-btn')) {
            this._startRefueling(e.type === 'touchstart');
        }
        if (e.target.closest('#repair-btn')) {
            this._startRepairing(e.type === 'touchstart');
        }
    }

    /**
     * Clears all active hold intervals, stopping any continuous actions.
     */
    handleHoldEnd() {
        this._stopRefueling();
        this._stopRepairing();
    }

    _startRefueling(isTouch = false) {
        if (this.gameState.isGameOver || this.refuelInterval) return;
        this._refuelTick();
        this.refuelInterval = setInterval(() => this._refuelTick(), isTouch ? 200 : 1000);
    }

    _stopRefueling() {
        clearInterval(this.refuelInterval);
        this.refuelInterval = null;
    }

    _refuelTick() {
        const cost = this.simulationService.refuelTick();
        const button = this.uiManager.cache.servicesScreen?.querySelector('#refuel-btn');
        if (cost > 0 && button) {
            const rect = button.getBoundingClientRect();
            this.uiManager.createFloatingText(`-${formatCredits(cost, false)}`, rect.left + (rect.width / 2), rect.top, '#f87171');
            this.uiManager.updateServicesScreen(this.gameState.getState());
        } else {
            this._stopRefueling();
        }
    }

    _startRepairing(isTouch = false) {
        if (this.gameState.isGameOver || this.repairInterval) return;
        this._repairTick();
        this.repairInterval = setInterval(() => this._repairTick(), isTouch ? 200 : 1000);
    }

    _stopRepairing() {
        clearInterval(this.repairInterval);
        this.repairInterval = null;
    }

    _repairTick() {
        const cost = this.simulationService.repairTick();
        const button = this.uiManager.cache.servicesScreen?.querySelector('#repair-btn');
        if (cost > 0 && button) {
            const rect = button.getBoundingClientRect();
            this.uiManager.createFloatingText(`-${formatCredits(cost, false)}`, rect.left + (rect.width / 2), rect.top, '#f87171');
            this.uiManager.updateServicesScreen(this.gameState.getState());
        } else {
            this._stopRepairing();
        }
    }
}
--- END OF FILE: ./js/services/handlers/HoldEventHandler.js ---

--- START OF FILE: ./js/services/handlers/ActionClickHandler.js ---
// js/services/handlers/ActionClickHandler.js
/**
 * @fileoverview Handles the primary routing of 'data-action' click events,
 * delegating them to the appropriate services. This module focuses on general
 * actions like navigation, modal triggers, and simple state changes, while
 * more complex interactions are handled by other specialized handlers.
 */
import { DB } from '../../data/database.js';
import { ACTION_IDS, NAV_IDS, SCREEN_IDS } from '../../data/constants.js';

export class ActionClickHandler {
    /**
     * @param {import('../GameState.js').GameState} gameState The central game state object.
     * @param {import('../SimulationService.js').SimulationService} simulationService The core game logic engine.
     * @param {import('../UIManager.js').UIManager} uiManager The UI rendering service.
     * @param {import('../TutorialService.js').TutorialService} tutorialService The tutorial management service.
     */
    constructor(gameState, simulationService, uiManager, tutorialService) {
        this.gameState = gameState;
        this.simulationService = simulationService;
        this.uiManager = uiManager;
        this.tutorialService = tutorialService;
    }

    /**
     * Handles a delegated click event if it matches a data-action.
     * @param {Event} e The click event object.
     * @param {HTMLElement} actionTarget The DOM element with the data-action attribute.
     */
    handle(e, actionTarget) {
        const state = this.gameState.getState();
        if (actionTarget.hasAttribute('disabled')) return;

        const { action, ...dataset } = actionTarget.dataset;
        let actionData = null; // For the TutorialService

        switch (action) {
            // --- Ship Actions (Hangar/Shipyard) ---
            case ACTION_IDS.BUY_SHIP:
            case ACTION_IDS.SELL_SHIP: {
                const { shipId } = dataset;
                if (!shipId) return;
                e.stopPropagation();
                this.simulationService.initiateShipTransactionAnimation(shipId, action, e);
                if (action === ACTION_IDS.BUY_SHIP) {
                    actionData = { type: 'ACTION', action: ACTION_IDS.BUY_SHIP };
                }
                break;
            }
            case ACTION_IDS.SELECT_SHIP: {
                const { shipId } = dataset;
                if (!shipId) return;
                this.simulationService.setActiveShip(shipId);
                actionData = { type: 'ACTION', action: ACTION_IDS.SELECT_SHIP };
                break;
            }

            // --- Hangar UI ---
            case ACTION_IDS.TOGGLE_HANGAR_MODE:
                if (dataset.mode && this.gameState.uiState.hangarShipyardToggleState !== dataset.mode) {
                    this.gameState.uiState.hangarShipyardToggleState = dataset.mode;
                    this.gameState.setState({});
                }
                break;
            case ACTION_IDS.SET_HANGAR_PAGE: {
                const newIndex = parseInt(dataset.index, 10);
                const isHangarMode = this.gameState.uiState.hangarShipyardToggleState === 'hangar';

                const carousel = document.getElementById('hangar-carousel');
                if (carousel) {
                    const currentIndex = isHangarMode ? this.gameState.uiState.hangarActiveIndex : this.gameState.uiState.shipyardActiveIndex;
                    const pagesToSkip = Math.abs(newIndex - currentIndex);
                    const duration = Math.min(0.8, 0.2 + pagesToSkip * 0.1);
                    carousel.style.transitionDuration = `${duration}s`;

                    this.simulationService.setHangarCarouselIndex(newIndex, isHangarMode ? 'hangar' : 'shipyard');

                    setTimeout(() => {
                        if (carousel) carousel.style.transitionDuration = '';
                    }, duration * 1000);
                } else {
                    this.simulationService.setHangarCarouselIndex(newIndex, isHangarMode ? 'hangar' : 'shipyard');
                }
                break;
            }

            // --- Navigation & Screen Changes ---
            case ACTION_IDS.SET_SCREEN:
                if (dataset.navId === state.activeNav && actionTarget.tagName === 'DIV') {
                    this.gameState.subNavCollapsed = !this.gameState.subNavCollapsed;
                    this.uiManager.render(this.gameState.getState());
                } else {
                    this.gameState.subNavCollapsed = false;
                    this.simulationService.setScreen(dataset.navId, dataset.screenId);
                }
                actionData = { type: 'ACTION', action: ACTION_IDS.SET_SCREEN, navId: dataset.navId, screenId: dataset.screenId };
                break;
            case ACTION_IDS.TRAVEL:
                this.uiManager.hideModal('launch-modal');
                this.simulationService.travelTo(dataset.locationId);
                actionData = { type: 'ACTION', action: ACTION_IDS.TRAVEL };
                break;

            // --- Modals ---
            case 'show-mission-modal':
                this.uiManager.showMissionModal(dataset.missionId);
                actionData = { type: 'ACTION', action: 'show-mission-modal' };
                break;
            case 'show_cargo_detail':
                this.uiManager.showCargoDetailModal(state, dataset.goodId);
                break;
            case 'show-launch-modal':
                this.uiManager.showLaunchModal(dataset.locationId);
                break;

            // --- Mission Actions ---
            case 'accept-mission':
                this.simulationService.missionService.acceptMission(dataset.missionId);
                this.uiManager.hideModal('mission-modal');
                actionData = { type: 'ACTION', action: 'accept-mission', missionId: dataset.missionId };
                break;
            case 'abandon-mission':
                this.simulationService.missionService.abandonMission();
                this.uiManager.hideModal('mission-modal');
                break;
            case 'complete-mission':
                this.simulationService.missionService.completeActiveMission();
                this.uiManager.hideModal('mission-modal');
                actionData = { type: 'ACTION', action: 'complete-mission' };
                break;

            // --- Finance & Licenses ---
            case ACTION_IDS.PAY_DEBT:
                this.simulationService.payOffDebt();
                break;
            case ACTION_IDS.TAKE_LOAN:
                this.simulationService.takeLoan(JSON.parse(dataset.loanDetails));
                break;
            case ACTION_IDS.PURCHASE_INTEL:
                this.simulationService.purchaseIntel(parseInt(dataset.cost));
                break;
            case ACTION_IDS.ACQUIRE_LICENSE:
                this._handleAcquireLicense(dataset.licenseId);
                break;

            // --- Market Card Minimization ---
            case ACTION_IDS.TOGGLE_MARKET_CARD_VIEW:
                if (dataset.goodId) {
                    this.gameState.uiState.marketCardMinimized[dataset.goodId] = !this.gameState.uiState.marketCardMinimized[dataset.goodId];
                    this.gameState.setState({});
                }
                break;
        }

        if (actionData) {
            this.tutorialService.checkState(actionData);
        }
    }

    /**
     * Handles the UI flow for acquiring a trade license.
     * @param {string} licenseId The ID of the license to acquire.
     * @private
     */
    _handleAcquireLicense(licenseId) {
        const license = DB.LICENSES[licenseId];
        if (!license) return;

        if (license.type === 'purchase') {
            const description = `${license.description}<br><br>Cost: <b class='hl-yellow'>${formatCredits(license.cost)}</b>`;
            this.uiManager.queueModal('event-modal', `Purchase ${license.name}?`, description, null, {
                customSetup: (modal, closeHandler) => {
                    const btnContainer = modal.querySelector('#event-button-container');
                    btnContainer.innerHTML = `
                        <button id="confirm-license-purchase" class="btn btn-pulse-green">Confirm</button>
                        <button id="cancel-license-purchase" class="btn">Cancel</button>
                    `;
                    modal.querySelector('#confirm-license-purchase').onclick = () => {
                        const result = this.simulationService.purchaseLicense(licenseId);
                        if (!result.success && result.error === 'INSUFFICIENT_FUNDS') {
                            this.uiManager.queueModal('event-modal', 'Purchase Failed', `You cannot afford the ${formatCredits(license.cost)} fee for this license.`);
                        }
                        closeHandler();
                    };
                    modal.querySelector('#cancel-license-purchase').onclick = closeHandler;
                }
            });
        } else if (license.type === 'mission') {
            this.uiManager.queueModal('event-modal', license.name, license.guidanceText);
        }
    }
}
--- END OF FILE: ./js/services/handlers/ActionClickHandler.js ---

--- START OF FILE: ./js/services/handlers/TooltipHandler.js ---
// js/services/handlers/TooltipHandler.js
/**
 * @fileoverview Manages the display and lifecycle of tooltips, price graphs,
 * and other contextual pop-ups that appear on user interaction (hover or click).
 */
import { ACTION_IDS } from '../../data/constants.js';

export class TooltipHandler {
    /**
     * @param {import('../GameState.js').GameState} gameState The central game state object.
     * @param {import('../UIManager.js').UIManager} uiManager The UI rendering service.
     */
    constructor(gameState, uiManager) {
        this.gameState = gameState;
        this.uiManager = uiManager;
        this.activeTooltipTarget = null;
        this.activeStatusTooltip = null;
    }

    /**
     * Handles click events to manage tooltips, primarily for mobile and special cases.
     * @param {Event} e The click event.
     */
    handleClick(e) {
        const actionTarget = e.target.closest('[data-action]');

        // --- Pre-action Cleanup ---
        if (this.activeStatusTooltip && !this.uiManager.isClickInside(e, '[data-action="toggle-tooltip"]')) {
            this.activeStatusTooltip.classList.remove('visible');
            this.activeStatusTooltip = null;
        }
        if (this.uiManager.isClickInside(e, '#graph-tooltip, #generic-tooltip')) {
            this.uiManager.hideGraph();
            this.uiManager.hideGenericTooltip();
            this.activeTooltipTarget = null;
            return;
        }
        if (this.activeTooltipTarget && actionTarget !== this.activeTooltipTarget) {
            this.uiManager.hideGraph();
            this.uiManager.hideGenericTooltip();
            this.activeTooltipTarget = null;
        }
        
        // --- Action Handling ---
        if (actionTarget) {
            const { action } = actionTarget.dataset;
            switch(action) {
                case 'toggle-tooltip':
                    this._toggleStatusTooltip(actionTarget);
                    return;
                case ACTION_IDS.SHOW_PRICE_GRAPH:
                case ACTION_IDS.SHOW_FINANCE_GRAPH:
                    if (this.uiManager.isMobile) {
                        this.uiManager.hideGenericTooltip();
                        if (this.activeTooltipTarget === actionTarget) {
                            this.uiManager.hideGraph();
                            this.activeTooltipTarget = null;
                        } else {
                            this.uiManager.showGraph(actionTarget, this.gameState.getState());
                            this.activeTooltipTarget = actionTarget;
                        }
                    }
                    break;
            }
        }
        
        if (this.uiManager.isMobile) {
            this._handleMobileTooltip(e);
        }

        this._handleLoreAndTutorialLog(e);
    }

    /**
     * Handles mouseover events for desktop tooltips and graphs.
     * @param {Event} e The mouseover event.
     */
    handleMouseOver(e) {
        if (this.uiManager.isMobile) return;
        const graphTarget = e.target.closest(`[data-action="${ACTION_IDS.SHOW_PRICE_GRAPH}"], [data-action="${ACTION_IDS.SHOW_FINANCE_GRAPH}"]`);
        if (graphTarget) {
            this.uiManager.showGraph(graphTarget, this.gameState.getState());
        }
    }

    /**
     * Handles mouseout events for desktop tooltips and graphs.
     * @param {Event} e The mouseout event.
     */
    handleMouseOut(e) {
        if (this.uiManager.isMobile) return;
        const graphTarget = e.target.closest(`[data-action="${ACTION_IDS.SHOW_PRICE_GRAPH}"], [data-action="${ACTION_IDS.SHOW_FINANCE_GRAPH}"]`);
        if (graphTarget) {
            this.uiManager.hideGraph();
        }
    }

    _toggleStatusTooltip(target) {
        const tooltip = target.querySelector('.status-tooltip');
        if (!tooltip) return;
        if (this.activeStatusTooltip === tooltip) {
            tooltip.classList.remove('visible');
            this.activeStatusTooltip = null;
        } else {
            if (this.activeStatusTooltip) this.activeStatusTooltip.classList.remove('visible');
            tooltip.classList.add('visible');
            this.activeStatusTooltip = tooltip;
        }
    }

    _handleMobileTooltip(e) {
        const tooltipTarget = e.target.closest('[data-tooltip]');
        if (tooltipTarget && !tooltipTarget.closest('[data-action="toggle-tooltip"]')) {
            this.uiManager.hideGraph();
            if (this.activeTooltipTarget === tooltipTarget) {
                this.uiManager.hideGenericTooltip();
                this.activeTooltipTarget = null;
            } else {
                this.uiManager.showGenericTooltip(tooltipTarget, tooltipTarget.dataset.tooltip);
                this.activeTooltipTarget = tooltipTarget;
            }
        }
    }

    _handleLoreAndTutorialLog(e) {
        const tutorialTrigger = e.target.closest('.tutorial-container');
        const loreTrigger = e.target.closest('.lore-container');

        const visibleTooltip = document.querySelector('.lore-tooltip.visible, .tutorial-tooltip.visible');
        if (visibleTooltip && !e.target.closest('.lore-tooltip, .tutorial-tooltip')) {
            visibleTooltip.classList.remove('visible');
        }
        
        if (loreTrigger) {
            loreTrigger.querySelector('.lore-tooltip')?.classList.toggle('visible');
        }

        if (tutorialTrigger) {
            this.uiManager.showTutorialLogModal({
                seenBatches: this.gameState.tutorials.seenBatchIds,
                onSelect: (batchId) => this.tutorialService.triggerBatch(batchId)
            });
        }
    }
}
--- END OF FILE: ./js/services/handlers/TooltipHandler.js ---

--- START OF FILE: ./js/services/handlers/CarouselEventHandler.js ---
// js/services/handlers/CarouselEventHandler.js
/**
 * @fileoverview Manages all pointer, touch, and wheel events for the
 * hangar/shipyard carousel, providing a smooth drag-and-swipe interface.
 */
export class CarouselEventHandler {
    /**
     * @param {import('../GameState.js').GameState} gameState The central game state object.
     * @param {import('../SimulationService.js').SimulationService} simulationService The core game logic engine.
     */
    constructor(gameState, simulationService) {
        this.gameState = gameState;
        this.simulationService = simulationService;

        this.isScrolling = false;
        this.scrollTimeout = null;

        this.state = {
            isDragging: false,
            startX: 0,
            startTranslate: 0,
            currentTranslate: 0,
            activeCarousel: null,
            containerWidth: 0,
            pageCount: 0,
            currentIndex: 0,
            moved: false
        };
    }

    /**
     * Handles wheel events (mouse scroll) over the carousel to navigate between pages.
     * @param {WheelEvent} e The wheel event.
     */
    handleWheel(e) {
        if (this.isScrolling) return;

        let direction = e.deltaY > 0 ? 'next' : 'prev';
        this.simulationService.cycleHangarCarousel(direction);

        this.isScrolling = true;
        clearTimeout(this.scrollTimeout);
        this.scrollTimeout = setTimeout(() => {
            this.isScrolling = false;
        }, 300); // Throttle scroll events
    }

    /**
     * Initiates a drag sequence on the carousel.
     * @param {MouseEvent|TouchEvent} e The mousedown or touchstart event.
     */
    handleDragStart(e) {
        const carouselContainer = e.target.closest('.carousel-container');
        const carousel = carouselContainer ? carouselContainer.querySelector('#hangar-carousel') : null;

        if (e.target.closest('.action-button') || !carousel || carousel.children.length <= 1) {
            this.state.isDragging = false;
            return;
        }
        e.preventDefault();

        const gameState = this.gameState.getState();
        const isHangarMode = gameState.uiState.hangarShipyardToggleState === 'hangar';

        this.state.isDragging = true;
        this.state.activeCarousel = carousel;
        this.state.startX = e.pageX ?? e.touches[0].pageX;
        this.state.containerWidth = carousel.parentElement.offsetWidth;
        this.state.pageCount = carousel.children.length;
        this.state.currentIndex = isHangarMode ? (gameState.uiState.hangarActiveIndex || 0) : (gameState.uiState.shipyardActiveIndex || 0);
        this.state.startTranslate = -this.state.currentIndex * this.state.containerWidth;
        this.state.currentTranslate = this.state.startTranslate;
        this.state.moved = false;

        carousel.style.transitionDuration = '0s'; // Make drag instant
        document.body.style.cursor = 'grabbing';
    }

    /**
     * Handles the movement during a carousel drag.
     * @param {MouseEvent|TouchEvent} e The mousemove or touchmove event.
     */
    handleDragMove(e) {
        if (!this.state.isDragging) return;
        e.preventDefault();

        const currentX = e.pageX ?? e.touches[0].pageX;
        const diff = currentX - this.state.startX;
        this.state.currentTranslate = this.state.startTranslate + diff;

        if (Math.abs(diff) > 10) this.state.moved = true;

        if (this.state.activeCarousel) {
            this.state.activeCarousel.style.transform = `translateX(${this.state.currentTranslate}px)`;
        }
    }

    /**
     * Ends the drag sequence and snaps the carousel to the nearest or intended page.
     */
    handleDragEnd() {
        if (!this.state.isDragging) return;

        const { activeCarousel, startTranslate, currentTranslate, currentIndex, containerWidth, pageCount } = this.state;

        this.state.isDragging = false;
        document.body.style.cursor = 'default';

        if (!activeCarousel) return;

        activeCarousel.style.transitionDuration = ''; // Revert to CSS-defined duration for smooth snap

        const movedBy = currentTranslate - startTranslate;
        let newIndex = currentIndex;
        const threshold = containerWidth / 4;

        if (movedBy < -threshold && currentIndex < pageCount - 1) {
            newIndex++;
        } else if (movedBy > threshold && currentIndex > 0) {
            newIndex--;
        }

        const mode = this.gameState.uiState.hangarShipyardToggleState;
        this.simulationService.setHangarCarouselIndex(newIndex, mode);

        // A timeout is used to reset the 'moved' flag, preventing a click event from firing immediately after a drag.
        setTimeout(() => {
            this.state.moved = false;
        }, 50);
    }
    
    /**
     * Returns whether the carousel was moved during the last drag operation.
     * Used by EventManager to suppress clicks after a drag.
     * @returns {boolean}
     */
    wasMoved() {
        return this.state.moved;
    }
}
--- END OF FILE: ./js/services/handlers/CarouselEventHandler.js ---

--- START OF FILE: ./js/services/player/PlayerActionService.js ---
// js/services/player/PlayerActionService.js
/**
 * @fileoverview Manages all direct, player-initiated actions that have an
 * immediate effect, such as buying/selling commodities, purchasing ships,
 * and using station services.
 */
import { DB } from '../../data/database.js';
import { formatCredits, calculateInventoryUsed } from '../../utils.js';
import { GAME_RULES, PERK_IDS, ACTION_IDS, LOCATION_IDS } from '../../data/constants.js';

export class PlayerActionService {
    /**
     * @param {import('../GameState.js').GameState} gameState
     * @param {import('../UIManager.js').UIManager} uiManager
     * @param {import('../MissionService.js').MissionService} missionService
     * @param {import('../simulation/MarketService.js').MarketService} marketService
     * @param {import('../world/TimeService.js').TimeService} timeService
     * @param {import('../../services/LoggingService.js').Logger} logger
     * @param {import('../SimulationService.js').SimulationService} simulationServiceFacade
     */
    constructor(gameState, uiManager, missionService, marketService, timeService, logger, simulationServiceFacade) {
        this.gameState = gameState;
        this.uiManager = uiManager;
        this.missionService = missionService;
        this.marketService = marketService;
        this.timeService = timeService;
        this.logger = logger;
        this.simulationService = simulationServiceFacade;
    }

    /**
     * Handles the purchase of a specified quantity of a commodity from the current market.
     * @param {string} goodId - The COMMODITY_ID of the item to purchase.
     * @param {number} quantity - The integer amount to buy.
     * @returns {boolean} - True if the purchase was successful, false otherwise.
     */
    buyItem(goodId, quantity) {
        const state = this.gameState.getState();
        if (state.isGameOver || quantity <= 0) return false;
        
        const good = DB.COMMODITIES.find(c=>c.id===goodId);
        if (good.licenseId && !state.player.unlockedLicenseIds.includes(good.licenseId)) {
            this.uiManager.queueModal('event-modal', "License Required", `You do not have the required license to trade ${good.name}.`);
            return false;
        }

        const price = this.uiManager.getItemPrice(state, goodId);
        const totalCost = price * quantity;
        const marketStock = state.market.inventory[state.currentLocationId][goodId].quantity;

        if (marketStock <= 0) { this.uiManager.queueModal('event-modal', "Sold Out", `This station has no more ${good.name} available.`); return false; }
        if (quantity > marketStock) { this.uiManager.queueModal('event-modal', "Limited Stock", `This station only has ${marketStock} units available.`); return false; }
        
        const activeShip = this.simulationService._getActiveShip();
        const activeInventory = this.simulationService._getActiveInventory();
        if (calculateInventoryUsed(activeInventory) + quantity > activeShip.cargoCapacity) {
             this.uiManager.queueModal('event-modal', "Cargo Hold Full", "You don't have enough space.");
            return false;
        }
        if (state.player.credits < totalCost) { this.uiManager.queueModal('event-modal', "Insufficient Funds", "Your credit balance is too low."); return false; }

        const inventoryItem = this.gameState.market.inventory[state.currentLocationId][goodId];
        inventoryItem.quantity -= quantity;

        const playerInvItem = activeInventory[goodId];
        playerInvItem.avgCost = ((playerInvItem.quantity * playerInvItem.avgCost) + totalCost) / (playerInvItem.quantity + quantity);
        playerInvItem.quantity += quantity;
        
        this.gameState.player.credits -= totalCost;
        this.logger.info.player(state.day, 'BUY', `Bought ${quantity}x ${good.name} for ${formatCredits(totalCost)}`);
        this.simulationService._logConsolidatedTrade(good.name, quantity, -totalCost);
        this.timeService._checkMilestones();
        this.missionService.checkTriggers();
        
        this.marketService.applyMarketImpact(goodId, quantity, 'buy');

        this.gameState.setState({});

        return true;
    }

    /**
     * Sells a specified quantity of a commodity to the current market.
     * @param {string} goodId - The COMMODITY_ID of the item to sell.
     * @param {number} quantity - The integer amount to sell.
     * @returns {number} - The total value of the sale, or 0 if failed.
     */
    sellItem(goodId, quantity) {
        const state = this.gameState.getState();
        if (state.isGameOver || quantity <= 0) return 0;
        
        const good = DB.COMMODITIES.find(c=>c.id===goodId);
        if (good.licenseId && !state.player.unlockedLicenseIds.includes(good.licenseId)) {
            this.uiManager.queueModal('event-modal', "License Required", `You do not have the required license to trade ${good.name}.`);
            return 0;
        }

        const activeInventory = this.simulationService._getActiveInventory();
        const item = activeInventory[goodId];
        if (!item || item.quantity < quantity) {
            this.uiManager.queueModal('event-modal', "Insufficient Inventory", `You do not have ${quantity} units of ${good.name} to sell.`);
            return 0;
        }

        const { totalPrice } = this._calculateDiminishingReturns(goodId, quantity, state.currentLocationId);
        let totalSaleValue = totalPrice;
        
        const profit = totalSaleValue - (item.avgCost * quantity);
        if (profit > 0) {
            let totalBonus = (state.player.activePerks[PERK_IDS.TRADEMASTER] ? DB.PERKS[PERK_IDS.TRADEMASTER].profitBonus : 0) + (state.player.birthdayProfitBonus || 0);
            totalSaleValue += profit * totalBonus;
        }
        
        totalSaleValue = Math.floor(totalSaleValue);
        this.gameState.player.credits += totalSaleValue;
        item.quantity -= quantity;
        if (item.quantity === 0) item.avgCost = 0;

        const inventoryItem = this.gameState.market.inventory[state.currentLocationId][goodId];
        inventoryItem.quantity += quantity;
        
        this.logger.info.player(state.day, 'SELL', `Sold ${quantity}x ${good.name} for ${formatCredits(totalSaleValue)}`);
        this.simulationService._logConsolidatedTrade(good.name, quantity, totalSaleValue);
        
        this.timeService._checkMilestones();
        this.missionService.checkTriggers();
        
        this.marketService.applyMarketImpact(goodId, quantity, 'sell');

        this.gameState.setState({});
        
        return totalSaleValue;
    }

    /**
     * Coordinates the ship purchase/sale animation and the actual transaction.
     * @param {string} shipId - The ID of the ship being bought or sold.
     * @param {string} action - The type of transaction ('buy-ship' or 'sell-ship').
     * @param {Event} event - The original click event for visual effects.
     */
    initiateShipTransactionAnimation(shipId, action, event) {
        const transactionCallback = () => {
            if (action === ACTION_IDS.BUY_SHIP) {
                this.buyShip(shipId, event);
            } else if (action === ACTION_IDS.SELL_SHIP) {
                this.sellShip(shipId, event);
            }
        };

        this.uiManager.applyShipTransactionAnimation(shipId, transactionCallback);
    }

    /**
     * Purchases a new ship and adds it to the player's hangar.
     * @param {string} shipId - The ID of the ship to buy.
     * @param {Event} [event] - The click event for placing floating text.
     * @returns {object|null} - The purchased ship object on success, otherwise null.
     */
    buyShip(shipId, event) {
        const ship = DB.SHIPS[shipId];
        if (!ship) {
            this.logger.error('PlayerActionService', `buyShip called with invalid shipId: ${shipId}`);
            return null;
        }
        if (this.gameState.player.credits < ship.price) {
            this.uiManager.queueModal('event-modal', "Insufficient Funds", "You cannot afford this ship.");
            return null;
        }
        
        this.gameState.player.credits -= ship.price;
        this.logger.info.player(this.gameState.day, 'SHIP_PURCHASE', `Purchased ${ship.name} for ${formatCredits(ship.price)}.`);
        if (event) {
            this.uiManager.createFloatingText(`-${formatCredits(ship.price, false)}`, event.clientX, event.clientY, '#f87171');
        }
        this.simulationService._logTransaction('ship', -ship.price, `Purchased ${ship.name}`);
        this.simulationService.addShipToHangar(shipId);

        if (['S', 'O'].includes(ship.class)) {
            this.uiManager.triggerEffect('systemSurge', { theme: 'red', text: 'TOP CLASS' });
        } else {
            this.uiManager.triggerEffect('systemSurge', { theme: 'silver', text: 'VESSEL ACQUIRED' });
        }

        if (this.gameState.tutorials.activeBatchId === 'intro_hangar') {
            this.simulationService.setHangarShipyardMode('hangar');
            this.simulationService.tutorialService.checkState({ type: 'ACTION', action: ACTION_IDS.BUY_SHIP });
        }

        this.gameState.setState({
            uiState: {
                ...this.gameState.uiState,
                lastTransactionTimestamp: Date.now()
            }
        });
        return ship;
    }

    /**
     * Sells a ship from the player's hangar.
     * @param {string} shipId - The ID of the ship to sell.
     * @param {Event} [event] - The click event for placing floating text.
     * @returns {number|false} - The sale price, or false if the sale is not allowed.
     */
    sellShip(shipId, event) {
        const state = this.gameState.getState();
        if (state.player.ownedShipIds.length <= 1) {
            this.uiManager.queueModal('event-modal', "Action Blocked", "You cannot sell your last remaining ship.");
            return false;
        }
        if (shipId === state.player.activeShipId) {
            this.uiManager.queueModal('event-modal', "Action Blocked", "You cannot sell your active ship.");
            return false;
        }
        if (calculateInventoryUsed(state.player.inventories[shipId]) > 0) {
            this.uiManager.queueModal('event-modal', 'Cannot Sell Ship', 'This vessel\'s cargo hold is not empty.');
            return false;
        }

        const ship = DB.SHIPS[shipId];
        if (!ship) {
            this.logger.error('PlayerActionService', `sellShip called with invalid shipId: ${shipId}`);
            return false;
        }
        const salePrice = Math.floor(ship.price * GAME_RULES.SHIP_SELL_MODIFIER);
        this.gameState.player.credits += salePrice;
        this.logger.info.player(this.gameState.day, 'SHIP_SALE', `Sold ${ship.name} for ${formatCredits(salePrice)}.`);
        if (event) {
            this.uiManager.createFloatingText(`+${formatCredits(salePrice, false)}`, event.clientX, event.clientY, '#34d399');
        }
        this.simulationService._logTransaction('ship', salePrice, `Sold ${ship.name}`);
        
        const shipIndex = this.gameState.player.ownedShipIds.indexOf(shipId);
        this.gameState.player.ownedShipIds = this.gameState.player.ownedShipIds.filter(id => id !== shipId);
        delete this.gameState.player.shipStates[shipId];
        delete this.gameState.player.inventories[shipId];

        let newActiveIndex = this.gameState.uiState.hangarActiveIndex;
        if (shipIndex < newActiveIndex) {
            newActiveIndex--;
        }
        if (newActiveIndex >= this.gameState.player.ownedShipIds.length) {
            newActiveIndex = Math.max(0, this.gameState.player.ownedShipIds.length - 1);
        }

        this.uiManager.queueModal('event-modal', "Vessel Sold", `You sold the ${ship.name} for ${formatCredits(salePrice)}.`);
        
        this.gameState.setState({
            uiState: {
                ...this.gameState.uiState,
                hangarActiveIndex: newActiveIndex,
                lastTransactionTimestamp: Date.now()
            }
        });
        return salePrice;
    }

    /**
     * Sets the player's currently active ship.
     * @param {string} shipId - The ID of the ship to make active.
     */
    setActiveShip(shipId) {
        if (!this.gameState.player.ownedShipIds.includes(shipId)) return;
        this.gameState.player.activeShipId = shipId;
        
        const newIndex = this.gameState.player.ownedShipIds.indexOf(shipId);
        if (newIndex !== -1) {
            this.gameState.uiState.hangarActiveIndex = newIndex;
        }

        this.logger.info.player(this.gameState.day, 'SET_ACTIVE_SHIP', `Boarded the ${DB.SHIPS[shipId].name}.`);

        if (this.gameState.introSequenceActive) {
            this.simulationService.tutorialService.checkState({ type: 'ACTION', action: ACTION_IDS.SELECT_SHIP });
        }

        this.gameState.setState({});
    }

    /**
     * Pays off the player's entire outstanding debt.
     */
    payOffDebt() {
        if (this.gameState.isGameOver) return;
        const { player } = this.gameState;
        if (player.credits < player.debt) {
            this.uiManager.queueModal('event-modal', "Insufficient Funds", "You can't afford to pay off your entire debt.");
            return;
        }

        const debtAmount = player.debt;
        player.credits -= debtAmount;
        this.logger.info.player(this.gameState.day, 'DEBT_PAID', `Paid off ${formatCredits(debtAmount)} in debt.`);
        this.simulationService._logTransaction('loan', -debtAmount, `Paid off ${formatCredits(debtAmount)} debt`);
        player.debt = 0;
        player.monthlyInterestAmount = 0;
        player.loanStartDate = null;

        this.uiManager.triggerEffect('systemSurge', { theme: 'tan', text: 'DEBT CLEARED' });
        this.timeService._checkMilestones();
        this.gameState.setState({});
    }
    
    /**
     * Allows the player to take out a loan, adding to their debt.
     * @param {object} loanData - Contains amount, fee, and interest for the loan.
     */
    takeLoan(loanData) {
        const { player, day } = this.gameState;
        if (player.debt > 0) {
            this.uiManager.queueModal('event-modal', "Loan Unavailable", `You must pay off your existing debt first.`);
            return;
        }
        if (player.credits < loanData.fee) {
            this.uiManager.queueModal('event-modal', "Unable to Secure Loan", `The financing fee is ${formatCredits(loanData.fee)}, but you only have ${formatCredits(player.credits)}.`);
            return;
        }

        player.credits -= loanData.fee;
        this.simulationService._logTransaction('loan', -loanData.fee, `Financing fee for ${formatCredits(loanData.amount)} loan`);
        player.credits += loanData.amount;
        this.simulationService._logTransaction('loan', loanData.amount, `Acquired ${formatCredits(loanData.amount)} loan`);

        player.debt += loanData.amount;
        player.monthlyInterestAmount = loanData.interest;
        player.loanStartDate = day;
        player.seenGarnishmentWarning = false;

        const loanDesc = `You've acquired a loan of <span class="hl-blue">${formatCredits(loanData.amount)}</span>.<br>A financing fee of <span class="hl-red">${formatCredits(loanData.fee)}</span> was deducted.`;
        this.uiManager.queueModal('event-modal', "Loan Acquired", loanDesc);
        this.logger.info.player(day, 'LOAN_TAKEN', `Took a loan for ${formatCredits(loanData.amount)}.`);
        this.gameState.setState({});
    }

    /**
     * Purchases a trade license for a specific commodity tier.
     * @param {string} licenseId - The ID of the license to purchase.
     * @returns {object} A structured object indicating success or failure with a specific error code.
     */
    purchaseLicense(licenseId) {
        const license = DB.LICENSES[licenseId];
        const { player, day } = this.gameState;

        if (!license) return { success: false, error: 'INVALID_LICENSE' };
        if (license.type !== 'purchase') return { success: false, error: 'NOT_FOR_PURCHASE' };
        if (player.unlockedLicenseIds.includes(licenseId)) return { success: false, error: 'ALREADY_OWNED' };
        if (player.credits < license.cost) return { success: false, error: 'INSUFFICIENT_FUNDS' };
        
        player.credits -= license.cost;
        player.unlockedLicenseIds.push(licenseId);
        this.logger.info.player(day, 'LICENSE_PURCHASE', `Purchased ${license.name}.`);
        this.simulationService._logTransaction('license', -license.cost, `Purchased ${license.name}`);
        
        this.uiManager.triggerEffect('systemSurge', { theme: 'tan' });
        this.gameState.setState({});
        
        return { success: true };
    }

    /**
     * Purchases market intel, providing a temporary trade advantage.
     * @param {number} cost - The credit cost of the intel.
     */
    purchaseIntel(cost) {
        const { player, currentLocationId, day } = this.gameState;
        if (player.credits < cost) {
            this.uiManager.queueModal('event-modal', "Insufficient Funds", "You can't afford this intel.");
            return;
        }
        
        player.credits -= cost;
        this.logger.info.player(day, 'INTEL_PURCHASE', `Purchased intel for ${formatCredits(cost)}.`);
        this.simulationService._logTransaction('intel', -cost, 'Purchased market intel');
        this.gameState.intel.available[currentLocationId] = false;

        const otherMarkets = DB.MARKETS.filter(m => m.id !== currentLocationId && player.unlockedLocationIds.includes(m.id));
        if (otherMarkets.length === 0) return;

        const targetMarket = otherMarkets[Math.floor(Math.random() * otherMarkets.length)];
        const availableCommodities = DB.COMMODITIES.filter(c => c.tier <= player.revealedTier);
        const commodity = availableCommodities[Math.floor(Math.random() * availableCommodities.length)];
        
        if (commodity) {
            this.gameState.intel.active = { 
                targetMarketId: targetMarket.id,
                commodityId: commodity.id, 
                type: 'demand',
                startDay: day,
                endDay: day + 100 
            };
        }
        this.gameState.setState({});
    }

    /**
     * Processes one "tick" of refueling while the button is held, costing credits and adding fuel.
     * @returns {number} - The cost of the fuel tick, or 0 if no fuel was added.
     */
    refuelTick() {
        const state = this.gameState;
        const ship = this.simulationService._getActiveShip();
        if (ship.fuel >= ship.maxFuel) return 0;

        let costPerTick = DB.MARKETS.find(m => m.id === state.currentLocationId).fuelPrice / 2;
        if (state.player.activePerks[PERK_IDS.VENETIAN_SYNDICATE] && state.currentLocationId === LOCATION_IDS.VENUS) {
            costPerTick *= (1 - DB.PERKS[PERK_IDS.VENETIAN_SYNDICATE].fuelDiscount);
        }
        if (state.player.credits < costPerTick) return 0;

        state.player.credits -= costPerTick;
        state.player.shipStates[ship.id].fuel = Math.min(ship.maxFuel, state.player.shipStates[ship.id].fuel + 5);
        this.simulationService._logConsolidatedTransaction('fuel', -costPerTick, 'Fuel Purchase');
        this.gameState.setState({});
        return costPerTick;
    }

    /**
     * Processes one "tick" of repairing while the button is held, costing credits and restoring health.
     * @returns {number} - The cost of the repair tick, or 0 if no repairs were made.
     */
    repairTick() {
        const state = this.gameState;
        const ship = this.simulationService._getActiveShip();
        if (ship.health >= ship.maxHealth) return 0;
        
        let costPerTick = (ship.maxHealth * (GAME_RULES.REPAIR_AMOUNT_PER_TICK / 100)) * GAME_RULES.REPAIR_COST_PER_HP;
        if (state.player.activePerks[PERK_IDS.VENETIAN_SYNDICATE] && state.currentLocationId === LOCATION_IDS.VENUS) {
            costPerTick *= (1 - DB.PERKS[PERK_IDS.VENETIAN_SYNDICATE].repairDiscount);
        }
        if (state.player.credits < costPerTick) return 0;
        
        state.player.credits -= costPerTick;
        state.player.shipStates[ship.id].health = Math.min(ship.maxHealth, state.player.shipStates[ship.id].health + (ship.maxHealth * (GAME_RULES.REPAIR_AMOUNT_PER_TICK / 100)));
        this.simulationService._logConsolidatedTransaction('repair', -costPerTick, 'Hull Repairs');
        this.simulationService._checkHullWarnings(ship.id);
        this.gameState.setState({});
        return costPerTick;
    }

    /**
     * Calculates the effect of diminishing returns on a sale.
     * @param {string} goodId The ID of the commodity being sold.
     * @param {number} quantity The amount being sold.
     * @param {string} locationId The ID of the market location.
     * @returns {{totalPrice: number, effectivePricePerUnit: number}}
     * @private
     */
    _calculateDiminishingReturns(goodId, quantity, locationId) {
        const good = DB.COMMODITIES.find(c => c.id === goodId);
        const marketStock = this.gameState.market.inventory[locationId][goodId].quantity;
        const basePrice = this.uiManager.getItemPrice(this.gameState.getState(), goodId, true);
        
        const threshold = marketStock * 0.1;
        if (quantity <= threshold) {
            return { totalPrice: basePrice * quantity, effectivePricePerUnit: basePrice };
        }

        const excessRatio = quantity / marketStock;
        let reduction = 0;

        if (good.tier <= 2) { // Low-Tier
            reduction = Math.min(0.10, (excessRatio - 0.1) * 0.2);
        } else if (good.tier <= 5) { // Mid-Tier
            reduction = Math.min(0.25, (excessRatio - 0.1) * 0.5);
        } else { // High-Tier
            reduction = Math.min(0.40, (excessRatio - 0.1) * 0.8);
        }
        
        const effectivePrice = basePrice * (1 - reduction);
        return {
            totalPrice: Math.floor(effectivePrice * quantity),
            effectivePricePerUnit: effectivePrice
        };
    }
}
--- END OF FILE: ./js/services/player/PlayerActionService.js ---

--- START OF FILE: ./meta/CHANGELOG.md ---
# Changelog

All notable changes to the Orbital Trading project will be documented in this file.

## [27.10] - 2025-09-29
- SimulationService refactor
- EventManager refactor
- created Architectural Decisions meta file
- created Roadmap meta file


## [27.00] - 2025-09-28
- shipyard/hangar overhaul
- UI update

## [26.15] - 2025-09-20
- portrait mode enforcement
- PWA optimization

## [26.10] - 2025-09-20
- UI update
- cargo overhaul

## [26.00] - 2025-09-18
- celebratory effects layer
- updated lexicon.json
- updated data_flow.md

## [25.60] - 2025-09-16
- tutorial update
- writing
- license bug fixes

## [25.50] - 2025-09-15
- refactoring
- bug fixes

## [25.40] - 2025-09-15
- removed tutorial editor tooling
- improved sub nav bar visibility

## [25.30] - 2025-09-14
- tutorial editor tools

## [25.20] - 2025-09-13
- scrollbar indicator

## [25.20] - 2025-09-13
- console debug diagnostic tools

## [25.10] - 2025-09-12
- minimizable commodities

## [25.00] - 2025-09-12
- launch confirmation modal

## [24.70] - 2025-09-10
- shipyard/hangar visual overhaul
- balance update
- writing update

## [24.30] - 2025-09-7
- cargo visual overhaul

## [24.20] - 2025-09-6
- economy v4 update
- commodity card update

## [24.00] - 2025-09-3
- economy v3 update
- progression update
- ship cargo balancing
- wealth milestone update

## [23.20] - 2025-08-31
- diminishing returns in economy
- expected profit display

## [23.00] - 2025-08-30
- navigation bar overhaul

## [22.30] - 2025-08-29
- debug/market toasts removed
- economy adjusted

## [22.20] - 2025-08-28
- transaction module visual overhaul

## [22.10] - 2025-08-28
- debug gui for visual overhauls added
- market screen visuals updated

## [22.00] - 2025-08-28
- CSS Refactor

## [21.01] - 2025-08-24
- transaction visual overhaul
- indicator overhaul

## [21.00] - 2025-08-24
- intro completed
- tutorial completed
- removed tutorial highlighting
- writing polish

## [20.02] - 2025-08-17
- Polished introduction sequence with gated navigation access
- UI polish

## [20.01] - 2025-08-16
- Implemented mission prerequisite system. Missions now only appear when their conditions are met.

## [20.00] - 2025-08-15
- implemented V1 MissionEngine

## [19.14] - 2025-08-11
- intro overhaul
- shipyard/hanger tutorial v1
- style, writing, and functionality polish

## [19.13] - 2025-08-10
- bug fixes
- polish

## [19.12] - 2025-08-09
- v1 intro sequence

## [19.11] - 2025-08-07
- removed test tools

## [19.09] - 2025-08-07
- updated lexicon
- new build tools: OrbitalBuilder

## [19.08] - 2025-08-06
- added meta/ folder
- added lexicon.json
- added CHANGELOG.md
- commentary overhaul

## [19.07] - 2025-07-XX
- Added extensive code comments to improve readability and AI-assisted development.
- Reached a stable build, code is considered well-documented.

## [19.06] - 2025-07-XX
- Created `combine.sh` script to aggregate project files for analysis.

## [19.05] - 2025-07-XX
- Overhauled UI navigation with a new top-bar and sub-navigation system.
- Refactored screen rendering logic in `UIManager.js`.

## [19.04] - 2025-07-XX
- Major refactor of game logic into distinct services (`GameState`, `SimulationService`, `EventManager`).
--- END OF FILE: ./meta/CHANGELOG.md ---

--- START OF FILE: ./meta/lexicon.json ---
{
  "project_info": {
    "project_name": "Orbital Trading",
    "synopsis": "A single-player, persistent browser game about interstellar arbitrage trading and capital accumulation.",
    "core_mechanics": [
      "arbitrage_trading",
      "ship_progression",
      "procedural_events",
      "debt_management",
      "wealth_milestones"
    ],
    "gameplay_loop": "Player travels between locations -> trades commodities based on market prices -> uses profits to upgrade ship and pay debt -> unlocks new locations/commodities -> repeats."
  },
  "ai_collaboration_guidelines": {
    "description": "Instructions for AI developers to optimize the collaborative workflow with the human designer/playtester.",
    "bug_reporting_protocol": {
      "title": "Standard Bug Reporting and Diagnostic Workflow",
      "steps": [
        "When the user reports a bug or unexpected behavior, ALWAYS first ask them to generate a bug report.",
        "Instruct the user to open the debug panel (using the backtick '`' key) and click the 'Generate Bug Report' button.",
        "Ask the user to paste the entire clipboard content, which will contain both the full game state snapshot and the recent log history.",
        "Analyze the provided game state to understand the exact conditions at the time of the bug. Do not assume; use the state as the single source of truth.",
        "Analyze the log history to trace the sequence of events leading up to the bug. The logs provide critical context that a simple description cannot.",
        "Use the combined information from the state snapshot and log history to perform a root cause analysis and propose a specific, targeted code fix."
      ]
    },
    "logging_utility_overview": {
      "title": "About the Centralized Logging System",
      "description": "The project uses a centralized LoggingService (F030) to manage all console output. This system is designed to provide clear, filterable, and context-rich information for debugging. Ad-hoc 'console.log' statements should not be used; all new logging must be routed through this service."
    }
  },
  "key_concepts": {
    "Market_Pressure": "A value representing recent player trading activity for a commodity at a specific location. Heavy selling increases pressure, driving prices down over time, while heavy buying decreases it, driving prices up.",
    "Galactic_Average": "The baseline, long-term average price for a commodity across the entire system. Market prices tend to revert to this average over time.",
    "Diminishing_Returns": "A mechanic that reduces the sale price of a commodity when selling large quantities at once, simulating the effect of flooding a market and reducing demand.",
    "Wealth_Milestones": "Specific credit thresholds that, when reached by the player, unlock higher tiers of commodities for trading, gating progression.",
    "Random_Events": "Procedurally triggered events that can occur during travel, presenting the player with choices that have various risks and rewards."
  },
  "service_summaries": {
    "GameState": {
      "description": "The single source of truth for all mutable game data. It holds the current state and notifies other services of changes.",
      "dependencies": [],
      "key_functions": {
        "setState": "Merges a partial state object into the main state and notifies subscribers.",
        "getState": "Returns a deep copy of the current game state.",
        "startNewGame": "Initializes the entire game state for a new session.",
        "subscribe": "Allows other services (primarily UIManager) to listen for state changes."
      },
      "mutates_state": ["day", "currentLocationId", "player", "market", "missions", "tutorials", "introSequenceActive", "uiState"]
    },
    "SimulationService": {
      "description": "The core game engine **Facade**. It instantiates and coordinates all specialized services. It receives calls from the EventManager and delegates them to the appropriate service. It also hosts shared helper methods needed by multiple services.",
      "dependencies": ["GameState", "UIManager", "Logger", "MarketService", "TimeService", "TravelService", "IntroService", "PlayerActionService", "TutorialService", "MissionService"],
      "key_functions": {
        "constructor": "Instantiates all specialized services.",
        "setScreen": "Sets the active navigation tab and screen.",
        "travelTo": "Facade method that delegates to TravelService.",
        "buyItem": "Facade method that delegates to PlayerActionService."
      },
      "mutates_state": ["activeNav", "activeScreen", "isGameOver", "uiState"]
    },
    "IntroService": {
      "description": "Manages the entire new game introduction sequence, from the initial lore modals to the final tutorial kickoff.",
      "dependencies": ["GameState", "UIManager", "Logger", "SimulationService (Facade)"],
      "key_functions": {
        "start": "Begins the intro sequence.",
        "handleIntroClick": "Handles clicks on intro-specific buttons.",
        "continueAfterTutorial": "Resumes the intro sequence after a tutorial batch is completed."
      },
      "mutates_state": ["player.introStep", "player.name", "player.debt", "introSequenceActive"]
    },
    "PlayerActionService": {
      "description": "Manages all direct, player-initiated actions that have an immediate effect, such as buying/selling commodities, purchasing ships, and using station services (refuel/repair).",
      "dependencies": ["GameState", "UIManager", "MissionService", "MarketService", "TimeService", "Logger", "SimulationService (Facade)"],
      "key_functions": {
        "buyItem": "Handles the logic for purchasing a commodity.",
        "sellItem": "Handles the logic for selling a commodity.",
        "buyShip": "Manages the purchase of a new ship.",
        "refuelTick": "Processes one 'tick' of refueling."
      },
      "mutates_state": ["player.credits", "player.debt", "player.inventories", "player.shipStates", "player.ownedShipIds", "market.inventory"]
    },
    "TravelService": {
      "description": "Handles all aspects of interstellar travel, including initiating trips, calculating costs, and managing the random event system during transit.",
      "dependencies": ["GameState", "UIManager", "TimeService", "Logger", "SimulationService (Facade)"],
      "key_functions": {
        "travelTo": "Validates and begins travel to a new location.",
        "initiateTravel": "Executes the core travel logic, consuming fuel and time.",
        "resumeTravel": "Continues a pending travel action after an event."
      },
      "mutates_state": ["pendingTravel", "player.shipStates.health", "player.shipStates.fuel"]
    },
    "TimeService": {
      "description": "Responsible for advancing the game clock (`advanceDays`) and triggering all time-based events like birthdays, debt interest charges, and weekly market updates.",
      "dependencies": ["GameState", "MarketService", "UIManager", "Logger", "SimulationService (Facade)"],
      "key_functions": {
        "advanceDays": "Advances game time and triggers all associated daily, weekly, and monthly logic."
      },
      "mutates_state": ["day", "player.playerAge", "player.debt", "player.shipStates.health", "market.prices", "market.inventory"]
    },
    "MarketService": {
      "description": "Handles the simulation of the in-game economy, including price evolution, inventory replenishment, and applying market pressure from player trades.",
      "dependencies": ["GameState"],
      "key_functions": {
          "evolveMarketPrices": "Simulates daily price changes for all commodities.",
          "replenishMarketInventory": "Handles the weekly restocking of all markets.",
          "applyMarketImpact": "Adjusts market pressure based on player buy/sell actions.",
          "_updateShipyardStock": "Updates the available ships for sale at each location."
      },
      "mutates_state": ["market.prices", "market.inventory", "market.shipyardStock"]
    },
    "UIManager": {
      "description": "Responsible for rendering the entire UI based on the current GameState. It reads from the state but never modifies it. It also manages visual effects via the EffectsManager.",
      "dependencies": ["Logger", "EffectsManager", "MissionService", "SimulationService"],
      "key_functions": {
        "render": "The main function that orchestrates the re-drawing of all UI components.",
        "queueModal": "Manages a queue for displaying modals to prevent overlap.",
        "triggerEffect": "Initiates a visual effect through the EffectsManager."
      },
      "mutates_state": []
    },
    "EventManager": {
      "description": "The universal input layer. Instantiates specialized handlers, binds global listeners, and delegates event handling to the appropriate module.",
      "dependencies": ["GameState", "SimulationService", "UIManager", "TutorialService", "DebugService", "Logger"],
      "key_functions": {
        "bindEvents": "Sets up all global event listeners for the application.",
        "_handleClick": "The central delegated click handler that routes events to the appropriate handler module."
      },
      "mutates_state": []
    },
    "ActionClickHandler": {
        "description": "Handles general `data-action` click events, such as navigation, modal triggers, and simple state changes.",
        "dependencies": ["GameState", "SimulationService", "UIManager", "TutorialService"],
        "key_functions": {"handle": "Processes a click event on an element with a `data-action` attribute."},
        "mutates_state": []
    },
    "MarketEventHandler": {
        "description": "Manages all interactions within a market commodity card, including mode toggling, quantity changes, and trade confirmations.",
        "dependencies": ["GameState", "SimulationService", "UIManager"],
        "key_functions": {"handleClick": "Handles clicks on market card controls.", "handleInput": "Handles direct input into the quantity field."},
        "mutates_state": []
    },
    "HoldEventHandler": {
        "description": "Manages the 'hold-to-act' functionality for continuous actions like refueling and repairing.",
        "dependencies": ["GameState", "SimulationService", "UIManager"],
        "key_functions": {"handleHoldStart": "Starts a continuous action.", "handleHoldEnd": "Stops all continuous actions."},
        "mutates_state": []
    },
    "CarouselEventHandler": {
        "description": "Encapsulates all logic for the drag, swipe, and scroll functionality of the hangar/shipyard carousel.",
        "dependencies": ["GameState", "SimulationService"],
        "key_functions": {"handleDragStart": "Initiates a drag sequence.", "handleDragMove": "Updates the carousel during a drag.", "handleDragEnd": "Concludes a drag sequence and snaps to a page.", "handleWheel": "Handles mouse wheel scrolling."},
        "mutates_state": []
    },
    "TooltipHandler": {
        "description": "Manages the display and lifecycle of tooltips, price graphs, and other contextual pop-ups on both desktop (hover) and mobile (click).",
        "dependencies": ["GameState", "UIManager"],
        "key_functions": {"handleClick": "Manages tooltip visibility on click.", "handleMouseOver": "Shows tooltips on hover.", "handleMouseOut": "Hides tooltips on hover out."},
        "mutates_state": []
    },
    "MissionService": {
        "description": "Manages the state, progression, and availability of player missions.",
        "dependencies": ["GameState", "UIManager", "Logger", "SimulationService"],
        "key_functions": {
            "getAvailableMissions": "Returns a list of all missions whose prerequisites are met.",
            "acceptMission": "Sets a mission as active and initializes its progress tracking.",
            "checkTriggers": "Checks if the objectives for the active mission are met based on the current game state.",
            "completeActiveMission": "Grants rewards and updates mission state upon successful completion."
        },
        "mutates_state": ["missions.activeMissionId", "missions.completedMissionIds", "missions.missionProgress", "missions.activeMissionObjectivesMet"]
    }
  },
  "asset_index": {
    "F001": {"path": "./index.html", "role": "DOCUMENT_ROOT"},
    "F003": {"path": "./js/main.js", "role": "ENTRY_POINT"},
    "F004": {"path": "./js/utils.js", "role": "UTILITY_LIBRARY"},
    "F005": {"path": "./js/data/constants.js", "role": "DATA_DEFINITION"},
    "F006": {"path": "./js/data/database.js", "role": "DATA_DEFINITION"},
    "F009": {"path": "./js/services/GameState.js", "role": "STATE_MANAGER"},
    "F010": {"path": "./js/services/simulation/MarketService.js", "role": "LOGIC_SERVICE"},
    "F011": {"path": "./js/services/SimulationService.js", "role": "LOGIC_FACADE"},
    "F014": {"path": "./js/services/eventEffectResolver.js", "role": "LOGIC_SERVICE"},
    "F015": {"path": "./js/services/EventManager.js", "role": "EVENT_HANDLER"},
    "F016": {"path": "./js/services/TutorialService.js", "role": "LOGIC_SERVICE"},
    "F017": {"path": "./js/services/UIManager.js", "role": "UI_RENDERER"},
    "F018": {"path": "./js/services/MissionService.js", "role": "LOGIC_SERVICE"},
    "F019": {"path": "./js/ui/components/CargoScreen.js", "role": "UI_COMPONENT"},
    "F020": {"path": "./js/ui/components/FinanceScreen.js", "role": "UI_COMPONENT"},
    "F021": {"path": "./js/ui/components/HangarScreen.js", "role": "UI_COMPONENT"},
    "F022": {"path": "./js/ui/components/IntelScreen.js", "role": "UI_COMPONENT"},
    "F023": {"path": "./js/ui/components/MarketScreen.js", "role": "UI_COMPONENT"},
    "F024": {"path": "./js/ui/components/MissionsScreen.js", "role": "UI_COMPONENT"},
    "F025": {"path": "./js/ui/components/NavigationScreen.js", "role": "UI_COMPONENT"},
    "F026": {"path": "./js/ui/components/ServicesScreen.js", "role": "UI_COMPONENT"},
    "F027": {"path": "./js/ui/components/StatusScreen.js", "role": "UI_COMPONENT"},
    "F029": {"path": "./js/services/DebugService.js", "role": "DEBUG_TOOL"},
    "F030": {"path": "./js/services/LoggingService.js", "role": "DEBUG_TOOL"},
    "F031": {"path": "./js/effects/BaseEffect.js", "role": "LOGIC_MODULE"},
    "F032": {"path": "./js/effects/EffectsManager.js", "role": "LOGIC_SERVICE"},
    "F033": {"path": "./js/effects/SystemSurgeEffect.js", "role": "LOGIC_MODULE"},
    "F034": {"path": "./js/services/game/IntroService.js", "role": "LOGIC_SERVICE"},
    "F035": {"path": "./js/services/player/PlayerActionService.js", "role": "LOGIC_SERVICE"},
    "F036": {"path": "./js/services/world/TimeService.js", "role": "LOGIC_SERVICE"},
    "F037": {"path": "./js/services/world/TravelService.js", "role": "LOGIC_SERVICE"},
    "F038": {"path": "./meta/ROADMAP.md", "role": "DOCUMENTATION"},
    "F039": {"path": "./meta/ARCHITECTURAL_DECISIONS.md", "role": "DOCUMENTATION"},
    "F040": {"path": "./js/services/handlers/ActionClickHandler.js", "role": "EVENT_HANDLER"},
    "F041": {"path": "./js/services/handlers/MarketEventHandler.js", "role": "EVENT_HANDLER"},
    "F042": {"path": "./js/services/handlers/HoldEventHandler.js", "role": "EVENT_HANDLER"},
    "F043": {"path": "./js/services/handlers/CarouselEventHandler.js", "role": "EVENT_HANDLER"},
    "F044": {"path": "./js/services/handlers/TooltipHandler.js", "role": "EVENT_HANDLER"}
  }
}
--- END OF FILE: ./meta/lexicon.json ---

--- START OF FILE: ./meta/ROADMAP.md ---
# Orbital Trading - Development Roadmap
This document outlines the planned features and high-level goals for the future development of Orbital Trading.

## Immediate Concerns, Bugs, Issues
- Tutorial step hangar_2 not correctly transition to hangar_3 because shipyard mode isn't changing to hangar mode on shipyard screen after purchase and disappearance of first ship
- Ship card dismissal transition animations broken
- Transactions reset the scroll page position on the market screen
- Introduce screen-surge effects vignette


## Planned Ideas
- Screen transitions
- Overhaul ship fuel, hull costs and gameplay
- Improve finance screen, logging
- Verify consistency in projected journey stats vs actual
- Design cononical missions, storyline
- Refine licenses
- Overhaul ship status screen
- Overhaul intel screen
- Refine ship storage


## Long-Term Ideas
- System states influencing market performance
- Refine commodities names, identity
- Design and canonize color themes, Orbital Trading brand, lore, planets, aesthetics
- Finalize mobile views
- Optimize repititive calculations, long-term data accumulation, and re-renders
- Reputation system
- News ticker


## Far-Future Wishlist Ideas ()
- Purchasable stations
- Each ship has a unique nav bar
- Cargo possesses a weight, reducing ship fuel efficiency
- Desktop version with super ultra wide compatibility
- Extend gameplay with simple but robust IAP DLC
--- END OF FILE: ./meta/ROADMAP.md ---

--- START OF FILE: ./meta/ARCHITECTURAL_DECISIONS.md ---
# Architectural Decision Records (ADRs)

This document records the key architectural decisions made during the development of Orbital Trading. Understanding the "why" behind these decisions is crucial for maintaining a consistent and robust codebase.

---

### 1. Unidirectional Data Flow Model

**Decision Date:** 2025-08-26

**Decision:** The project strictly adheres to a unidirectional data flow model (Input -> Logic -> State -> Render).

**Reason:** This model ensures that all state mutations are predictable and easily traceable. By centralizing state changes within `GameState` and having a single trigger point (`GameState.setState()`), we prevent complex, circular dependencies where a UI update could accidentally trigger more logic. This makes debugging significantly more straightforward and the overall application more stable.

---

### 2. SimulationService as a Facade

**Decision Date:** 2025-09-28

**Decision:** `SimulationService.js` was refactored from a monolithic "do-everything" class into a lean **Facade**.

**Reason:** The original `SimulationService` had too many disparate responsibilities (e.g., handling player actions, time progression, travel, and the intro sequence), which violated the Single Responsibility Principle and made the file difficult to maintain. The Facade pattern was chosen because it maintains a simple, consistent API for the `EventManager` while delegating all complex work to new, specialized services (`PlayerActionService`, `TravelService`, etc.). This dramatically improves code organization and makes it much easier to locate and modify specific pieces of game logic.

---

### 3. Decoupling Event Handling with Specialized Modules

**Decision Date:** 2025-09-30

**Decision:** The monolithic `EventManager` was refactored into a coordinator class that delegates to specialized, single-responsibility handler modules (e.g., `MarketEventHandler`, `CarouselEventHandler`).

**Reason:** To improve code readability, maintainability, and separation of concerns in alignment with the project's architectural principles. The original `EventManager` violated the Single Responsibility Principle, making it difficult to modify and debug. The new structure isolates the logic for complex UI components like the market and carousel, making them easier to manage and extend.

---
--- END OF FILE: ./meta/ARCHITECTURAL_DECISIONS.md ---

--- START OF FILE: ./meta/DATA_FLOW.md ---
# Orbital Trading - Core Data Flow (Post-Refactor)

## System Architecture

-   **Model**: Unidirectional Data Flow
-   **Description**: A predictable and traceable state mutation model. `SimulationService` acts as a central **Facade** that delegates logic to specialized services.
-   **Primary Services**:
    1.  **EventManager**: The universal input layer. Captures DOM events and delegates them to the appropriate specialized **Handler Service** or the **SimulationService**.
        -   **Handler Services**: `ActionClickHandler`, `MarketEventHandler`, `HoldEventHandler`, `CarouselEventHandler`, and `TooltipHandler` process raw user input into specific game actions.
    2.  **SimulationService (Facade)**: The central coordinator. It receives calls from `EventManager` and delegates them to the appropriate specialized service. It is the only service that should directly call `GameState.setState()`.
    3.  **Specialized Services**:
        -   `IntroService`: Manages the new game introduction sequence.
        -   `PlayerActionService`: Handles immediate player actions (buy, sell, refuel, etc.).
        -   `TravelService`: Manages all logic related to interstellar travel and events.
        -   `TimeService`: Controls the passage of game time and time-based events.
    4.  **GameState**: The single source of truth for all dynamic data.
    5.  **UIManager**: The output layer, responsible for rendering the game state.
    6.  **EffectsManager**: A dedicated service within the UIManager for handling visual effects.

---

## Core Data Flows

### Flow: Core Logic Loop

1.  **Actor**: `User`
    -   **Action**: Interacts with a UI element (e.g., clicks a "Buy" button).
    -   **Target**: `DOM`

2.  **Actor**: `EventManager`
    -   **Action**: Captures the DOM event.
    -   **Target**: `Specialized Handler` (e.g., `ActionClickHandler`)
    -   **Details**: The `EventManager`'s global listeners pass the event to the relevant handler based on the event type (e.g., 'click', 'mousedown').

3.  **Actor**: `Specialized Handler` (e.g., `ActionClickHandler`)
    -   **Action**: Interprets the event and calls the appropriate high-level service.
    -   **Target**: `SimulationService (Facade)`
    -   **Details**: Reads the `data-action` attribute and calls the corresponding public method on the `SimulationService` facade (e.g., `simulationService.buyItem(...)`).

4.  **Actor**: `SimulationService (Facade)`
    -   **Action**: Delegates the call to the appropriate specialized service.
    -   **Target**: `PlayerActionService` (in this example)
    -   **Details**: The facade's `buyItem` method simply calls `this.playerActionService.buyItem(...)`.

5.  **Actor**: `PlayerActionService` (or other specialized service)
    -   **Action**: Executes the core game logic.
    -   **Target**: `GameState`
    -   **Details**: The service validates the action, calculates the outcome (e.g., deducts credits, adds cargo), and then calls `GameState.setState()` to mutate the state. This is the **sole point of state mutation**.

6.  **Actor**: `GameState`
    -   **Action**: Notifies subscribers of the state change.
    -   **Target**: `UIManager`
    -   **Details**: The `setState` method triggers the `_notify` method, which calls the `render` function subscribed by the `UIManager`.

7.  **Actor**: `UIManager`
    -   **Action**: Re-renders all necessary UI components.
    -   **Target**: `DOM`
    -   **Details**: Reads the entire updated state from `GameState` to ensure the UI is a perfect reflection of the current game state.
--- END OF FILE: ./meta/DATA_FLOW.md ---

--- START OF FILE: ./manifest.json ---
{
  "short_name": "Orbital Trading",
  "name": "Orbital Trading",
  "start_url": "./index.html",
  "orientation": "portrait-primary",
  "display": "standalone",
  "background_color": "#0c101d",
  "theme_color": "#0c101d"
}
--- END OF FILE: ./manifest.json ---

--- START OF FILE: ./sw.js ---
// Minimal service worker to enable PWA installability.
self.addEventListener('fetch', (event) => {
  // This basic fetch handler is sufficient to make the app installable.
});
--- END OF FILE: ./sw.js ---

